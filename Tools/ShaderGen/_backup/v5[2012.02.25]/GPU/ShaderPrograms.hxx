/* Do NOT modify this file! It has been autogenerated by the tools.*/
/* File created by HLSL wrapper generator version 0.5 on Friday, February 24th, at 23-39-13 */
/* Copyright © 2012 ShaderGen.*/

#pragma once

// Shaders

// 20 shader programs (67 unique combinations)

#include <Renderer/GPU/HLSL/BuildConfig.h>

namespace GPU
{
	//==============================================================================================================================================
	//
	//	p_batched_lines
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_editor_shaders.fx(6,7)
	struct MX_GRAPHICS_API p_batched_lines
	{
#pragma pack (push,16)
		struct Data
		{
			float4x4 transform;
		};
#pragma pack (pop)
	
	public:	// Constant buffers (manually updated)
		static TConstantBuffer< Data >	cb_Data;	// VS
	
	public:	// Sampler states (set manually)
		static ID3D11SamplerState* linearSampler;	// PS
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* textureMap;	// PS
								enum { SR_Slot_textureMap = 0 };
	
	public:	// Read-only properties
		enum { UID = 0 }; // unique index (within this shader library)
		enum { NumInstances = 2 }; // number of unique combinations
		// Integer bit masks for identifying unique shader program combinations:
		enum Variations
		{
			bTextureMap = BIT(0), //default=0
			DefaultInstanceId = 0
		};
	
	public:	// Public member functions
		static FORCEINLINE BOOL IsValidInstanceId( rxShaderInstanceId instanceId )
		{
			return ( instanceId < p_batched_lines::NumInstances );
		}
		static FORCEINLINE ShaderInstance& GetInstance( rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			Assert( IsValidInstanceId( instanceId ) );
			return shaderInstances[ instanceId ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			// Bind constant buffers
			cb_Data.BindTo_VS( theContext, 0 );
			
			// Bind sampler states to slots
			theContext->PSSetSamplers(
				0,
				1,
				(ID3D11SamplerState**)&linearSampler
			);
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				0,
				1,
				(ID3D11ShaderResourceView**)&textureMap
			);
			
			// Bind shader program
			ShaderInstance & program = GetInstance( instanceId );
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11Buffer* old_VS_CBs[ 1 ];
			ID3D11SamplerState* old_PS_SS[ 1 ];
			ID3D11ShaderResourceView* old_PS_SRVs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
			{
				pD3DContext = theContext;
				pD3DContext->VSGetConstantBuffers( 0, 1, old_VS_CBs );
				pD3DContext->PSGetSamplers( 0, 1, old_PS_SS );
				pD3DContext->PSGetShaderResources( 0, 1, old_PS_SRVs );
				p_batched_lines::Set( pD3DContext, instanceId );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->VSSetConstantBuffers( 0, 1, old_VS_CBs );	D3D_SafeReleaseArray( old_VS_CBs );
				pD3DContext->PSSetSamplers( 0, 1, old_PS_SS );	D3D_SafeReleaseArray( old_PS_SS );
				pD3DContext->PSSetShaderResources( 0, 1, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_batched_lines() {}
		
		static ShaderInstance	shaderInstances[ p_batched_lines::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_build_hw_shadow_map
	//
	//	uses Shared_Globals, Shared_View	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_shadow_mapping.fx(9,7)
	struct MX_GRAPHICS_API p_build_hw_shadow_map
	{
#pragma pack (push,16)
		struct Data
		{
			float4x4 lightWVP;
		};
#pragma pack (pop)
	
	public:	// Constant buffers (manually updated)
		static TConstantBuffer< Data >	cb_Data;	// VS
	
	public:	// Read-only properties
		enum { UID = 1 }; // unique index (within this shader library)
		enum { NumInstances = 1 }; // number of unique combinations
	
	public:	// Public member functions
		static FORCEINLINE ShaderInstance& GetInstance()
		{
			return shaderInstances[ 0 ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext )
		{
			// Bind constant buffers
			cb_Data.BindTo_VS( theContext, 2 );
			
			// Bind shader program
			ShaderInstance & program = shaderInstances[ 0 ];
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				nil,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11Buffer* old_VS_CBs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext )
			{
				pD3DContext = theContext;
				pD3DContext->VSGetConstantBuffers( 2, 1, old_VS_CBs );
				p_build_hw_shadow_map::Set( pD3DContext );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->VSSetConstantBuffers( 2, 1, old_VS_CBs );	D3D_SafeReleaseArray( old_VS_CBs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_build_hw_shadow_map() {}
		
		static ShaderInstance	shaderInstances[ p_build_hw_shadow_map::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_debug_gbuffer_show_diffuse
	//
	//	uses Shared_Globals, Shared_View, Shared_GBuffer	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_debug_shaders.fx(6,7)
	struct MX_GRAPHICS_API p_debug_gbuffer_show_diffuse
	{
	
	public:	// Read-only properties
		enum { UID = 2 }; // unique index (within this shader library)
		enum { NumInstances = 1 }; // number of unique combinations
	
	public:	// Public member functions
		static FORCEINLINE ShaderInstance& GetInstance()
		{
			return shaderInstances[ 0 ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext )
		{
			// Bind shader program
			ShaderInstance & program = shaderInstances[ 0 ];
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext )
			{
				pD3DContext = theContext;
				p_debug_gbuffer_show_diffuse::Set( pD3DContext );
			}
			FORCEINLINE ~SetScoped()
			{
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_debug_gbuffer_show_diffuse() {}
		
		static ShaderInstance	shaderInstances[ p_debug_gbuffer_show_diffuse::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_deferred_directional_light
	//
	//	uses Shared_Globals, Shared_View, Shared_GBuffer	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_deferred_lighting.fx(13,7)
	struct MX_GRAPHICS_API p_deferred_directional_light
	{
#pragma pack (push,16)
		struct Data
		{
			float4 lightVectorVS;
			float4 lightDiffuseColor;
			float4 lightSpecularColor;
			float4x4 shadowMatrices[ NUM_SHADOW_CASCADES ];
			float4 cascadeSplits;
		};
#pragma pack (pop)
	
	public:	// Constant buffers (manually updated)
		static TConstantBuffer< Data >	cb_Data;	// PS
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* shadowDepthMap;	// PS
								enum { SR_Slot_shadowDepthMap = 3 };
	
	public:	// Read-only properties
		enum { UID = 3 }; // unique index (within this shader library)
		enum { NumInstances = 8 }; // number of unique combinations
		// Integer bit masks for identifying unique shader program combinations:
		enum Variations
		{
			bLight_CastShadows = BIT(0), //default=0
			bEnableSoftShadows = BIT(1), //default=1
			bVisualizeCascades = BIT(2), //default=0
			DefaultInstanceId = 1
		};
	
	public:	// Public member functions
		static FORCEINLINE BOOL IsValidInstanceId( rxShaderInstanceId instanceId )
		{
			return ( instanceId < p_deferred_directional_light::NumInstances );
		}
		static FORCEINLINE ShaderInstance& GetInstance( rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			Assert( IsValidInstanceId( instanceId ) );
			return shaderInstances[ instanceId ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			// Bind constant buffers
			cb_Data.BindTo_PS( theContext, 2 );
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				3,
				1,
				(ID3D11ShaderResourceView**)&shadowDepthMap
			);
			
			// Bind shader program
			ShaderInstance & program = GetInstance( instanceId );
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11Buffer* old_PS_CBs[ 1 ];
			ID3D11ShaderResourceView* old_PS_SRVs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetConstantBuffers( 2, 1, old_PS_CBs );
				pD3DContext->PSGetShaderResources( 3, 1, old_PS_SRVs );
				p_deferred_directional_light::Set( pD3DContext, instanceId );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetConstantBuffers( 2, 1, old_PS_CBs );	D3D_SafeReleaseArray( old_PS_CBs );
				pD3DContext->PSSetShaderResources( 3, 1, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_deferred_directional_light() {}
		
		static ShaderInstance	shaderInstances[ p_deferred_directional_light::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_deferred_fullscreen_point_light
	//
	//	uses Shared_Globals, Shared_View, Shared_GBuffer, Shared_LocalLightData	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_deferred_lighting.fx(246,7)
	struct MX_GRAPHICS_API p_deferred_fullscreen_point_light
	{
	
	public:	// Read-only properties
		enum { UID = 4 }; // unique index (within this shader library)
		enum { NumInstances = 2 }; // number of unique combinations
		// Integer bit masks for identifying unique shader program combinations:
		enum Variations
		{
			bLight_EnableSpecular = BIT(0), //default=0
			DefaultInstanceId = 0
		};
	
	public:	// Public member functions
		static FORCEINLINE BOOL IsValidInstanceId( rxShaderInstanceId instanceId )
		{
			return ( instanceId < p_deferred_fullscreen_point_light::NumInstances );
		}
		static FORCEINLINE ShaderInstance& GetInstance( rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			Assert( IsValidInstanceId( instanceId ) );
			return shaderInstances[ instanceId ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			// Bind shader program
			ShaderInstance & program = GetInstance( instanceId );
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
			{
				pD3DContext = theContext;
				p_deferred_fullscreen_point_light::Set( pD3DContext, instanceId );
			}
			FORCEINLINE ~SetScoped()
			{
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_deferred_fullscreen_point_light() {}
		
		static ShaderInstance	shaderInstances[ p_deferred_fullscreen_point_light::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_deferred_fullscreen_spot_light
	//
	//	uses Shared_Globals, Shared_View, Shared_GBuffer, Shared_LocalLightData	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_deferred_lighting.fx(325,7)
	struct MX_GRAPHICS_API p_deferred_fullscreen_spot_light
	{
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* projector;	// PS
								enum { SR_Slot_projector = 3 };
		static ID3D11ShaderResourceView* shadowDepthMap;	// PS
								enum { SR_Slot_shadowDepthMap = 4 };
	
	public:	// Read-only properties
		enum { UID = 5 }; // unique index (within this shader library)
		enum { NumInstances = 8 }; // number of unique combinations
		// Integer bit masks for identifying unique shader program combinations:
		enum Variations
		{
			bLight_EnableSpecular = BIT(0), //default=0
			bSpotLight_ProjectsTexture = BIT(1), //default=0
			bSpotLight_CastShadows = BIT(2), //default=0
			DefaultInstanceId = 0
		};
	
	public:	// Public member functions
		static FORCEINLINE BOOL IsValidInstanceId( rxShaderInstanceId instanceId )
		{
			return ( instanceId < p_deferred_fullscreen_spot_light::NumInstances );
		}
		static FORCEINLINE ShaderInstance& GetInstance( rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			Assert( IsValidInstanceId( instanceId ) );
			return shaderInstances[ instanceId ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				3,
				2,
				(ID3D11ShaderResourceView**)&projector
			);
			
			// Bind shader program
			ShaderInstance & program = GetInstance( instanceId );
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11ShaderResourceView* old_PS_SRVs[ 2 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetShaderResources( 3, 2, old_PS_SRVs );
				p_deferred_fullscreen_spot_light::Set( pD3DContext, instanceId );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetShaderResources( 3, 2, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_deferred_fullscreen_spot_light() {}
		
		static ShaderInstance	shaderInstances[ p_deferred_fullscreen_spot_light::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_deferred_local_point_light
	//
	//	uses Shared_Globals, Shared_View, Shared_GBuffer, Shared_LocalLightData	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_deferred_lighting.fx(286,7)
	struct MX_GRAPHICS_API p_deferred_local_point_light
	{
	
	public:	// Read-only properties
		enum { UID = 6 }; // unique index (within this shader library)
		enum { NumInstances = 2 }; // number of unique combinations
		// Integer bit masks for identifying unique shader program combinations:
		enum Variations
		{
			bLight_EnableSpecular = BIT(0), //default=0
			DefaultInstanceId = 0
		};
	
	public:	// Public member functions
		static FORCEINLINE BOOL IsValidInstanceId( rxShaderInstanceId instanceId )
		{
			return ( instanceId < p_deferred_local_point_light::NumInstances );
		}
		static FORCEINLINE ShaderInstance& GetInstance( rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			Assert( IsValidInstanceId( instanceId ) );
			return shaderInstances[ instanceId ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			// Bind shader program
			ShaderInstance & program = GetInstance( instanceId );
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
			{
				pD3DContext = theContext;
				p_deferred_local_point_light::Set( pD3DContext, instanceId );
			}
			FORCEINLINE ~SetScoped()
			{
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_deferred_local_point_light() {}
		
		static ShaderInstance	shaderInstances[ p_deferred_local_point_light::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_deferred_local_spot_light
	//
	//	uses Shared_Globals, Shared_View, Shared_GBuffer, Shared_LocalLightData	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_deferred_lighting.fx(368,7)
	struct MX_GRAPHICS_API p_deferred_local_spot_light
	{
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* projector;	// PS
								enum { SR_Slot_projector = 3 };
		static ID3D11ShaderResourceView* shadowDepthMap;	// PS
								enum { SR_Slot_shadowDepthMap = 4 };
	
	public:	// Read-only properties
		enum { UID = 7 }; // unique index (within this shader library)
		enum { NumInstances = 8 }; // number of unique combinations
		// Integer bit masks for identifying unique shader program combinations:
		enum Variations
		{
			bLight_EnableSpecular = BIT(0), //default=0
			bSpotLight_ProjectsTexture = BIT(1), //default=0
			bSpotLight_CastShadows = BIT(2), //default=0
			DefaultInstanceId = 0
		};
	
	public:	// Public member functions
		static FORCEINLINE BOOL IsValidInstanceId( rxShaderInstanceId instanceId )
		{
			return ( instanceId < p_deferred_local_spot_light::NumInstances );
		}
		static FORCEINLINE ShaderInstance& GetInstance( rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			Assert( IsValidInstanceId( instanceId ) );
			return shaderInstances[ instanceId ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				3,
				2,
				(ID3D11ShaderResourceView**)&projector
			);
			
			// Bind shader program
			ShaderInstance & program = GetInstance( instanceId );
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11ShaderResourceView* old_PS_SRVs[ 2 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetShaderResources( 3, 2, old_PS_SRVs );
				p_deferred_local_spot_light::Set( pD3DContext, instanceId );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetShaderResources( 3, 2, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_deferred_local_spot_light() {}
		
		static ShaderInstance	shaderInstances[ p_deferred_local_spot_light::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_depth_of_field
	//
	//	uses Shared_Globals, Shared_View, Shared_GBuffer	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_post_processing.fx(208,7)
	struct MX_GRAPHICS_API p_depth_of_field
	{
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* sceneColorTexture;	// PS
								enum { SR_Slot_sceneColorTexture = 3 };
		static ID3D11ShaderResourceView* sceneDepthTexture;	// PS
								enum { SR_Slot_sceneDepthTexture = 4 };
		static ID3D11ShaderResourceView* blurredSceneTexture;	// PS
								enum { SR_Slot_blurredSceneTexture = 5 };
	
	public:	// Read-only properties
		enum { UID = 8 }; // unique index (within this shader library)
		enum { NumInstances = 1 }; // number of unique combinations
	
	public:	// Public member functions
		static FORCEINLINE ShaderInstance& GetInstance()
		{
			return shaderInstances[ 0 ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext )
		{
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				3,
				3,
				(ID3D11ShaderResourceView**)&sceneColorTexture
			);
			
			// Bind shader program
			ShaderInstance & program = shaderInstances[ 0 ];
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11ShaderResourceView* old_PS_SRVs[ 3 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetShaderResources( 3, 3, old_PS_SRVs );
				p_depth_of_field::Set( pD3DContext );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetShaderResources( 3, 3, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_depth_of_field() {}
		
		static ShaderInstance	shaderInstances[ p_depth_of_field::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_fullscreen_colored_triangle_shader
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_screen_shader.fx(28,7)
	struct MX_GRAPHICS_API p_fullscreen_colored_triangle_shader
	{
#pragma pack (push,16)
		struct Data
		{
			float4 color;
		};
#pragma pack (pop)
	
	public:	// Constant buffers (manually updated)
		static TConstantBuffer< Data >	cb_Data;	// PS
	
	public:	// Read-only properties
		enum { UID = 9 }; // unique index (within this shader library)
		enum { NumInstances = 1 }; // number of unique combinations
	
	public:	// Public member functions
		static FORCEINLINE ShaderInstance& GetInstance()
		{
			return shaderInstances[ 0 ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext )
		{
			// Bind constant buffers
			cb_Data.BindTo_PS( theContext, 0 );
			
			// Bind shader program
			ShaderInstance & program = shaderInstances[ 0 ];
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11Buffer* old_PS_CBs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetConstantBuffers( 0, 1, old_PS_CBs );
				p_fullscreen_colored_triangle_shader::Set( pD3DContext );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetConstantBuffers( 0, 1, old_PS_CBs );	D3D_SafeReleaseArray( old_PS_CBs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_fullscreen_colored_triangle_shader() {}
		
		static ShaderInstance	shaderInstances[ p_fullscreen_colored_triangle_shader::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_fullscreen_textured_triangle_shader
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_screen_shader.fx(1,7)
	struct MX_GRAPHICS_API p_fullscreen_textured_triangle_shader
	{
	
	public:	// Sampler states (set manually)
		static ID3D11SamplerState* linearSampler;	// PS
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* sourceTexture;	// PS
								enum { SR_Slot_sourceTexture = 0 };
	
	public:	// Read-only properties
		enum { UID = 10 }; // unique index (within this shader library)
		enum { NumInstances = 1 }; // number of unique combinations
	
	public:	// Public member functions
		static FORCEINLINE ShaderInstance& GetInstance()
		{
			return shaderInstances[ 0 ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext )
		{
			
			// Bind sampler states to slots
			theContext->PSSetSamplers(
				0,
				1,
				(ID3D11SamplerState**)&linearSampler
			);
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				0,
				1,
				(ID3D11ShaderResourceView**)&sourceTexture
			);
			
			// Bind shader program
			ShaderInstance & program = shaderInstances[ 0 ];
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11SamplerState* old_PS_SS[ 1 ];
			ID3D11ShaderResourceView* old_PS_SRVs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetSamplers( 0, 1, old_PS_SS );
				pD3DContext->PSGetShaderResources( 0, 1, old_PS_SRVs );
				p_fullscreen_textured_triangle_shader::Set( pD3DContext );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetSamplers( 0, 1, old_PS_SS );	D3D_SafeReleaseArray( old_PS_SS );
				pD3DContext->PSSetShaderResources( 0, 1, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_fullscreen_textured_triangle_shader() {}
		
		static ShaderInstance	shaderInstances[ p_fullscreen_textured_triangle_shader::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_hit_proxy
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_editor_shaders.fx(65,7)
	struct MX_GRAPHICS_API p_hit_proxy
	{
#pragma pack (push,16)
		struct Data
		{
			float4x4 transform;
			float4 hitProxyId;
		};
#pragma pack (pop)
	
	public:	// Constant buffers (manually updated)
		static TConstantBuffer< Data >	cb_Data;	// VS PS
	
	public:	// Read-only properties
		enum { UID = 11 }; // unique index (within this shader library)
		enum { NumInstances = 2 }; // number of unique combinations
		// Integer bit masks for identifying unique shader program combinations:
		enum Variations
		{
			bEnableColorWrites = BIT(0), //default=0
			DefaultInstanceId = 0
		};
	
	public:	// Public member functions
		static FORCEINLINE BOOL IsValidInstanceId( rxShaderInstanceId instanceId )
		{
			return ( instanceId < p_hit_proxy::NumInstances );
		}
		static FORCEINLINE ShaderInstance& GetInstance( rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			Assert( IsValidInstanceId( instanceId ) );
			return shaderInstances[ instanceId ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			// Bind constant buffers
			cb_Data.BindTo_VS( theContext, 0 );
			cb_Data.BindTo_PS( theContext, 0 );
			
			// Bind shader program
			ShaderInstance & program = GetInstance( instanceId );
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11Buffer* old_VS_CBs[ 1 ];
			ID3D11Buffer* old_PS_CBs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
			{
				pD3DContext = theContext;
				pD3DContext->VSGetConstantBuffers( 0, 1, old_VS_CBs );
				pD3DContext->PSGetConstantBuffers( 0, 1, old_PS_CBs );
				p_hit_proxy::Set( pD3DContext, instanceId );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->VSSetConstantBuffers( 0, 1, old_VS_CBs );	D3D_SafeReleaseArray( old_VS_CBs );
				pD3DContext->PSSetConstantBuffers( 0, 1, old_PS_CBs );	D3D_SafeReleaseArray( old_PS_CBs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_hit_proxy() {}
		
		static ShaderInstance	shaderInstances[ p_hit_proxy::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_horizontal_blur
	//
	//	uses Shared_Globals	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_post_processing.fx(12,7)
	struct MX_GRAPHICS_API p_horizontal_blur
	{
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* sourceTexture;	// PS
								enum { SR_Slot_sourceTexture = 0 };
	
	public:	// Read-only properties
		enum { UID = 12 }; // unique index (within this shader library)
		enum { NumInstances = 1 }; // number of unique combinations
	
	public:	// Public member functions
		static FORCEINLINE ShaderInstance& GetInstance()
		{
			return shaderInstances[ 0 ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext )
		{
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				0,
				1,
				(ID3D11ShaderResourceView**)&sourceTexture
			);
			
			// Bind shader program
			ShaderInstance & program = shaderInstances[ 0 ];
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11ShaderResourceView* old_PS_SRVs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetShaderResources( 0, 1, old_PS_SRVs );
				p_horizontal_blur::Set( pD3DContext );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetShaderResources( 0, 1, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_horizontal_blur() {}
		
		static ShaderInstance	shaderInstances[ p_horizontal_blur::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_horizontal_gaussian_blur
	//
	//	uses Shared_Globals	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_post_processing.fx(90,7)
	struct MX_GRAPHICS_API p_horizontal_gaussian_blur
	{
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* sourceTexture;	// PS
								enum { SR_Slot_sourceTexture = 0 };
	
	public:	// Read-only properties
		enum { UID = 13 }; // unique index (within this shader library)
		enum { NumInstances = 1 }; // number of unique combinations
	
	public:	// Public member functions
		static FORCEINLINE ShaderInstance& GetInstance()
		{
			return shaderInstances[ 0 ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext )
		{
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				0,
				1,
				(ID3D11ShaderResourceView**)&sourceTexture
			);
			
			// Bind shader program
			ShaderInstance & program = shaderInstances[ 0 ];
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11ShaderResourceView* old_PS_SRVs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetShaderResources( 0, 1, old_PS_SRVs );
				p_horizontal_gaussian_blur::Set( pD3DContext );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetShaderResources( 0, 1, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_horizontal_gaussian_blur() {}
		
		static ShaderInstance	shaderInstances[ p_horizontal_gaussian_blur::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_material_phong
	//
	//	uses Shared_Globals, Shared_View, Shared_Object	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_materials.fx(75,7)
	struct MX_GRAPHICS_API p_material_phong
	{
#pragma pack (push,16)
		struct Data
		{
			float4 materialDiffuseColor;
			float4 materialSpecularColor;
			float4 materialEmissiveColor;
		};
#pragma pack (pop)
	
	public:	// Constant buffers (manually updated)
		static TConstantBuffer< Data >	cb_Data;	// PS
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* baseMap;	// PS
								enum { SR_Slot_baseMap = 0 };
		static ID3D11ShaderResourceView* normalMap;	// PS
								enum { SR_Slot_normalMap = 1 };
		static ID3D11ShaderResourceView* specularMap;	// PS
								enum { SR_Slot_specularMap = 2 };
	
	public:	// Read-only properties
		enum { UID = 14 }; // unique index (within this shader library)
		enum { NumInstances = 8 }; // number of unique combinations
		// Integer bit masks for identifying unique shader program combinations:
		enum Variations
		{
			bHasBaseMap = BIT(0), //default=0
			bHasNormalMap = BIT(1), //default=0
			bHasSpecularMap = BIT(2), //default=0
			DefaultInstanceId = 0
		};
	
	public:	// Public member functions
		static FORCEINLINE BOOL IsValidInstanceId( rxShaderInstanceId instanceId )
		{
			return ( instanceId < p_material_phong::NumInstances );
		}
		static FORCEINLINE ShaderInstance& GetInstance( rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			Assert( IsValidInstanceId( instanceId ) );
			return shaderInstances[ instanceId ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			// Bind constant buffers
			cb_Data.BindTo_PS( theContext, 3 );
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				0,
				3,
				(ID3D11ShaderResourceView**)&baseMap
			);
			
			// Bind shader program
			ShaderInstance & program = GetInstance( instanceId );
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11Buffer* old_PS_CBs[ 1 ];
			ID3D11ShaderResourceView* old_PS_SRVs[ 3 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetConstantBuffers( 3, 1, old_PS_CBs );
				pD3DContext->PSGetShaderResources( 0, 3, old_PS_SRVs );
				p_material_phong::Set( pD3DContext, instanceId );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetConstantBuffers( 3, 1, old_PS_CBs );	D3D_SafeReleaseArray( old_PS_CBs );
				pD3DContext->PSSetShaderResources( 0, 3, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_material_phong() {}
		
		static ShaderInstance	shaderInstances[ p_material_phong::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_material_plain_color
	//
	//	uses Shared_Globals, Shared_View, Shared_Object	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_materials.fx(13,7)
	struct MX_GRAPHICS_API p_material_plain_color
	{
#pragma pack (push,16)
		struct Data
		{
			float4 materialDiffuseColor;
			float4 materialSpecularColor;
		};
#pragma pack (pop)
	
	public:	// Constant buffers (manually updated)
		static TConstantBuffer< Data >	cb_Data;	// PS
	
	public:	// Read-only properties
		enum { UID = 15 }; // unique index (within this shader library)
		enum { NumInstances = 1 }; // number of unique combinations
	
	public:	// Public member functions
		static FORCEINLINE ShaderInstance& GetInstance()
		{
			return shaderInstances[ 0 ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext )
		{
			// Bind constant buffers
			cb_Data.BindTo_PS( theContext, 3 );
			
			// Bind shader program
			ShaderInstance & program = shaderInstances[ 0 ];
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11Buffer* old_PS_CBs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetConstantBuffers( 3, 1, old_PS_CBs );
				p_material_plain_color::Set( pD3DContext );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetConstantBuffers( 3, 1, old_PS_CBs );	D3D_SafeReleaseArray( old_PS_CBs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_material_plain_color() {}
		
		static ShaderInstance	shaderInstances[ p_material_plain_color::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_sky_dome
	//
	//	uses Shared_Globals, Shared_View	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_sky_shaders.fx(8,7)
	struct MX_GRAPHICS_API p_sky_dome
	{
#pragma pack (push,16)
		struct Data
		{
			float4x4 skyDomeTransform;
		};
#pragma pack (pop)
	
	public:	// Constant buffers (manually updated)
		static TConstantBuffer< Data >	cb_Data;	// VS
	
	public:	// Sampler states (set manually)
		static ID3D11SamplerState* skyTextureSampler;	// PS
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* skyTexture;	// PS
								enum { SR_Slot_skyTexture = 0 };
	
	public:	// Read-only properties
		enum { UID = 16 }; // unique index (within this shader library)
		enum { NumInstances = 1 }; // number of unique combinations
	
	public:	// Public member functions
		static FORCEINLINE ShaderInstance& GetInstance()
		{
			return shaderInstances[ 0 ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext )
		{
			// Bind constant buffers
			cb_Data.BindTo_VS( theContext, 2 );
			
			// Bind sampler states to slots
			theContext->PSSetSamplers(
				14,
				1,
				(ID3D11SamplerState**)&skyTextureSampler
			);
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				0,
				1,
				(ID3D11ShaderResourceView**)&skyTexture
			);
			
			// Bind shader program
			ShaderInstance & program = shaderInstances[ 0 ];
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11Buffer* old_VS_CBs[ 1 ];
			ID3D11SamplerState* old_PS_SS[ 1 ];
			ID3D11ShaderResourceView* old_PS_SRVs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext )
			{
				pD3DContext = theContext;
				pD3DContext->VSGetConstantBuffers( 2, 1, old_VS_CBs );
				pD3DContext->PSGetSamplers( 14, 1, old_PS_SS );
				pD3DContext->PSGetShaderResources( 0, 1, old_PS_SRVs );
				p_sky_dome::Set( pD3DContext );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->VSSetConstantBuffers( 2, 1, old_VS_CBs );	D3D_SafeReleaseArray( old_VS_CBs );
				pD3DContext->PSSetSamplers( 14, 1, old_PS_SS );	D3D_SafeReleaseArray( old_PS_SS );
				pD3DContext->PSSetShaderResources( 0, 1, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_sky_dome() {}
		
		static ShaderInstance	shaderInstances[ p_sky_dome::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_uber_post_processing_shader
	//
	//	uses Shared_Globals, Shared_View, Shared_GBuffer	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_post_processing.fx(248,7)
	struct MX_GRAPHICS_API p_uber_post_processing_shader
	{
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* sceneColorTexture;	// PS
								enum { SR_Slot_sceneColorTexture = 3 };
		static ID3D11ShaderResourceView* sceneDepthTexture;	// PS
								enum { SR_Slot_sceneDepthTexture = 4 };
		static ID3D11ShaderResourceView* blurredSceneTexture;	// PS
								enum { SR_Slot_blurredSceneTexture = 5 };
		static ID3D11ShaderResourceView* randomNormalsTexture;	// PS
								enum { SR_Slot_randomNormalsTexture = 6 };
	
	public:	// Read-only properties
		enum { UID = 17 }; // unique index (within this shader library)
		enum { NumInstances = 16 }; // number of unique combinations
		// Integer bit masks for identifying unique shader program combinations:
		enum Variations
		{
			bEnable_Bloom = BIT(0), //default=1
			bEnable_HDR = BIT(1), //default=1
			bEnable_DOF = BIT(2), //default=1
			bEnable_SSAO = BIT(3), //default=1
			DefaultInstanceId = 1
		};
	
	public:	// Public member functions
		static FORCEINLINE BOOL IsValidInstanceId( rxShaderInstanceId instanceId )
		{
			return ( instanceId < p_uber_post_processing_shader::NumInstances );
		}
		static FORCEINLINE ShaderInstance& GetInstance( rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			Assert( IsValidInstanceId( instanceId ) );
			return shaderInstances[ instanceId ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				3,
				4,
				(ID3D11ShaderResourceView**)&sceneColorTexture
			);
			
			// Bind shader program
			ShaderInstance & program = GetInstance( instanceId );
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11ShaderResourceView* old_PS_SRVs[ 4 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetShaderResources( 3, 4, old_PS_SRVs );
				p_uber_post_processing_shader::Set( pD3DContext, instanceId );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetShaderResources( 3, 4, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_uber_post_processing_shader() {}
		
		static ShaderInstance	shaderInstances[ p_uber_post_processing_shader::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_vertical_blur
	//
	//	uses Shared_Globals	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_post_processing.fx(49,7)
	struct MX_GRAPHICS_API p_vertical_blur
	{
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* sourceTexture;	// PS
								enum { SR_Slot_sourceTexture = 0 };
	
	public:	// Read-only properties
		enum { UID = 18 }; // unique index (within this shader library)
		enum { NumInstances = 1 }; // number of unique combinations
	
	public:	// Public member functions
		static FORCEINLINE ShaderInstance& GetInstance()
		{
			return shaderInstances[ 0 ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext )
		{
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				0,
				1,
				(ID3D11ShaderResourceView**)&sourceTexture
			);
			
			// Bind shader program
			ShaderInstance & program = shaderInstances[ 0 ];
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11ShaderResourceView* old_PS_SRVs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetShaderResources( 0, 1, old_PS_SRVs );
				p_vertical_blur::Set( pD3DContext );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetShaderResources( 0, 1, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_vertical_blur() {}
		
		static ShaderInstance	shaderInstances[ p_vertical_blur::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_vertical_gaussian_blur
	//
	//	uses Shared_Globals	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_post_processing.fx(127,7)
	struct MX_GRAPHICS_API p_vertical_gaussian_blur
	{
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* sourceTexture;	// PS
								enum { SR_Slot_sourceTexture = 0 };
	
	public:	// Read-only properties
		enum { UID = 19 }; // unique index (within this shader library)
		enum { NumInstances = 1 }; // number of unique combinations
	
	public:	// Public member functions
		static FORCEINLINE ShaderInstance& GetInstance()
		{
			return shaderInstances[ 0 ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext )
		{
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				0,
				1,
				(ID3D11ShaderResourceView**)&sourceTexture
			);
			
			// Bind shader program
			ShaderInstance & program = shaderInstances[ 0 ];
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11ShaderResourceView* old_PS_SRVs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetShaderResources( 0, 1, old_PS_SRVs );
				p_vertical_gaussian_blur::Set( pD3DContext );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetShaderResources( 0, 1, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_vertical_gaussian_blur() {}
		
		static ShaderInstance	shaderInstances[ p_vertical_gaussian_blur::NumInstances ];
	};
	
	
} // namespace GPU

//--------------------------------------------------------------//
//				End Of File.									//
//--------------------------------------------------------------//

