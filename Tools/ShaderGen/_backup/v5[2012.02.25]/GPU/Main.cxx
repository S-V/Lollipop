/* Do NOT modify this file! It has been autogenerated by the tools.*/
/* File created by HLSL wrapper generator version 0.5 on Friday, February 24th, at 23-39-13 */
/* Copyright © 2012 ShaderGen.*/

/* This ALWAYS GENERATED file contains the definitions for the interfaces */

#include "Renderer_PCH.h"
#pragma hdrstop
#include "Renderer.h"

// for BinaryStringSearch()
#include <Base/Text/TextUtils.h>

// for dxVertexFormat
#include <Graphics/DX11/DX11Private.h>

// for assemble_vertex_data()
#include <Renderer/Core/Geometry.h>

#include "Main.hxx"
#include "ShaderPrograms.hxx"
#include "VertexFormats.hxx"

namespace GPU
{
	// 02.24.2012  23:39
	const FileTime TIME_STAMP( 1582599280, 30208820 );
	
	// sorted in ascending order
	const char* g_shaderNames[ TotalNumberOfShaders ] =
	{
		"p_batched_lines",
		"p_build_hw_shadow_map",
		"p_debug_gbuffer_show_diffuse",
		"p_deferred_directional_light",
		"p_deferred_fullscreen_point_light",
		"p_deferred_fullscreen_spot_light",
		"p_deferred_local_point_light",
		"p_deferred_local_spot_light",
		"p_depth_of_field",
		"p_fullscreen_colored_triangle_shader",
		"p_fullscreen_textured_triangle_shader",
		"p_hit_proxy",
		"p_horizontal_blur",
		"p_horizontal_gaussian_blur",
		"p_material_phong",
		"p_material_plain_color",
		"p_sky_dome",
		"p_uber_post_processing_shader",
		"p_vertical_blur",
		"p_vertical_gaussian_blur",
	};
	
	UINT ShaderNameToIndex( const char* str ) {
		return BinaryStringSearch( g_shaderNames, ARRAY_SIZE(g_shaderNames), str );
	}
	
	const char* ShaderIndexToName( UINT idx ) {
		Assert( idx < ARRAY_SIZE(g_shaderNames) );
		return g_shaderNames[ idx ];
	}
	
	//===========================================================================
	//	Render targets
	//===========================================================================
	
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(11,13)
	RenderTarget RT_Normal_SpecIntensity;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(20,13)
	RenderTarget RT_Diffuse_SpecPower;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(29,13)
	RenderTarget RT_LinearDepth;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(71,13)
	RenderTarget RT_HDR_SceneColor;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(80,13)
	RenderTarget RT_Ping;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(87,13)
	RenderTarget RT_Pong;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(96,13)
	RenderTarget RT_Downscaled_4x4;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(103,13)
	RenderTarget RT_HBlur_Map;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(110,13)
	RenderTarget RT_FinalBlur_Map;
	
	static void SetupRenderTargets( const UINT sizeX, const UINT sizeY )
	{
		D3D11_TEXTURE2D_DESC texDesc;
		D3D11_RENDER_TARGET_VIEW_DESC rtvDesc;
		D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
		
// RT_Normal_SpecIntensity
// "Normals & Specular intensity"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(11,13)
		Assert( RT_Normal_SpecIntensity.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R8G8B8A8_UNORM;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_Normal_SpecIntensity, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_Normal_SpecIntensity.pTexture, "RT_Normal_SpecIntensity_T2D" );
			dxDbgSetName( RT_Normal_SpecIntensity.pRTV, "RT_Normal_SpecIntensity_RTV" );
			dxDbgSetName( RT_Normal_SpecIntensity.pSRV, "RT_Normal_SpecIntensity_SRV" );
		}
// RT_Diffuse_SpecPower
// "Diffuse & Specular power"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(20,13)
		Assert( RT_Diffuse_SpecPower.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R8G8B8A8_UNORM;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_Diffuse_SpecPower, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_Diffuse_SpecPower.pTexture, "RT_Diffuse_SpecPower_T2D" );
			dxDbgSetName( RT_Diffuse_SpecPower.pRTV, "RT_Diffuse_SpecPower_RTV" );
			dxDbgSetName( RT_Diffuse_SpecPower.pSRV, "RT_Diffuse_SpecPower_SRV" );
		}
// RT_LinearDepth
// "Depth"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(29,13)
		Assert( RT_LinearDepth.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R32_FLOAT;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R32_FLOAT;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R32_FLOAT;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_LinearDepth, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_LinearDepth.pTexture, "RT_LinearDepth_T2D" );
			dxDbgSetName( RT_LinearDepth.pRTV, "RT_LinearDepth_RTV" );
			dxDbgSetName( RT_LinearDepth.pSRV, "RT_LinearDepth_SRV" );
		}
// RT_HDR_SceneColor
// "HDR Light Accum"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(71,13)
		Assert( RT_HDR_SceneColor.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R16G16B16A16_FLOAT;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R16G16B16A16_FLOAT;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R16G16B16A16_FLOAT;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_HDR_SceneColor, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_HDR_SceneColor.pTexture, "RT_HDR_SceneColor_T2D" );
			dxDbgSetName( RT_HDR_SceneColor.pRTV, "RT_HDR_SceneColor_RTV" );
			dxDbgSetName( RT_HDR_SceneColor.pSRV, "RT_HDR_SceneColor_SRV" );
		}
// RT_Ping
// "Temporary storage"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(80,13)
		Assert( RT_Ping.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R8G8B8A8_UNORM;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_Ping, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_Ping.pTexture, "RT_Ping_T2D" );
			dxDbgSetName( RT_Ping.pRTV, "RT_Ping_RTV" );
			dxDbgSetName( RT_Ping.pSRV, "RT_Ping_SRV" );
		}
// RT_Pong
// "Temporary storage"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(87,13)
		Assert( RT_Pong.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R8G8B8A8_UNORM;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_Pong, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_Pong.pTexture, "RT_Pong_T2D" );
			dxDbgSetName( RT_Pong.pRTV, "RT_Pong_RTV" );
			dxDbgSetName( RT_Pong.pSRV, "RT_Pong_SRV" );
		}
// RT_Downscaled_4x4
// "Downscaled map for bloom"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(96,13)
		Assert( RT_Downscaled_4x4.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			texDesc.Width				= sizeX * 0.250000f;
			texDesc.Height				= sizeY * 0.250000f;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R8G8B8A8_UNORM;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_Downscaled_4x4, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_Downscaled_4x4.pTexture, "RT_Downscaled_4x4_T2D" );
			dxDbgSetName( RT_Downscaled_4x4.pRTV, "RT_Downscaled_4x4_RTV" );
			dxDbgSetName( RT_Downscaled_4x4.pSRV, "RT_Downscaled_4x4_SRV" );
		}
// RT_HBlur_Map
// "HBlur map for bloom"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(103,13)
		Assert( RT_HBlur_Map.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			texDesc.Width				= sizeX * 0.250000f;
			texDesc.Height				= sizeY * 0.250000f;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R8G8B8A8_UNORM;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_HBlur_Map, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_HBlur_Map.pTexture, "RT_HBlur_Map_T2D" );
			dxDbgSetName( RT_HBlur_Map.pRTV, "RT_HBlur_Map_RTV" );
			dxDbgSetName( RT_HBlur_Map.pSRV, "RT_HBlur_Map_SRV" );
		}
// RT_FinalBlur_Map
// "Final blur map for bloom"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(110,13)
		Assert( RT_FinalBlur_Map.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			texDesc.Width				= sizeX * 0.250000f;
			texDesc.Height				= sizeY * 0.250000f;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R8G8B8A8_UNORM;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_FinalBlur_Map, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_FinalBlur_Map.pTexture, "RT_FinalBlur_Map_T2D" );
			dxDbgSetName( RT_FinalBlur_Map.pRTV, "RT_FinalBlur_Map_RTV" );
			dxDbgSetName( RT_FinalBlur_Map.pSRV, "RT_FinalBlur_Map_SRV" );
		}
	}
	
	// releases render targets that depend on backbuffer size; should be called before resizing viewports
	void ReleaseRenderTargets()
	{
		RT_Normal_SpecIntensity.Release();
		RT_Diffuse_SpecPower.Release();
		RT_LinearDepth.Release();
		RT_HDR_SceneColor.Release();
		RT_Ping.Release();
		RT_Pong.Release();
		RT_Downscaled_4x4.Release();
		RT_HBlur_Map.Release();
		RT_FinalBlur_Map.Release();
	}
	
	// recreates render targets that depend on backbuffer size; should be called after resizing viewports
	void ReallocRenderTargets( UINT sizeX, UINT sizeY )
	{
		D3D11_TEXTURE2D_DESC texDesc;
		D3D11_RENDER_TARGET_VIEW_DESC rtvDesc;
		D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
		
		Assert( RT_Normal_SpecIntensity.IsNull() );
// RT_Normal_SpecIntensity
// "Normals & Specular intensity"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(11,13)
		Assert( RT_Normal_SpecIntensity.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R8G8B8A8_UNORM;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_Normal_SpecIntensity, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_Normal_SpecIntensity.pTexture, "RT_Normal_SpecIntensity_T2D" );
			dxDbgSetName( RT_Normal_SpecIntensity.pRTV, "RT_Normal_SpecIntensity_RTV" );
			dxDbgSetName( RT_Normal_SpecIntensity.pSRV, "RT_Normal_SpecIntensity_SRV" );
		}
		
		Assert( RT_Diffuse_SpecPower.IsNull() );
// RT_Diffuse_SpecPower
// "Diffuse & Specular power"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(20,13)
		Assert( RT_Diffuse_SpecPower.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R8G8B8A8_UNORM;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_Diffuse_SpecPower, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_Diffuse_SpecPower.pTexture, "RT_Diffuse_SpecPower_T2D" );
			dxDbgSetName( RT_Diffuse_SpecPower.pRTV, "RT_Diffuse_SpecPower_RTV" );
			dxDbgSetName( RT_Diffuse_SpecPower.pSRV, "RT_Diffuse_SpecPower_SRV" );
		}
		
		Assert( RT_LinearDepth.IsNull() );
// RT_LinearDepth
// "Depth"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(29,13)
		Assert( RT_LinearDepth.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R32_FLOAT;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R32_FLOAT;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R32_FLOAT;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_LinearDepth, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_LinearDepth.pTexture, "RT_LinearDepth_T2D" );
			dxDbgSetName( RT_LinearDepth.pRTV, "RT_LinearDepth_RTV" );
			dxDbgSetName( RT_LinearDepth.pSRV, "RT_LinearDepth_SRV" );
		}
		
		Assert( RT_HDR_SceneColor.IsNull() );
// RT_HDR_SceneColor
// "HDR Light Accum"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(71,13)
		Assert( RT_HDR_SceneColor.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R16G16B16A16_FLOAT;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R16G16B16A16_FLOAT;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R16G16B16A16_FLOAT;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_HDR_SceneColor, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_HDR_SceneColor.pTexture, "RT_HDR_SceneColor_T2D" );
			dxDbgSetName( RT_HDR_SceneColor.pRTV, "RT_HDR_SceneColor_RTV" );
			dxDbgSetName( RT_HDR_SceneColor.pSRV, "RT_HDR_SceneColor_SRV" );
		}
		
		Assert( RT_Ping.IsNull() );
// RT_Ping
// "Temporary storage"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(80,13)
		Assert( RT_Ping.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R8G8B8A8_UNORM;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_Ping, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_Ping.pTexture, "RT_Ping_T2D" );
			dxDbgSetName( RT_Ping.pRTV, "RT_Ping_RTV" );
			dxDbgSetName( RT_Ping.pSRV, "RT_Ping_SRV" );
		}
		
		Assert( RT_Pong.IsNull() );
// RT_Pong
// "Temporary storage"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(87,13)
		Assert( RT_Pong.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R8G8B8A8_UNORM;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_Pong, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_Pong.pTexture, "RT_Pong_T2D" );
			dxDbgSetName( RT_Pong.pRTV, "RT_Pong_RTV" );
			dxDbgSetName( RT_Pong.pSRV, "RT_Pong_SRV" );
		}
		
		Assert( RT_Downscaled_4x4.IsNull() );
// RT_Downscaled_4x4
// "Downscaled map for bloom"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(96,13)
		Assert( RT_Downscaled_4x4.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			texDesc.Width				= sizeX * 0.250000f;
			texDesc.Height				= sizeY * 0.250000f;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R8G8B8A8_UNORM;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_Downscaled_4x4, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_Downscaled_4x4.pTexture, "RT_Downscaled_4x4_T2D" );
			dxDbgSetName( RT_Downscaled_4x4.pRTV, "RT_Downscaled_4x4_RTV" );
			dxDbgSetName( RT_Downscaled_4x4.pSRV, "RT_Downscaled_4x4_SRV" );
		}
		
		Assert( RT_HBlur_Map.IsNull() );
// RT_HBlur_Map
// "HBlur map for bloom"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(103,13)
		Assert( RT_HBlur_Map.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			texDesc.Width				= sizeX * 0.250000f;
			texDesc.Height				= sizeY * 0.250000f;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R8G8B8A8_UNORM;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_HBlur_Map, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_HBlur_Map.pTexture, "RT_HBlur_Map_T2D" );
			dxDbgSetName( RT_HBlur_Map.pRTV, "RT_HBlur_Map_RTV" );
			dxDbgSetName( RT_HBlur_Map.pSRV, "RT_HBlur_Map_SRV" );
		}
		
		Assert( RT_FinalBlur_Map.IsNull() );
// RT_FinalBlur_Map
// "Final blur map for bloom"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(110,13)
		Assert( RT_FinalBlur_Map.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			texDesc.Width				= sizeX * 0.250000f;
			texDesc.Height				= sizeY * 0.250000f;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R8G8B8A8_UNORM;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_FinalBlur_Map, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_FinalBlur_Map.pTexture, "RT_FinalBlur_Map_T2D" );
			dxDbgSetName( RT_FinalBlur_Map.pRTV, "RT_FinalBlur_Map_RTV" );
			dxDbgSetName( RT_FinalBlur_Map.pSRV, "RT_FinalBlur_Map_SRV" );
		}
	}
	
	void EnumerateRenderTargets( F_EnumerateRenderTargets* callback, void* userData )
	{
		(*callback)( &RT_Normal_SpecIntensity, userData );
		(*callback)( &RT_Diffuse_SpecPower, userData );
		(*callback)( &RT_LinearDepth, userData );
		(*callback)( &RT_HDR_SceneColor, userData );
		(*callback)( &RT_Ping, userData );
		(*callback)( &RT_Pong, userData );
		(*callback)( &RT_Downscaled_4x4, userData );
		(*callback)( &RT_HBlur_Map, userData );
		(*callback)( &RT_FinalBlur_Map, userData );
	}
	
	//===========================================================================
	//	Sampler states
	//===========================================================================
	
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(7,13)
	ID3D11SamplerStatePtr SS_Point;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(13,13)
	ID3D11SamplerStatePtr SS_Bilinear;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(20,13)
	ID3D11SamplerStatePtr SS_Trilinear;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(27,13)
	ID3D11SamplerStatePtr SS_Aniso;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(35,13)
	ID3D11SamplerStatePtr SS_PointClamp;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(41,13)
	ID3D11SamplerStatePtr SS_LinearClamp;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(49,13)
	ID3D11SamplerStatePtr SS_ShadowMap;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(63,13)
	ID3D11SamplerStatePtr SS_ShadowMapPCF;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(77,13)
	ID3D11SamplerStatePtr SS_ShadowMapPCF_Bilinear;
	
	static void SetupSamplerStates()
	{
		D3D11_SAMPLER_DESC samplerDesc;
		
// SS_Point
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(7,13)
		{
			samplerDesc.Filter	= D3D11_FILTER_MIN_MAG_MIP_POINT;
			samplerDesc.AddressU	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.AddressV	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.AddressW	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.MipLODBias		= 0.000000f;
			samplerDesc.MaxAnisotropy	= 1;
			samplerDesc.ComparisonFunc	= D3D11_COMPARISON_NEVER;
			samplerDesc.BorderColor[0]	= 1.000000f;
			samplerDesc.BorderColor[1]	= 1.000000f;
			samplerDesc.BorderColor[2]	= 1.000000f;
			samplerDesc.BorderColor[3]	= 1.000000f;
			samplerDesc.MinLOD			= 0.0f;
			samplerDesc.MaxLOD			= D3D11_FLOAT32_MAX;
			
			graphics.resources->Create_SamplerState( SS_Point, samplerDesc );
			dxDbgSetName( SS_Point, "SS_Point" );
		}
		
// SS_Bilinear
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(13,13)
		{
			samplerDesc.Filter	= D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT;
			samplerDesc.AddressU	= D3D11_TEXTURE_ADDRESS_WRAP;
			samplerDesc.AddressV	= D3D11_TEXTURE_ADDRESS_WRAP;
			samplerDesc.AddressW	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.MipLODBias		= 0.000000f;
			samplerDesc.MaxAnisotropy	= 1;
			samplerDesc.ComparisonFunc	= D3D11_COMPARISON_NEVER;
			samplerDesc.BorderColor[0]	= 1.000000f;
			samplerDesc.BorderColor[1]	= 1.000000f;
			samplerDesc.BorderColor[2]	= 1.000000f;
			samplerDesc.BorderColor[3]	= 1.000000f;
			samplerDesc.MinLOD			= 0.0f;
			samplerDesc.MaxLOD			= D3D11_FLOAT32_MAX;
			
			graphics.resources->Create_SamplerState( SS_Bilinear, samplerDesc );
			dxDbgSetName( SS_Bilinear, "SS_Bilinear" );
		}
		
// SS_Trilinear
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(20,13)
		{
			samplerDesc.Filter	= D3D11_FILTER_MIN_MAG_MIP_LINEAR;
			samplerDesc.AddressU	= D3D11_TEXTURE_ADDRESS_WRAP;
			samplerDesc.AddressV	= D3D11_TEXTURE_ADDRESS_WRAP;
			samplerDesc.AddressW	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.MipLODBias		= 0.000000f;
			samplerDesc.MaxAnisotropy	= 1;
			samplerDesc.ComparisonFunc	= D3D11_COMPARISON_NEVER;
			samplerDesc.BorderColor[0]	= 1.000000f;
			samplerDesc.BorderColor[1]	= 1.000000f;
			samplerDesc.BorderColor[2]	= 1.000000f;
			samplerDesc.BorderColor[3]	= 1.000000f;
			samplerDesc.MinLOD			= 0.0f;
			samplerDesc.MaxLOD			= D3D11_FLOAT32_MAX;
			
			graphics.resources->Create_SamplerState( SS_Trilinear, samplerDesc );
			dxDbgSetName( SS_Trilinear, "SS_Trilinear" );
		}
		
// SS_Aniso
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(27,13)
		{
			samplerDesc.Filter	= D3D11_FILTER_ANISOTROPIC;
			samplerDesc.AddressU	= D3D11_TEXTURE_ADDRESS_WRAP;
			samplerDesc.AddressV	= D3D11_TEXTURE_ADDRESS_WRAP;
			samplerDesc.AddressW	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.MipLODBias		= 0.000000f;
			samplerDesc.MaxAnisotropy	= 1;
			samplerDesc.ComparisonFunc	= D3D11_COMPARISON_NEVER;
			samplerDesc.BorderColor[0]	= 1.000000f;
			samplerDesc.BorderColor[1]	= 1.000000f;
			samplerDesc.BorderColor[2]	= 1.000000f;
			samplerDesc.BorderColor[3]	= 1.000000f;
			samplerDesc.MinLOD			= 0.0f;
			samplerDesc.MaxLOD			= D3D11_FLOAT32_MAX;
			
			graphics.resources->Create_SamplerState( SS_Aniso, samplerDesc );
			dxDbgSetName( SS_Aniso, "SS_Aniso" );
		}
		
// SS_PointClamp
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(35,13)
		{
			samplerDesc.Filter	= D3D11_FILTER_MIN_MAG_MIP_POINT;
			samplerDesc.AddressU	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.AddressV	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.AddressW	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.MipLODBias		= 0.000000f;
			samplerDesc.MaxAnisotropy	= 1;
			samplerDesc.ComparisonFunc	= D3D11_COMPARISON_NEVER;
			samplerDesc.BorderColor[0]	= 1.000000f;
			samplerDesc.BorderColor[1]	= 1.000000f;
			samplerDesc.BorderColor[2]	= 1.000000f;
			samplerDesc.BorderColor[3]	= 1.000000f;
			samplerDesc.MinLOD			= 0.0f;
			samplerDesc.MaxLOD			= D3D11_FLOAT32_MAX;
			
			graphics.resources->Create_SamplerState( SS_PointClamp, samplerDesc );
			dxDbgSetName( SS_PointClamp, "SS_PointClamp" );
		}
		
// SS_LinearClamp
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(41,13)
		{
			samplerDesc.Filter	= D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT;
			samplerDesc.AddressU	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.AddressV	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.AddressW	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.MipLODBias		= 0.000000f;
			samplerDesc.MaxAnisotropy	= 1;
			samplerDesc.ComparisonFunc	= D3D11_COMPARISON_NEVER;
			samplerDesc.BorderColor[0]	= 1.000000f;
			samplerDesc.BorderColor[1]	= 1.000000f;
			samplerDesc.BorderColor[2]	= 1.000000f;
			samplerDesc.BorderColor[3]	= 1.000000f;
			samplerDesc.MinLOD			= 0.0f;
			samplerDesc.MaxLOD			= D3D11_FLOAT32_MAX;
			
			graphics.resources->Create_SamplerState( SS_LinearClamp, samplerDesc );
			dxDbgSetName( SS_LinearClamp, "SS_LinearClamp" );
		}
		
// SS_ShadowMap
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(49,13)
		{
			samplerDesc.Filter	= D3D11_FILTER_COMPARISON_MIN_MAG_MIP_POINT;
			samplerDesc.AddressU	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.AddressV	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.AddressW	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.MipLODBias		= 0.000000f;
			samplerDesc.MaxAnisotropy	= 1;
			samplerDesc.ComparisonFunc	= D3D11_COMPARISON_LESS_EQUAL;
			samplerDesc.BorderColor[0]	= 0.000000f;
			samplerDesc.BorderColor[1]	= 0.000000f;
			samplerDesc.BorderColor[2]	= 0.000000f;
			samplerDesc.BorderColor[3]	= 0.000000f;
			samplerDesc.MinLOD			= 0.0f;
			samplerDesc.MaxLOD			= D3D11_FLOAT32_MAX;
			
			graphics.resources->Create_SamplerState( SS_ShadowMap, samplerDesc );
			dxDbgSetName( SS_ShadowMap, "SS_ShadowMap" );
		}
		
// SS_ShadowMapPCF
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(63,13)
		{
			samplerDesc.Filter	= D3D11_FILTER_COMPARISON_MIN_MAG_MIP_POINT;
			samplerDesc.AddressU	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.AddressV	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.AddressW	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.MipLODBias		= 0.000000f;
			samplerDesc.MaxAnisotropy	= 1;
			samplerDesc.ComparisonFunc	= D3D11_COMPARISON_LESS_EQUAL;
			samplerDesc.BorderColor[0]	= 0.000000f;
			samplerDesc.BorderColor[1]	= 0.000000f;
			samplerDesc.BorderColor[2]	= 0.000000f;
			samplerDesc.BorderColor[3]	= 0.000000f;
			samplerDesc.MinLOD			= 0.0f;
			samplerDesc.MaxLOD			= D3D11_FLOAT32_MAX;
			
			graphics.resources->Create_SamplerState( SS_ShadowMapPCF, samplerDesc );
			dxDbgSetName( SS_ShadowMapPCF, "SS_ShadowMapPCF" );
		}
		
// SS_ShadowMapPCF_Bilinear
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(77,13)
		{
			samplerDesc.Filter	= D3D11_FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT;
			samplerDesc.AddressU	= D3D11_TEXTURE_ADDRESS_BORDER;
			samplerDesc.AddressV	= D3D11_TEXTURE_ADDRESS_BORDER;
			samplerDesc.AddressW	= D3D11_TEXTURE_ADDRESS_BORDER;
			samplerDesc.MipLODBias		= 0.000000f;
			samplerDesc.MaxAnisotropy	= 1;
			samplerDesc.ComparisonFunc	= D3D11_COMPARISON_LESS;
			samplerDesc.BorderColor[0]	= 0.000000f;
			samplerDesc.BorderColor[1]	= 0.000000f;
			samplerDesc.BorderColor[2]	= 0.000000f;
			samplerDesc.BorderColor[3]	= 0.000000f;
			samplerDesc.MinLOD			= 0.0f;
			samplerDesc.MaxLOD			= D3D11_FLOAT32_MAX;
			
			graphics.resources->Create_SamplerState( SS_ShadowMapPCF_Bilinear, samplerDesc );
			dxDbgSetName( SS_ShadowMapPCF_Bilinear, "SS_ShadowMapPCF_Bilinear" );
		}
	}
	
	void EnumerateSamplerStates( F_EnumerateSamplerStates* callback, void* userData )
	{
		(*callback)( SS_Point, userData );
		(*callback)( SS_Bilinear, userData );
		(*callback)( SS_Trilinear, userData );
		(*callback)( SS_Aniso, userData );
		(*callback)( SS_PointClamp, userData );
		(*callback)( SS_LinearClamp, userData );
		(*callback)( SS_ShadowMap, userData );
		(*callback)( SS_ShadowMapPCF, userData );
		(*callback)( SS_ShadowMapPCF_Bilinear, userData );
	}
	
	//===========================================================================
	//	Depth-Stencil states
	//===========================================================================
	
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(98,18)
	ID3D11DepthStencilStatePtr DS_NormalZTestWriteNoStencil;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(105,18)
	ID3D11DepthStencilStatePtr DS_NormalZTestNoWriteNoStencil;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(112,18)
	ID3D11DepthStencilStatePtr DS_NoZTestWriteNoStencil;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(119,18)
	ID3D11DepthStencilStatePtr DS_ZTestLessEqual_ZWrite_NoStencil;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(131,18)
	ID3D11DepthStencilStatePtr DS_ZTestGreaterNoZWriteNoStencil;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(142,18)
	ID3D11DepthStencilStatePtr DS_ZTestLessEqualNoZWriteNoStencil;
	
	static void SetupDepthStencilStates()
	{
		D3D11_DEPTH_STENCIL_DESC depthStencilDesc;
		
// DS_NormalZTestWriteNoStencil
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(98,18)
		{
			depthStencilDesc.DepthEnable	= TRUE;
			depthStencilDesc.DepthWriteMask	= D3D11_DEPTH_WRITE_MASK_ALL;
			depthStencilDesc.DepthFunc	= D3D11_COMPARISON_LESS;
			depthStencilDesc.StencilEnable	= FALSE;
			depthStencilDesc.StencilReadMask	= D3D11_DEFAULT_STENCIL_READ_MASK;
			depthStencilDesc.StencilWriteMask	= D3D11_DEFAULT_STENCIL_WRITE_MASK;
			depthStencilDesc.FrontFace.StencilFailOp		= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilPassOp		= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			depthStencilDesc.BackFace.StencilFailOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilPassOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			
			graphics.resources->Create_DepthStencilState( DS_NormalZTestWriteNoStencil, depthStencilDesc );
			dxDbgSetName( DS_NormalZTestWriteNoStencil, "DS_NormalZTestWriteNoStencil" );
		}
		
// DS_NormalZTestNoWriteNoStencil
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(105,18)
		{
			depthStencilDesc.DepthEnable	= TRUE;
			depthStencilDesc.DepthWriteMask	= D3D11_DEPTH_WRITE_MASK_ZERO;
			depthStencilDesc.DepthFunc	= D3D11_COMPARISON_LESS;
			depthStencilDesc.StencilEnable	= FALSE;
			depthStencilDesc.StencilReadMask	= D3D11_DEFAULT_STENCIL_READ_MASK;
			depthStencilDesc.StencilWriteMask	= D3D11_DEFAULT_STENCIL_WRITE_MASK;
			depthStencilDesc.FrontFace.StencilFailOp		= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilPassOp		= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			depthStencilDesc.BackFace.StencilFailOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilPassOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			
			graphics.resources->Create_DepthStencilState( DS_NormalZTestNoWriteNoStencil, depthStencilDesc );
			dxDbgSetName( DS_NormalZTestNoWriteNoStencil, "DS_NormalZTestNoWriteNoStencil" );
		}
		
// DS_NoZTestWriteNoStencil
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(112,18)
		{
			depthStencilDesc.DepthEnable	= FALSE;
			depthStencilDesc.DepthWriteMask	= D3D11_DEPTH_WRITE_MASK_ZERO;
			depthStencilDesc.DepthFunc	= D3D11_COMPARISON_ALWAYS;
			depthStencilDesc.StencilEnable	= FALSE;
			depthStencilDesc.StencilReadMask	= D3D11_DEFAULT_STENCIL_READ_MASK;
			depthStencilDesc.StencilWriteMask	= D3D11_DEFAULT_STENCIL_WRITE_MASK;
			depthStencilDesc.FrontFace.StencilFailOp		= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilPassOp		= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			depthStencilDesc.BackFace.StencilFailOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilPassOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			
			graphics.resources->Create_DepthStencilState( DS_NoZTestWriteNoStencil, depthStencilDesc );
			dxDbgSetName( DS_NoZTestWriteNoStencil, "DS_NoZTestWriteNoStencil" );
		}
		
// DS_ZTestLessEqual_ZWrite_NoStencil
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(119,18)
		{
			depthStencilDesc.DepthEnable	= TRUE;
			depthStencilDesc.DepthWriteMask	= D3D11_DEPTH_WRITE_MASK_ALL;
			depthStencilDesc.DepthFunc	= D3D11_COMPARISON_LESS_EQUAL;
			depthStencilDesc.StencilEnable	= FALSE;
			depthStencilDesc.StencilReadMask	= D3D11_DEFAULT_STENCIL_READ_MASK;
			depthStencilDesc.StencilWriteMask	= D3D11_DEFAULT_STENCIL_WRITE_MASK;
			depthStencilDesc.FrontFace.StencilFailOp		= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilPassOp		= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			depthStencilDesc.BackFace.StencilFailOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilPassOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			
			graphics.resources->Create_DepthStencilState( DS_ZTestLessEqual_ZWrite_NoStencil, depthStencilDesc );
			dxDbgSetName( DS_ZTestLessEqual_ZWrite_NoStencil, "DS_ZTestLessEqual_ZWrite_NoStencil" );
		}
		
// DS_ZTestGreaterNoZWriteNoStencil
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(131,18)
		{
			depthStencilDesc.DepthEnable	= TRUE;
			depthStencilDesc.DepthWriteMask	= D3D11_DEPTH_WRITE_MASK_ZERO;
			depthStencilDesc.DepthFunc	= D3D11_COMPARISON_GREATER;
			depthStencilDesc.StencilEnable	= FALSE;
			depthStencilDesc.StencilReadMask	= D3D11_DEFAULT_STENCIL_READ_MASK;
			depthStencilDesc.StencilWriteMask	= D3D11_DEFAULT_STENCIL_WRITE_MASK;
			depthStencilDesc.FrontFace.StencilFailOp		= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilPassOp		= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			depthStencilDesc.BackFace.StencilFailOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilPassOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			
			graphics.resources->Create_DepthStencilState( DS_ZTestGreaterNoZWriteNoStencil, depthStencilDesc );
			dxDbgSetName( DS_ZTestGreaterNoZWriteNoStencil, "DS_ZTestGreaterNoZWriteNoStencil" );
		}
		
// DS_ZTestLessEqualNoZWriteNoStencil
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(142,18)
		{
			depthStencilDesc.DepthEnable	= TRUE;
			depthStencilDesc.DepthWriteMask	= D3D11_DEPTH_WRITE_MASK_ZERO;
			depthStencilDesc.DepthFunc	= D3D11_COMPARISON_LESS_EQUAL;
			depthStencilDesc.StencilEnable	= FALSE;
			depthStencilDesc.StencilReadMask	= D3D11_DEFAULT_STENCIL_READ_MASK;
			depthStencilDesc.StencilWriteMask	= D3D11_DEFAULT_STENCIL_WRITE_MASK;
			depthStencilDesc.FrontFace.StencilFailOp		= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilPassOp		= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			depthStencilDesc.BackFace.StencilFailOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilPassOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			
			graphics.resources->Create_DepthStencilState( DS_ZTestLessEqualNoZWriteNoStencil, depthStencilDesc );
			dxDbgSetName( DS_ZTestLessEqualNoZWriteNoStencil, "DS_ZTestLessEqualNoZWriteNoStencil" );
		}
	}
	
	void EnumerateDepthStencilStates( F_EnumerateDepthStencilStates* callback, void* userData )
	{
		(*callback)( DS_NormalZTestWriteNoStencil, userData );
		(*callback)( DS_NormalZTestNoWriteNoStencil, userData );
		(*callback)( DS_NoZTestWriteNoStencil, userData );
		(*callback)( DS_ZTestLessEqual_ZWrite_NoStencil, userData );
		(*callback)( DS_ZTestGreaterNoZWriteNoStencil, userData );
		(*callback)( DS_ZTestLessEqualNoZWriteNoStencil, userData );
	}
	
	//===========================================================================
	//	Rasterizer states
	//===========================================================================
	
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(155,16)
	ID3D11RasterizerStatePtr RS_SolidNoCull;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(162,16)
	ID3D11RasterizerStatePtr RS_SolidCullBack;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(169,16)
	ID3D11RasterizerStatePtr RS_SolidCullFront;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(176,16)
	ID3D11RasterizerStatePtr RS_WireframeCullBack;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(184,16)
	ID3D11RasterizerStatePtr RS_SolidNoCullNoClip;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(191,16)
	ID3D11RasterizerStatePtr RS_WireframeNoCullNoClip;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(373,16)
	ID3D11RasterizerStatePtr RS_EyeOutsideLightVolume;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(397,16)
	ID3D11RasterizerStatePtr RS_BuildShadowMap;
	
	static void SetupRasterizerStates()
	{
		D3D11_RASTERIZER_DESC rasterizerDesc;
		
// RS_SolidNoCull
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(155,16)
		{
			rasterizerDesc.FillMode				= D3D11_FILL_SOLID;
			rasterizerDesc.CullMode				= D3D11_CULL_NONE;
			rasterizerDesc.FrontCounterClockwise	= FALSE;
			rasterizerDesc.DepthBias				= 0;
			rasterizerDesc.DepthBiasClamp		= 0.0f;
			rasterizerDesc.SlopeScaledDepthBias	= 0.0f;
			rasterizerDesc.DepthClipEnable		= TRUE;
			rasterizerDesc.ScissorEnable			= FALSE;
			rasterizerDesc.MultisampleEnable		= FALSE;
			rasterizerDesc.AntialiasedLineEnable	= FALSE;
			
			graphics.resources->Create_RasterizerState( RS_SolidNoCull, rasterizerDesc );
			dxDbgSetName( RS_SolidNoCull, "RS_SolidNoCull" );
		}
		
// RS_SolidCullBack
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(162,16)
		{
			rasterizerDesc.FillMode				= D3D11_FILL_SOLID;
			rasterizerDesc.CullMode				= D3D11_CULL_BACK;
			rasterizerDesc.FrontCounterClockwise	= FALSE;
			rasterizerDesc.DepthBias				= 0;
			rasterizerDesc.DepthBiasClamp		= 0.0f;
			rasterizerDesc.SlopeScaledDepthBias	= 0.0f;
			rasterizerDesc.DepthClipEnable		= TRUE;
			rasterizerDesc.ScissorEnable			= FALSE;
			rasterizerDesc.MultisampleEnable		= FALSE;
			rasterizerDesc.AntialiasedLineEnable	= FALSE;
			
			graphics.resources->Create_RasterizerState( RS_SolidCullBack, rasterizerDesc );
			dxDbgSetName( RS_SolidCullBack, "RS_SolidCullBack" );
		}
		
// RS_SolidCullFront
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(169,16)
		{
			rasterizerDesc.FillMode				= D3D11_FILL_SOLID;
			rasterizerDesc.CullMode				= D3D11_CULL_FRONT;
			rasterizerDesc.FrontCounterClockwise	= FALSE;
			rasterizerDesc.DepthBias				= 0;
			rasterizerDesc.DepthBiasClamp		= 0.0f;
			rasterizerDesc.SlopeScaledDepthBias	= 0.0f;
			rasterizerDesc.DepthClipEnable		= TRUE;
			rasterizerDesc.ScissorEnable			= FALSE;
			rasterizerDesc.MultisampleEnable		= FALSE;
			rasterizerDesc.AntialiasedLineEnable	= FALSE;
			
			graphics.resources->Create_RasterizerState( RS_SolidCullFront, rasterizerDesc );
			dxDbgSetName( RS_SolidCullFront, "RS_SolidCullFront" );
		}
		
// RS_WireframeCullBack
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(176,16)
		{
			rasterizerDesc.FillMode				= D3D11_FILL_WIREFRAME;
			rasterizerDesc.CullMode				= D3D11_CULL_BACK;
			rasterizerDesc.FrontCounterClockwise	= FALSE;
			rasterizerDesc.DepthBias				= 0;
			rasterizerDesc.DepthBiasClamp		= 0.0f;
			rasterizerDesc.SlopeScaledDepthBias	= 0.0f;
			rasterizerDesc.DepthClipEnable		= TRUE;
			rasterizerDesc.ScissorEnable			= FALSE;
			rasterizerDesc.MultisampleEnable		= FALSE;
			rasterizerDesc.AntialiasedLineEnable	= FALSE;
			
			graphics.resources->Create_RasterizerState( RS_WireframeCullBack, rasterizerDesc );
			dxDbgSetName( RS_WireframeCullBack, "RS_WireframeCullBack" );
		}
		
// RS_SolidNoCullNoClip
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(184,16)
		{
			rasterizerDesc.FillMode				= D3D11_FILL_SOLID;
			rasterizerDesc.CullMode				= D3D11_CULL_NONE;
			rasterizerDesc.FrontCounterClockwise	= FALSE;
			rasterizerDesc.DepthBias				= 0;
			rasterizerDesc.DepthBiasClamp		= 0.0f;
			rasterizerDesc.SlopeScaledDepthBias	= 0.0f;
			rasterizerDesc.DepthClipEnable		= FALSE;
			rasterizerDesc.ScissorEnable			= FALSE;
			rasterizerDesc.MultisampleEnable		= FALSE;
			rasterizerDesc.AntialiasedLineEnable	= FALSE;
			
			graphics.resources->Create_RasterizerState( RS_SolidNoCullNoClip, rasterizerDesc );
			dxDbgSetName( RS_SolidNoCullNoClip, "RS_SolidNoCullNoClip" );
		}
		
// RS_WireframeNoCullNoClip
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(191,16)
		{
			rasterizerDesc.FillMode				= D3D11_FILL_WIREFRAME;
			rasterizerDesc.CullMode				= D3D11_CULL_NONE;
			rasterizerDesc.FrontCounterClockwise	= FALSE;
			rasterizerDesc.DepthBias				= 0;
			rasterizerDesc.DepthBiasClamp		= 0.0f;
			rasterizerDesc.SlopeScaledDepthBias	= 0.0f;
			rasterizerDesc.DepthClipEnable		= FALSE;
			rasterizerDesc.ScissorEnable			= FALSE;
			rasterizerDesc.MultisampleEnable		= FALSE;
			rasterizerDesc.AntialiasedLineEnable	= FALSE;
			
			graphics.resources->Create_RasterizerState( RS_WireframeNoCullNoClip, rasterizerDesc );
			dxDbgSetName( RS_WireframeNoCullNoClip, "RS_WireframeNoCullNoClip" );
		}
		
// RS_EyeOutsideLightVolume
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(373,16)
		{
			rasterizerDesc.FillMode				= D3D11_FILL_SOLID;
			rasterizerDesc.CullMode				= D3D11_CULL_BACK;
			rasterizerDesc.FrontCounterClockwise	= FALSE;
			rasterizerDesc.DepthBias				= 0;
			rasterizerDesc.DepthBiasClamp		= 0.0f;
			rasterizerDesc.SlopeScaledDepthBias	= 0.0f;
			rasterizerDesc.DepthClipEnable		= FALSE;
			rasterizerDesc.ScissorEnable			= FALSE;
			rasterizerDesc.MultisampleEnable		= FALSE;
			rasterizerDesc.AntialiasedLineEnable	= FALSE;
			
			graphics.resources->Create_RasterizerState( RS_EyeOutsideLightVolume, rasterizerDesc );
			dxDbgSetName( RS_EyeOutsideLightVolume, "RS_EyeOutsideLightVolume" );
		}
		
// RS_BuildShadowMap
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(397,16)
		{
			rasterizerDesc.FillMode				= D3D11_FILL_SOLID;
			rasterizerDesc.CullMode				= D3D11_CULL_BACK;
			rasterizerDesc.FrontCounterClockwise	= FALSE;
			rasterizerDesc.DepthBias				= 0;
			rasterizerDesc.DepthBiasClamp		= 0.0f;
			rasterizerDesc.SlopeScaledDepthBias	= 0.7F;
			rasterizerDesc.DepthClipEnable		= TRUE;
			rasterizerDesc.ScissorEnable			= FALSE;
			rasterizerDesc.MultisampleEnable		= FALSE;
			rasterizerDesc.AntialiasedLineEnable	= FALSE;
			
			graphics.resources->Create_RasterizerState( RS_BuildShadowMap, rasterizerDesc );
			dxDbgSetName( RS_BuildShadowMap, "RS_BuildShadowMap" );
		}
	}
	
	void EnumerateRasterizerStates( F_EnumerateRasterizerStates* callback, void* userData )
	{
		(*callback)( RS_SolidNoCull, userData );
		(*callback)( RS_SolidCullBack, userData );
		(*callback)( RS_SolidCullFront, userData );
		(*callback)( RS_WireframeCullBack, userData );
		(*callback)( RS_SolidNoCullNoClip, userData );
		(*callback)( RS_WireframeNoCullNoClip, userData );
		(*callback)( RS_EyeOutsideLightVolume, userData );
		(*callback)( RS_BuildShadowMap, userData );
	}
	
	//===========================================================================
	//	Blend states
	//===========================================================================
	
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(205,11)
	ID3D11BlendStatePtr BS_NoBlending;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(212,11)
	ID3D11BlendStatePtr BS_AdditiveBlending;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(223,11)
	ID3D11BlendStatePtr BS_AlphaBlending;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(235,11)
	ID3D11BlendStatePtr BS_NoBlendingNoColorWrites;
	
	static void SetupBlendStates()
	{
		D3D11_BLEND_DESC blendDesc;
		ZERO_OUT( blendDesc );
		
// BS_NoBlending
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(205,11)
		{
			blendDesc.AlphaToCoverageEnable	= FALSE;
			blendDesc.IndependentBlendEnable	= FALSE;
			blendDesc.RenderTarget[0].BlendEnable	= FALSE;
			blendDesc.RenderTarget[0].SrcBlend		= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].DestBlend		= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].BlendOp		= D3D11_BLEND_OP_ADD;
			blendDesc.RenderTarget[0].SrcBlendAlpha	= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].DestBlendAlpha	= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].BlendOpAlpha	= D3D11_BLEND_OP_ADD;
			blendDesc.RenderTarget[0].RenderTargetWriteMask	= 0x0F;
			
			graphics.resources->Create_BlendState( BS_NoBlending, blendDesc );
			dxDbgSetName( BS_NoBlending, "BS_NoBlending" );
		}
		
// BS_AdditiveBlending
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(212,11)
		{
			blendDesc.AlphaToCoverageEnable	= FALSE;
			blendDesc.IndependentBlendEnable	= FALSE;
			blendDesc.RenderTarget[0].BlendEnable	= TRUE;
			blendDesc.RenderTarget[0].SrcBlend		= D3D11_BLEND_ONE;
			blendDesc.RenderTarget[0].DestBlend		= D3D11_BLEND_ONE;
			blendDesc.RenderTarget[0].BlendOp		= D3D11_BLEND_OP_ADD;
			blendDesc.RenderTarget[0].SrcBlendAlpha	= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].DestBlendAlpha	= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].BlendOpAlpha	= D3D11_BLEND_OP_ADD;
			blendDesc.RenderTarget[0].RenderTargetWriteMask	= D3D11_COLOR_WRITE_ENABLE_ALL;
			
			graphics.resources->Create_BlendState( BS_AdditiveBlending, blendDesc );
			dxDbgSetName( BS_AdditiveBlending, "BS_AdditiveBlending" );
		}
		
// BS_AlphaBlending
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(223,11)
		{
			blendDesc.AlphaToCoverageEnable	= FALSE;
			blendDesc.IndependentBlendEnable	= FALSE;
			blendDesc.RenderTarget[0].BlendEnable	= TRUE;
			blendDesc.RenderTarget[0].SrcBlend		= D3D11_BLEND_SRC_ALPHA;
			blendDesc.RenderTarget[0].DestBlend		= D3D11_BLEND_INV_SRC_ALPHA;
			blendDesc.RenderTarget[0].BlendOp		= D3D11_BLEND_OP_ADD;
			blendDesc.RenderTarget[0].SrcBlendAlpha	= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].DestBlendAlpha	= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].BlendOpAlpha	= D3D11_BLEND_OP_ADD;
			blendDesc.RenderTarget[0].RenderTargetWriteMask	= D3D11_COLOR_WRITE_ENABLE_ALL;
			
			graphics.resources->Create_BlendState( BS_AlphaBlending, blendDesc );
			dxDbgSetName( BS_AlphaBlending, "BS_AlphaBlending" );
		}
		
// BS_NoBlendingNoColorWrites
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(235,11)
		{
			blendDesc.AlphaToCoverageEnable	= FALSE;
			blendDesc.IndependentBlendEnable	= FALSE;
			blendDesc.RenderTarget[0].BlendEnable	= FALSE;
			blendDesc.RenderTarget[0].SrcBlend		= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].DestBlend		= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].BlendOp		= D3D11_BLEND_OP_ADD;
			blendDesc.RenderTarget[0].SrcBlendAlpha	= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].DestBlendAlpha	= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].BlendOpAlpha	= D3D11_BLEND_OP_ADD;
			blendDesc.RenderTarget[0].RenderTargetWriteMask	= 0;
			
			graphics.resources->Create_BlendState( BS_NoBlendingNoColorWrites, blendDesc );
			dxDbgSetName( BS_NoBlendingNoColorWrites, "BS_NoBlendingNoColorWrites" );
		}
	}
	
	void EnumerateBlendStates( F_EnumerateBlendStates* callback, void* userData )
	{
		(*callback)( BS_NoBlending, userData );
		(*callback)( BS_AdditiveBlending, userData );
		(*callback)( BS_AlphaBlending, userData );
		(*callback)( BS_NoBlendingNoColorWrites, userData );
	}
	
	//===========================================================================
	//	State blocks
	//===========================================================================
	
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(248,11)
	StateBlock Default;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(264,11)
	StateBlock DebugPrimitives;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(276,11)
	StateBlock HitProxy_ZTestLessEqualCullBack;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(298,11)
	StateBlock SolidNoCullNoZTestNoClipNoBlend;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(323,11)
	StateBlock TranslucentCullBack;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(337,11)
	StateBlock SkyLast;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(355,11)
	StateBlock Deferred_Light_FullScreen_Additive;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(381,11)
	StateBlock Deferred_Light_ConvexMesh_Additive;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(406,11)
	StateBlock Build_Shadow_Map;
	
	static void SetupStateBlocks()
	{
		
// Default
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(248,11)
		{
			Default.rasterizer   = RS_SolidCullBack;
			
			Default.depthStencil = DS_NormalZTestWriteNoStencil;
			Default.stencilRef   = 0;
			
			Default.blend           = BS_NoBlending;
			Default.blendFactorRGBA[0] = 0.000000;
			Default.blendFactorRGBA[1] = 0.000000;
			Default.blendFactorRGBA[2] = 0.000000;
			Default.blendFactorRGBA[3] = 1.000000;
			Default.sampleMask      = 0xFFFFFFFF;
		}
		
// DebugPrimitives
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(264,11)
		{
			DebugPrimitives.rasterizer   = RS_SolidNoCullNoClip;
			
			DebugPrimitives.depthStencil = DS_ZTestLessEqualNoZWriteNoStencil;
			DebugPrimitives.stencilRef   = 0;
			
			DebugPrimitives.blend           = BS_NoBlending;
			DebugPrimitives.blendFactorRGBA[0] = 0.000000;
			DebugPrimitives.blendFactorRGBA[1] = 0.000000;
			DebugPrimitives.blendFactorRGBA[2] = 0.000000;
			DebugPrimitives.blendFactorRGBA[3] = 1.000000;
			DebugPrimitives.sampleMask      = 0xFFFFFFFF;
		}
		
// HitProxy_ZTestLessEqualCullBack
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(276,11)
		{
			HitProxy_ZTestLessEqualCullBack.rasterizer   = RS_SolidCullBack;
			
			HitProxy_ZTestLessEqualCullBack.depthStencil = DS_ZTestLessEqualNoZWriteNoStencil;
			HitProxy_ZTestLessEqualCullBack.stencilRef   = 0;
			
			HitProxy_ZTestLessEqualCullBack.blend           = BS_NoBlending;
			HitProxy_ZTestLessEqualCullBack.blendFactorRGBA[0] = 0.000000;
			HitProxy_ZTestLessEqualCullBack.blendFactorRGBA[1] = 0.000000;
			HitProxy_ZTestLessEqualCullBack.blendFactorRGBA[2] = 0.000000;
			HitProxy_ZTestLessEqualCullBack.blendFactorRGBA[3] = 1.000000;
			HitProxy_ZTestLessEqualCullBack.sampleMask      = 0xFFFFFFFF;
		}
		
// SolidNoCullNoZTestNoClipNoBlend
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(298,11)
		{
			SolidNoCullNoZTestNoClipNoBlend.rasterizer   = RS_SolidNoCullNoClip;
			
			SolidNoCullNoZTestNoClipNoBlend.depthStencil = DS_NoZTestWriteNoStencil;
			SolidNoCullNoZTestNoClipNoBlend.stencilRef   = 0;
			
			SolidNoCullNoZTestNoClipNoBlend.blend           = BS_NoBlending;
			SolidNoCullNoZTestNoClipNoBlend.blendFactorRGBA[0] = 0.000000;
			SolidNoCullNoZTestNoClipNoBlend.blendFactorRGBA[1] = 0.000000;
			SolidNoCullNoZTestNoClipNoBlend.blendFactorRGBA[2] = 0.000000;
			SolidNoCullNoZTestNoClipNoBlend.blendFactorRGBA[3] = 1.000000;
			SolidNoCullNoZTestNoClipNoBlend.sampleMask      = 0xFFFFFFFF;
		}
		
// TranslucentCullBack
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(323,11)
		{
			TranslucentCullBack.rasterizer   = RS_SolidCullBack;
			
			TranslucentCullBack.depthStencil = DS_NormalZTestNoWriteNoStencil;
			TranslucentCullBack.stencilRef   = 0;
			
			TranslucentCullBack.blend           = BS_AlphaBlending;
			TranslucentCullBack.blendFactorRGBA[0] = 0.000000;
			TranslucentCullBack.blendFactorRGBA[1] = 0.000000;
			TranslucentCullBack.blendFactorRGBA[2] = 0.000000;
			TranslucentCullBack.blendFactorRGBA[3] = 1.000000;
			TranslucentCullBack.sampleMask      = 0xFFFFFFFF;
		}
		
// SkyLast
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(337,11)
		{
			SkyLast.rasterizer   = RS_SolidCullBack;
			
			SkyLast.depthStencil = DS_ZTestLessEqualNoZWriteNoStencil;
			SkyLast.stencilRef   = 0;
			
			SkyLast.blend           = BS_NoBlending;
			SkyLast.blendFactorRGBA[0] = 0.000000;
			SkyLast.blendFactorRGBA[1] = 0.000000;
			SkyLast.blendFactorRGBA[2] = 0.000000;
			SkyLast.blendFactorRGBA[3] = 1.000000;
			SkyLast.sampleMask      = 0xFFFFFFFF;
		}
		
// Deferred_Light_FullScreen_Additive
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(355,11)
		{
			Deferred_Light_FullScreen_Additive.rasterizer   = RS_SolidNoCull;
			
			Deferred_Light_FullScreen_Additive.depthStencil = DS_ZTestGreaterNoZWriteNoStencil;
			Deferred_Light_FullScreen_Additive.stencilRef   = 0;
			
			Deferred_Light_FullScreen_Additive.blend           = BS_AdditiveBlending;
			Deferred_Light_FullScreen_Additive.blendFactorRGBA[0] = 0.000000;
			Deferred_Light_FullScreen_Additive.blendFactorRGBA[1] = 0.000000;
			Deferred_Light_FullScreen_Additive.blendFactorRGBA[2] = 0.000000;
			Deferred_Light_FullScreen_Additive.blendFactorRGBA[3] = 1.000000;
			Deferred_Light_FullScreen_Additive.sampleMask      = 0xFFFFFFFF;
		}
		
// Deferred_Light_ConvexMesh_Additive
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(381,11)
		{
			Deferred_Light_ConvexMesh_Additive.rasterizer   = RS_EyeOutsideLightVolume;
			
			Deferred_Light_ConvexMesh_Additive.depthStencil = DS_NormalZTestNoWriteNoStencil;
			Deferred_Light_ConvexMesh_Additive.stencilRef   = 0;
			
			Deferred_Light_ConvexMesh_Additive.blend           = BS_AdditiveBlending;
			Deferred_Light_ConvexMesh_Additive.blendFactorRGBA[0] = 0.000000;
			Deferred_Light_ConvexMesh_Additive.blendFactorRGBA[1] = 0.000000;
			Deferred_Light_ConvexMesh_Additive.blendFactorRGBA[2] = 0.000000;
			Deferred_Light_ConvexMesh_Additive.blendFactorRGBA[3] = 1.000000;
			Deferred_Light_ConvexMesh_Additive.sampleMask      = 0xFFFFFFFF;
		}
		
// Build_Shadow_Map
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(406,11)
		{
			Build_Shadow_Map.rasterizer   = RS_BuildShadowMap;
			
			Build_Shadow_Map.depthStencil = DS_NormalZTestWriteNoStencil;
			Build_Shadow_Map.stencilRef   = 0;
			
			Build_Shadow_Map.blend           = BS_NoBlending;
			Build_Shadow_Map.blendFactorRGBA[0] = 0.000000;
			Build_Shadow_Map.blendFactorRGBA[1] = 0.000000;
			Build_Shadow_Map.blendFactorRGBA[2] = 0.000000;
			Build_Shadow_Map.blendFactorRGBA[3] = 1.000000;
			Build_Shadow_Map.sampleMask      = 0xFFFFFFFF;
		}
	}
	
	
	TConstantBuffer< Shared_Globals::PerFrame >	Shared_Globals::cb_PerFrame;
	ID3D11SamplerState* Shared_Globals::pointSampler = nil;
	ID3D11SamplerState* Shared_Globals::linearSampler = nil;
	ID3D11SamplerState* Shared_Globals::anisotropicSampler = nil;
	ID3D11SamplerState* Shared_Globals::pointClampSampler = nil;
	ID3D11SamplerState* Shared_Globals::linearClampSampler = nil;
	ID3D11SamplerState* Shared_Globals::colorMapSampler = nil;
	ID3D11SamplerState* Shared_Globals::detailMapSampler = nil;
	ID3D11SamplerState* Shared_Globals::normalMapSampler = nil;
	ID3D11SamplerState* Shared_Globals::specularMapSampler = nil;
	ID3D11SamplerState* Shared_Globals::attenuationSampler = nil;
	ID3D11SamplerState* Shared_Globals::cubeMapSampler = nil;
	ID3D11SamplerState* Shared_Globals::shadowMapSampler = nil;
	ID3D11SamplerState* Shared_Globals::shadowMapPCFSampler = nil;
	ID3D11SamplerState* Shared_Globals::shadowMapPCFBilinearSampler = nil;
	
	
	TConstantBuffer< Shared_View::PerView >	Shared_View::cb_PerView;
	
	
	TConstantBuffer< Shared_Object::PerObject >	Shared_Object::cb_PerObject;
	
	
	ID3D11ShaderResourceView* Shared_GBuffer::RT_normal_specMul = nil;
	ID3D11ShaderResourceView* Shared_GBuffer::RT_diffuse_specExp = nil;
	ID3D11ShaderResourceView* Shared_GBuffer::RT_linearDepth = nil;
	
	
	TConstantBuffer< Shared_LocalLightData::PerLocalLight >	Shared_LocalLightData::cb_PerLocalLight;
	
	static void SetupSharedSections()
	{
		
		// Make sure that sampler states are laid out contiguously in memory (so we can Set() them in one call)
		{
			ID3D11SamplerState** samplerStatesArray = c_cast(ID3D11SamplerState**) &Shared_Globals::pointSampler;
			ensure( samplerStatesArray + 0 == &Shared_Globals::pointSampler );
			ensure( samplerStatesArray + 1 == &Shared_Globals::linearSampler );
			ensure( samplerStatesArray + 2 == &Shared_Globals::anisotropicSampler );
			ensure( samplerStatesArray + 3 == &Shared_Globals::pointClampSampler );
			ensure( samplerStatesArray + 4 == &Shared_Globals::linearClampSampler );
			ensure( samplerStatesArray + 5 == &Shared_Globals::colorMapSampler );
			ensure( samplerStatesArray + 6 == &Shared_Globals::detailMapSampler );
			ensure( samplerStatesArray + 7 == &Shared_Globals::normalMapSampler );
			ensure( samplerStatesArray + 8 == &Shared_Globals::specularMapSampler );
			ensure( samplerStatesArray + 9 == &Shared_Globals::attenuationSampler );
			ensure( samplerStatesArray + 10 == &Shared_Globals::cubeMapSampler );
			ensure( samplerStatesArray + 11 == &Shared_Globals::shadowMapSampler );
			ensure( samplerStatesArray + 12 == &Shared_Globals::shadowMapPCFSampler );
			ensure( samplerStatesArray + 13 == &Shared_Globals::shadowMapPCFBilinearSampler );
		}
		
		Shared_Globals::cb_PerFrame.Create( graphics.shaders );
		Shared_Globals::pointSampler = SS_Bilinear;
		Shared_Globals::linearSampler = SS_Bilinear;
		Shared_Globals::anisotropicSampler = SS_Aniso;
		Shared_Globals::pointClampSampler = SS_PointClamp;
		Shared_Globals::linearClampSampler = SS_LinearClamp;
		Shared_Globals::colorMapSampler = SS_Bilinear;
		Shared_Globals::detailMapSampler = SS_Bilinear;
		Shared_Globals::normalMapSampler = SS_Bilinear;
		Shared_Globals::specularMapSampler = SS_Bilinear;
		Shared_Globals::attenuationSampler = SS_Bilinear;
		Shared_Globals::cubeMapSampler = SS_Bilinear;
		Shared_Globals::shadowMapSampler = SS_ShadowMap;
		Shared_Globals::shadowMapPCFSampler = SS_ShadowMapPCF;
		Shared_Globals::shadowMapPCFBilinearSampler = SS_ShadowMapPCF_Bilinear;
		Shared_View::cb_PerView.Create( graphics.shaders );
		Shared_Object::cb_PerObject.Create( graphics.shaders );
		
		// Make sure that shader resources are laid out contiguously in memory (so we can Set() them in one call)
		{
			ID3D11ShaderResourceView** shaderResourcesArray = c_cast(ID3D11ShaderResourceView**) &Shared_GBuffer::RT_normal_specMul;
			ensure( shaderResourcesArray + 0 == &Shared_GBuffer::RT_normal_specMul );
			ensure( shaderResourcesArray + 1 == &Shared_GBuffer::RT_diffuse_specExp );
			ensure( shaderResourcesArray + 2 == &Shared_GBuffer::RT_linearDepth );
		}
		
		Shared_GBuffer::RT_normal_specMul = RT_Normal_SpecIntensity.pSRV;
		Shared_GBuffer::RT_diffuse_specExp = RT_Diffuse_SpecPower.pSRV;
		Shared_GBuffer::RT_linearDepth = RT_LinearDepth.pSRV;
		Shared_LocalLightData::cb_PerLocalLight.Create( graphics.shaders );
	}
	
	//===========================================================================
	//	Shaders
	//===========================================================================
	
	
	
	TConstantBuffer< p_batched_lines::Data >	p_batched_lines::cb_Data;
	ID3D11SamplerState* p_batched_lines::linearSampler = nil;
	ID3D11ShaderResourceView* p_batched_lines::textureMap = nil;
	ShaderInstance p_batched_lines::shaderInstances[2];
	
	extern ID3D11SamplerStatePtr SS_Bilinear;
	
	void p_batched_lines::Initialize()
	{
		p_batched_lines::cb_Data.Create( graphics.shaders );
		
		p_batched_lines::linearSampler = SS_Bilinear;
		
		static GrShaderData d;
		d.uniqueId = p_batched_lines::UID;
		d.name = GR_TEXT("p_batched_lines");
		d.file = GR_TEXT("p_batched_lines_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VSMain");
		d.PS_EntryPoint = GR_TEXT("PSMain");
		d.numInstances = p_batched_lines::NumInstances;
		d.instances = p_batched_lines::shaderInstances;
		d.getDefines = p_batched_lines::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_batched_lines::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_batched_lines::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( "bTextureMap", (instanceId & bTextureMap) ? "1" : "0" );
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_batched_lines::Shutdown()
	{
		p_batched_lines::cb_Data.Destroy( graphics.shaders );
	}
	
	
	TConstantBuffer< p_build_hw_shadow_map::Data >	p_build_hw_shadow_map::cb_Data;
	ShaderInstance p_build_hw_shadow_map::shaderInstances[1];
	
	
	void p_build_hw_shadow_map::Initialize()
	{
		p_build_hw_shadow_map::cb_Data.Create( graphics.shaders );
		
		static GrShaderData d;
		d.uniqueId = p_build_hw_shadow_map::UID;
		d.name = GR_TEXT("p_build_hw_shadow_map");
		d.file = GR_TEXT("p_build_hw_shadow_map_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VS_Main");
		d.PS_EntryPoint = nil;	// null pixel shader
		d.numInstances = p_build_hw_shadow_map::NumInstances;
		d.instances = p_build_hw_shadow_map::shaderInstances;
		d.getDefines = p_build_hw_shadow_map::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_build_hw_shadow_map::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_build_hw_shadow_map::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_build_hw_shadow_map::Shutdown()
	{
		p_build_hw_shadow_map::cb_Data.Destroy( graphics.shaders );
	}
	
	
	ShaderInstance p_debug_gbuffer_show_diffuse::shaderInstances[1];
	
	
	void p_debug_gbuffer_show_diffuse::Initialize()
	{
		static GrShaderData d;
		d.uniqueId = p_debug_gbuffer_show_diffuse::UID;
		d.name = GR_TEXT("p_debug_gbuffer_show_diffuse");
		d.file = GR_TEXT("p_debug_gbuffer_show_diffuse_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("FullScreenTriangle_VS");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_debug_gbuffer_show_diffuse::NumInstances;
		d.instances = p_debug_gbuffer_show_diffuse::shaderInstances;
		d.getDefines = p_debug_gbuffer_show_diffuse::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_debug_gbuffer_show_diffuse::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_debug_gbuffer_show_diffuse::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_debug_gbuffer_show_diffuse::Shutdown()
	{
	}
	
	
	TConstantBuffer< p_deferred_directional_light::Data >	p_deferred_directional_light::cb_Data;
	ID3D11ShaderResourceView* p_deferred_directional_light::shadowDepthMap = nil;
	ShaderInstance p_deferred_directional_light::shaderInstances[8];
	
	
	void p_deferred_directional_light::Initialize()
	{
		p_deferred_directional_light::cb_Data.Create( graphics.shaders );
		
		static GrShaderData d;
		d.uniqueId = p_deferred_directional_light::UID;
		d.name = GR_TEXT("p_deferred_directional_light");
		d.file = GR_TEXT("p_deferred_directional_light_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("FullScreenQuad_VS");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_deferred_directional_light::NumInstances;
		d.instances = p_deferred_directional_light::shaderInstances;
		d.getDefines = p_deferred_directional_light::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_deferred_directional_light::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_deferred_directional_light::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( "bLight_CastShadows", (instanceId & bLight_CastShadows) ? "1" : "0" );
		OutDefines.Add().Set( "bEnableSoftShadows", (instanceId & bEnableSoftShadows) ? "1" : "0" );
		OutDefines.Add().Set( "bVisualizeCascades", (instanceId & bVisualizeCascades) ? "1" : "0" );
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_deferred_directional_light::Shutdown()
	{
		p_deferred_directional_light::cb_Data.Destroy( graphics.shaders );
	}
	
	
	ShaderInstance p_deferred_fullscreen_point_light::shaderInstances[2];
	
	
	void p_deferred_fullscreen_point_light::Initialize()
	{
		static GrShaderData d;
		d.uniqueId = p_deferred_fullscreen_point_light::UID;
		d.name = GR_TEXT("p_deferred_fullscreen_point_light");
		d.file = GR_TEXT("p_deferred_fullscreen_point_light_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("FullScreenQuad_VS");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_deferred_fullscreen_point_light::NumInstances;
		d.instances = p_deferred_fullscreen_point_light::shaderInstances;
		d.getDefines = p_deferred_fullscreen_point_light::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_deferred_fullscreen_point_light::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_deferred_fullscreen_point_light::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( "bLight_EnableSpecular", (instanceId & bLight_EnableSpecular) ? "1" : "0" );
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_deferred_fullscreen_point_light::Shutdown()
	{
	}
	
	
	ID3D11ShaderResourceView* p_deferred_fullscreen_spot_light::projector = nil;
	ID3D11ShaderResourceView* p_deferred_fullscreen_spot_light::shadowDepthMap = nil;
	ShaderInstance p_deferred_fullscreen_spot_light::shaderInstances[8];
	
	
	void p_deferred_fullscreen_spot_light::Initialize()
	{
		
		// Make sure that shader resources are laid out contiguously in memory (so we can Set() them in one call)
		{
			ID3D11ShaderResourceView** shaderResourcesArray = c_cast(ID3D11ShaderResourceView**) &p_deferred_fullscreen_spot_light::projector;
			ensure( shaderResourcesArray + 0 == &p_deferred_fullscreen_spot_light::projector );
			ensure( shaderResourcesArray + 1 == &p_deferred_fullscreen_spot_light::shadowDepthMap );
		}
		
		static GrShaderData d;
		d.uniqueId = p_deferred_fullscreen_spot_light::UID;
		d.name = GR_TEXT("p_deferred_fullscreen_spot_light");
		d.file = GR_TEXT("p_deferred_fullscreen_spot_light_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("FullScreenQuad_VS");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_deferred_fullscreen_spot_light::NumInstances;
		d.instances = p_deferred_fullscreen_spot_light::shaderInstances;
		d.getDefines = p_deferred_fullscreen_spot_light::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_deferred_fullscreen_spot_light::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_deferred_fullscreen_spot_light::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( "bLight_EnableSpecular", (instanceId & bLight_EnableSpecular) ? "1" : "0" );
		OutDefines.Add().Set( "bSpotLight_ProjectsTexture", (instanceId & bSpotLight_ProjectsTexture) ? "1" : "0" );
		OutDefines.Add().Set( "bSpotLight_CastShadows", (instanceId & bSpotLight_CastShadows) ? "1" : "0" );
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_deferred_fullscreen_spot_light::Shutdown()
	{
	}
	
	
	ShaderInstance p_deferred_local_point_light::shaderInstances[2];
	
	
	void p_deferred_local_point_light::Initialize()
	{
		static GrShaderData d;
		d.uniqueId = p_deferred_local_point_light::UID;
		d.name = GR_TEXT("p_deferred_local_point_light");
		d.file = GR_TEXT("p_deferred_local_point_light_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VS_LightVolume_Main");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_deferred_local_point_light::NumInstances;
		d.instances = p_deferred_local_point_light::shaderInstances;
		d.getDefines = p_deferred_local_point_light::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_deferred_local_point_light::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_deferred_local_point_light::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( "bLight_EnableSpecular", (instanceId & bLight_EnableSpecular) ? "1" : "0" );
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_deferred_local_point_light::Shutdown()
	{
	}
	
	
	ID3D11ShaderResourceView* p_deferred_local_spot_light::projector = nil;
	ID3D11ShaderResourceView* p_deferred_local_spot_light::shadowDepthMap = nil;
	ShaderInstance p_deferred_local_spot_light::shaderInstances[8];
	
	
	void p_deferred_local_spot_light::Initialize()
	{
		
		// Make sure that shader resources are laid out contiguously in memory (so we can Set() them in one call)
		{
			ID3D11ShaderResourceView** shaderResourcesArray = c_cast(ID3D11ShaderResourceView**) &p_deferred_local_spot_light::projector;
			ensure( shaderResourcesArray + 0 == &p_deferred_local_spot_light::projector );
			ensure( shaderResourcesArray + 1 == &p_deferred_local_spot_light::shadowDepthMap );
		}
		
		static GrShaderData d;
		d.uniqueId = p_deferred_local_spot_light::UID;
		d.name = GR_TEXT("p_deferred_local_spot_light");
		d.file = GR_TEXT("p_deferred_local_spot_light_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VS_LightVolume_Main");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_deferred_local_spot_light::NumInstances;
		d.instances = p_deferred_local_spot_light::shaderInstances;
		d.getDefines = p_deferred_local_spot_light::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_deferred_local_spot_light::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_deferred_local_spot_light::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( "bLight_EnableSpecular", (instanceId & bLight_EnableSpecular) ? "1" : "0" );
		OutDefines.Add().Set( "bSpotLight_ProjectsTexture", (instanceId & bSpotLight_ProjectsTexture) ? "1" : "0" );
		OutDefines.Add().Set( "bSpotLight_CastShadows", (instanceId & bSpotLight_CastShadows) ? "1" : "0" );
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_deferred_local_spot_light::Shutdown()
	{
	}
	
	
	ID3D11ShaderResourceView* p_depth_of_field::sceneColorTexture = nil;
	ID3D11ShaderResourceView* p_depth_of_field::sceneDepthTexture = nil;
	ID3D11ShaderResourceView* p_depth_of_field::blurredSceneTexture = nil;
	ShaderInstance p_depth_of_field::shaderInstances[1];
	
	
	void p_depth_of_field::Initialize()
	{
		
		// Make sure that shader resources are laid out contiguously in memory (so we can Set() them in one call)
		{
			ID3D11ShaderResourceView** shaderResourcesArray = c_cast(ID3D11ShaderResourceView**) &p_depth_of_field::sceneColorTexture;
			ensure( shaderResourcesArray + 0 == &p_depth_of_field::sceneColorTexture );
			ensure( shaderResourcesArray + 1 == &p_depth_of_field::sceneDepthTexture );
			ensure( shaderResourcesArray + 2 == &p_depth_of_field::blurredSceneTexture );
		}
		
		static GrShaderData d;
		d.uniqueId = p_depth_of_field::UID;
		d.name = GR_TEXT("p_depth_of_field");
		d.file = GR_TEXT("p_depth_of_field_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VS_Main");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_depth_of_field::NumInstances;
		d.instances = p_depth_of_field::shaderInstances;
		d.getDefines = p_depth_of_field::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_depth_of_field::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_depth_of_field::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_depth_of_field::Shutdown()
	{
	}
	
	
	TConstantBuffer< p_fullscreen_colored_triangle_shader::Data >	p_fullscreen_colored_triangle_shader::cb_Data;
	ShaderInstance p_fullscreen_colored_triangle_shader::shaderInstances[1];
	
	
	void p_fullscreen_colored_triangle_shader::Initialize()
	{
		p_fullscreen_colored_triangle_shader::cb_Data.Create( graphics.shaders );
		
		static GrShaderData d;
		d.uniqueId = p_fullscreen_colored_triangle_shader::UID;
		d.name = GR_TEXT("p_fullscreen_colored_triangle_shader");
		d.file = GR_TEXT("p_fullscreen_colored_triangle_shader_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("FullScreenTriangle_VS");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_fullscreen_colored_triangle_shader::NumInstances;
		d.instances = p_fullscreen_colored_triangle_shader::shaderInstances;
		d.getDefines = p_fullscreen_colored_triangle_shader::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_fullscreen_colored_triangle_shader::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_fullscreen_colored_triangle_shader::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_fullscreen_colored_triangle_shader::Shutdown()
	{
		p_fullscreen_colored_triangle_shader::cb_Data.Destroy( graphics.shaders );
	}
	
	
	ID3D11SamplerState* p_fullscreen_textured_triangle_shader::linearSampler = nil;
	ID3D11ShaderResourceView* p_fullscreen_textured_triangle_shader::sourceTexture = nil;
	ShaderInstance p_fullscreen_textured_triangle_shader::shaderInstances[1];
	
	extern ID3D11SamplerStatePtr SS_Bilinear;
	
	void p_fullscreen_textured_triangle_shader::Initialize()
	{
		p_fullscreen_textured_triangle_shader::linearSampler = SS_Bilinear;
		
		static GrShaderData d;
		d.uniqueId = p_fullscreen_textured_triangle_shader::UID;
		d.name = GR_TEXT("p_fullscreen_textured_triangle_shader");
		d.file = GR_TEXT("p_fullscreen_textured_triangle_shader_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("FullScreenTriangle_VS");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_fullscreen_textured_triangle_shader::NumInstances;
		d.instances = p_fullscreen_textured_triangle_shader::shaderInstances;
		d.getDefines = p_fullscreen_textured_triangle_shader::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_fullscreen_textured_triangle_shader::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_fullscreen_textured_triangle_shader::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_fullscreen_textured_triangle_shader::Shutdown()
	{
	}
	
	
	TConstantBuffer< p_hit_proxy::Data >	p_hit_proxy::cb_Data;
	ShaderInstance p_hit_proxy::shaderInstances[2];
	
	
	void p_hit_proxy::Initialize()
	{
		p_hit_proxy::cb_Data.Create( graphics.shaders );
		
		static GrShaderData d;
		d.uniqueId = p_hit_proxy::UID;
		d.name = GR_TEXT("p_hit_proxy");
		d.file = GR_TEXT("p_hit_proxy_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VSMain");
		d.PS_EntryPoint = GR_TEXT("PSMain");
		d.numInstances = p_hit_proxy::NumInstances;
		d.instances = p_hit_proxy::shaderInstances;
		d.getDefines = p_hit_proxy::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_hit_proxy::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_hit_proxy::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( "bEnableColorWrites", (instanceId & bEnableColorWrites) ? "1" : "0" );
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_hit_proxy::Shutdown()
	{
		p_hit_proxy::cb_Data.Destroy( graphics.shaders );
	}
	
	
	ID3D11ShaderResourceView* p_horizontal_blur::sourceTexture = nil;
	ShaderInstance p_horizontal_blur::shaderInstances[1];
	
	
	void p_horizontal_blur::Initialize()
	{
		static GrShaderData d;
		d.uniqueId = p_horizontal_blur::UID;
		d.name = GR_TEXT("p_horizontal_blur");
		d.file = GR_TEXT("p_horizontal_blur_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VS_Main");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_horizontal_blur::NumInstances;
		d.instances = p_horizontal_blur::shaderInstances;
		d.getDefines = p_horizontal_blur::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_horizontal_blur::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_horizontal_blur::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_horizontal_blur::Shutdown()
	{
	}
	
	
	ID3D11ShaderResourceView* p_horizontal_gaussian_blur::sourceTexture = nil;
	ShaderInstance p_horizontal_gaussian_blur::shaderInstances[1];
	
	
	void p_horizontal_gaussian_blur::Initialize()
	{
		static GrShaderData d;
		d.uniqueId = p_horizontal_gaussian_blur::UID;
		d.name = GR_TEXT("p_horizontal_gaussian_blur");
		d.file = GR_TEXT("p_horizontal_gaussian_blur_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VS_Main");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_horizontal_gaussian_blur::NumInstances;
		d.instances = p_horizontal_gaussian_blur::shaderInstances;
		d.getDefines = p_horizontal_gaussian_blur::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_horizontal_gaussian_blur::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_horizontal_gaussian_blur::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_horizontal_gaussian_blur::Shutdown()
	{
	}
	
	
	TConstantBuffer< p_material_phong::Data >	p_material_phong::cb_Data;
	ID3D11ShaderResourceView* p_material_phong::baseMap = nil;
	ID3D11ShaderResourceView* p_material_phong::normalMap = nil;
	ID3D11ShaderResourceView* p_material_phong::specularMap = nil;
	ShaderInstance p_material_phong::shaderInstances[8];
	
	
	void p_material_phong::Initialize()
	{
		
		// Make sure that shader resources are laid out contiguously in memory (so we can Set() them in one call)
		{
			ID3D11ShaderResourceView** shaderResourcesArray = c_cast(ID3D11ShaderResourceView**) &p_material_phong::baseMap;
			ensure( shaderResourcesArray + 0 == &p_material_phong::baseMap );
			ensure( shaderResourcesArray + 1 == &p_material_phong::normalMap );
			ensure( shaderResourcesArray + 2 == &p_material_phong::specularMap );
		}
		
		p_material_phong::cb_Data.Create( graphics.shaders );
		
		static GrShaderData d;
		d.uniqueId = p_material_phong::UID;
		d.name = GR_TEXT("p_material_phong");
		d.file = GR_TEXT("p_material_phong_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VS_Main");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_material_phong::NumInstances;
		d.instances = p_material_phong::shaderInstances;
		d.getDefines = p_material_phong::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_material_phong::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_material_phong::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( "bHasBaseMap", (instanceId & bHasBaseMap) ? "1" : "0" );
		OutDefines.Add().Set( "bHasNormalMap", (instanceId & bHasNormalMap) ? "1" : "0" );
		OutDefines.Add().Set( "bHasSpecularMap", (instanceId & bHasSpecularMap) ? "1" : "0" );
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_material_phong::Shutdown()
	{
		p_material_phong::cb_Data.Destroy( graphics.shaders );
	}
	
	
	TConstantBuffer< p_material_plain_color::Data >	p_material_plain_color::cb_Data;
	ShaderInstance p_material_plain_color::shaderInstances[1];
	
	
	void p_material_plain_color::Initialize()
	{
		p_material_plain_color::cb_Data.Create( graphics.shaders );
		
		static GrShaderData d;
		d.uniqueId = p_material_plain_color::UID;
		d.name = GR_TEXT("p_material_plain_color");
		d.file = GR_TEXT("p_material_plain_color_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VS_Main");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_material_plain_color::NumInstances;
		d.instances = p_material_plain_color::shaderInstances;
		d.getDefines = p_material_plain_color::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_material_plain_color::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_material_plain_color::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_material_plain_color::Shutdown()
	{
		p_material_plain_color::cb_Data.Destroy( graphics.shaders );
	}
	
	
	TConstantBuffer< p_sky_dome::Data >	p_sky_dome::cb_Data;
	ID3D11SamplerState* p_sky_dome::skyTextureSampler = nil;
	ID3D11ShaderResourceView* p_sky_dome::skyTexture = nil;
	ShaderInstance p_sky_dome::shaderInstances[1];
	
	extern ID3D11SamplerStatePtr SS_Bilinear;
	
	void p_sky_dome::Initialize()
	{
		p_sky_dome::cb_Data.Create( graphics.shaders );
		
		p_sky_dome::skyTextureSampler = SS_Bilinear;
		
		static GrShaderData d;
		d.uniqueId = p_sky_dome::UID;
		d.name = GR_TEXT("p_sky_dome");
		d.file = GR_TEXT("p_sky_dome_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VS_Main");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_sky_dome::NumInstances;
		d.instances = p_sky_dome::shaderInstances;
		d.getDefines = p_sky_dome::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_sky_dome::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_sky_dome::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_sky_dome::Shutdown()
	{
		p_sky_dome::cb_Data.Destroy( graphics.shaders );
	}
	
	
	ID3D11ShaderResourceView* p_uber_post_processing_shader::sceneColorTexture = nil;
	ID3D11ShaderResourceView* p_uber_post_processing_shader::sceneDepthTexture = nil;
	ID3D11ShaderResourceView* p_uber_post_processing_shader::blurredSceneTexture = nil;
	ID3D11ShaderResourceView* p_uber_post_processing_shader::randomNormalsTexture = nil;
	ShaderInstance p_uber_post_processing_shader::shaderInstances[16];
	
	
	void p_uber_post_processing_shader::Initialize()
	{
		
		// Make sure that shader resources are laid out contiguously in memory (so we can Set() them in one call)
		{
			ID3D11ShaderResourceView** shaderResourcesArray = c_cast(ID3D11ShaderResourceView**) &p_uber_post_processing_shader::sceneColorTexture;
			ensure( shaderResourcesArray + 0 == &p_uber_post_processing_shader::sceneColorTexture );
			ensure( shaderResourcesArray + 1 == &p_uber_post_processing_shader::sceneDepthTexture );
			ensure( shaderResourcesArray + 2 == &p_uber_post_processing_shader::blurredSceneTexture );
			ensure( shaderResourcesArray + 3 == &p_uber_post_processing_shader::randomNormalsTexture );
		}
		
		static GrShaderData d;
		d.uniqueId = p_uber_post_processing_shader::UID;
		d.name = GR_TEXT("p_uber_post_processing_shader");
		d.file = GR_TEXT("p_uber_post_processing_shader_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("FullScreenQuad_VS");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_uber_post_processing_shader::NumInstances;
		d.instances = p_uber_post_processing_shader::shaderInstances;
		d.getDefines = p_uber_post_processing_shader::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_uber_post_processing_shader::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_uber_post_processing_shader::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( "bEnable_Bloom", (instanceId & bEnable_Bloom) ? "1" : "0" );
		OutDefines.Add().Set( "bEnable_HDR", (instanceId & bEnable_HDR) ? "1" : "0" );
		OutDefines.Add().Set( "bEnable_DOF", (instanceId & bEnable_DOF) ? "1" : "0" );
		OutDefines.Add().Set( "bEnable_SSAO", (instanceId & bEnable_SSAO) ? "1" : "0" );
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_uber_post_processing_shader::Shutdown()
	{
	}
	
	
	ID3D11ShaderResourceView* p_vertical_blur::sourceTexture = nil;
	ShaderInstance p_vertical_blur::shaderInstances[1];
	
	
	void p_vertical_blur::Initialize()
	{
		static GrShaderData d;
		d.uniqueId = p_vertical_blur::UID;
		d.name = GR_TEXT("p_vertical_blur");
		d.file = GR_TEXT("p_vertical_blur_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VS_Main");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_vertical_blur::NumInstances;
		d.instances = p_vertical_blur::shaderInstances;
		d.getDefines = p_vertical_blur::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_vertical_blur::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_vertical_blur::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_vertical_blur::Shutdown()
	{
	}
	
	
	ID3D11ShaderResourceView* p_vertical_gaussian_blur::sourceTexture = nil;
	ShaderInstance p_vertical_gaussian_blur::shaderInstances[1];
	
	
	void p_vertical_gaussian_blur::Initialize()
	{
		static GrShaderData d;
		d.uniqueId = p_vertical_gaussian_blur::UID;
		d.name = GR_TEXT("p_vertical_gaussian_blur");
		d.file = GR_TEXT("p_vertical_gaussian_blur_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VS_Main");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_vertical_gaussian_blur::NumInstances;
		d.instances = p_vertical_gaussian_blur::shaderInstances;
		d.getDefines = p_vertical_gaussian_blur::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_vertical_gaussian_blur::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_vertical_gaussian_blur::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_vertical_gaussian_blur::Shutdown()
	{
	}
	ID3D11InputLayoutPtr Vertex_P3f::layout;
	ID3D11InputLayoutPtr Vertex_P3f_TEX2f::layout;
	ID3D11InputLayoutPtr Vertex_P3f_TEX2f_N4Ub_T4Ub::layout;
	ID3D11InputLayoutPtr Vertex_P3f_TEX2f_COL4Ub::layout;
	
	static void CreateInputLayouts()
	{
		{
			dxVertexFormat	vtxFormat;
			{
				D3D11_INPUT_ELEMENT_DESC & elemDesc = vtxFormat.elements.Add();
				elemDesc.SemanticName = "Position";
				elemDesc.SemanticIndex = 0;
				elemDesc.Format = DXGI_FORMAT_R32G32B32_FLOAT;
				elemDesc.InputSlot = 0;
				elemDesc.AlignedByteOffset = Vertex_P3f::xyz_stream_offset;
				elemDesc.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				elemDesc.InstanceDataStepRate = 0;
			}
			graphics.resources->Create_InputLayout( Vertex_P3f::layout, vtxFormat.elements.ToPtr(), vtxFormat.elements.Num() );
			dxDbgSetName( Vertex_P3f::layout, "Vertex_P3f" );
		}
		
		{
			dxVertexFormat	vtxFormat;
			{
				D3D11_INPUT_ELEMENT_DESC & elemDesc = vtxFormat.elements.Add();
				elemDesc.SemanticName = "Position";
				elemDesc.SemanticIndex = 0;
				elemDesc.Format = DXGI_FORMAT_R32G32B32_FLOAT;
				elemDesc.InputSlot = 0;
				elemDesc.AlignedByteOffset = Vertex_P3f_TEX2f::xyz_stream_offset;
				elemDesc.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				elemDesc.InstanceDataStepRate = 0;
			}
			{
				D3D11_INPUT_ELEMENT_DESC & elemDesc = vtxFormat.elements.Add();
				elemDesc.SemanticName = "TexCoord";
				elemDesc.SemanticIndex = 0;
				elemDesc.Format = DXGI_FORMAT_R32G32_FLOAT;
				elemDesc.InputSlot = 0;
				elemDesc.AlignedByteOffset = Vertex_P3f_TEX2f::uv_stream_offset;
				elemDesc.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				elemDesc.InstanceDataStepRate = 0;
			}
			graphics.resources->Create_InputLayout( Vertex_P3f_TEX2f::layout, vtxFormat.elements.ToPtr(), vtxFormat.elements.Num() );
			dxDbgSetName( Vertex_P3f_TEX2f::layout, "Vertex_P3f_TEX2f" );
		}
		
		{
			dxVertexFormat	vtxFormat;
			{
				D3D11_INPUT_ELEMENT_DESC & elemDesc = vtxFormat.elements.Add();
				elemDesc.SemanticName = "Position";
				elemDesc.SemanticIndex = 0;
				elemDesc.Format = DXGI_FORMAT_R32G32B32_FLOAT;
				elemDesc.InputSlot = 0;
				elemDesc.AlignedByteOffset = Vertex_P3f_TEX2f_N4Ub_T4Ub::xyz_stream_offset;
				elemDesc.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				elemDesc.InstanceDataStepRate = 0;
			}
			{
				D3D11_INPUT_ELEMENT_DESC & elemDesc = vtxFormat.elements.Add();
				elemDesc.SemanticName = "TexCoord";
				elemDesc.SemanticIndex = 0;
				elemDesc.Format = DXGI_FORMAT_R32G32_FLOAT;
				elemDesc.InputSlot = 1;
				elemDesc.AlignedByteOffset = Vertex_P3f_TEX2f_N4Ub_T4Ub::uv_stream_offset;
				elemDesc.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				elemDesc.InstanceDataStepRate = 0;
			}
			{
				D3D11_INPUT_ELEMENT_DESC & elemDesc = vtxFormat.elements.Add();
				elemDesc.SemanticName = "Normal";
				elemDesc.SemanticIndex = 0;
				elemDesc.Format = DXGI_FORMAT_R8G8B8A8_UINT;
				elemDesc.InputSlot = 1;
				elemDesc.AlignedByteOffset = Vertex_P3f_TEX2f_N4Ub_T4Ub::N_stream_offset;
				elemDesc.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				elemDesc.InstanceDataStepRate = 0;
			}
			{
				D3D11_INPUT_ELEMENT_DESC & elemDesc = vtxFormat.elements.Add();
				elemDesc.SemanticName = "Tangent";
				elemDesc.SemanticIndex = 0;
				elemDesc.Format = DXGI_FORMAT_R8G8B8A8_UINT;
				elemDesc.InputSlot = 1;
				elemDesc.AlignedByteOffset = Vertex_P3f_TEX2f_N4Ub_T4Ub::T_stream_offset;
				elemDesc.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				elemDesc.InstanceDataStepRate = 0;
			}
			graphics.resources->Create_InputLayout( Vertex_P3f_TEX2f_N4Ub_T4Ub::layout, vtxFormat.elements.ToPtr(), vtxFormat.elements.Num() );
			dxDbgSetName( Vertex_P3f_TEX2f_N4Ub_T4Ub::layout, "Vertex_P3f_TEX2f_N4Ub_T4Ub" );
		}
		
		{
			dxVertexFormat	vtxFormat;
			{
				D3D11_INPUT_ELEMENT_DESC & elemDesc = vtxFormat.elements.Add();
				elemDesc.SemanticName = "Position";
				elemDesc.SemanticIndex = 0;
				elemDesc.Format = DXGI_FORMAT_R32G32B32_FLOAT;
				elemDesc.InputSlot = 0;
				elemDesc.AlignedByteOffset = Vertex_P3f_TEX2f_COL4Ub::xyz_stream_offset;
				elemDesc.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				elemDesc.InstanceDataStepRate = 0;
			}
			{
				D3D11_INPUT_ELEMENT_DESC & elemDesc = vtxFormat.elements.Add();
				elemDesc.SemanticName = "TexCoord";
				elemDesc.SemanticIndex = 0;
				elemDesc.Format = DXGI_FORMAT_R32G32_FLOAT;
				elemDesc.InputSlot = 0;
				elemDesc.AlignedByteOffset = Vertex_P3f_TEX2f_COL4Ub::uv_stream_offset;
				elemDesc.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				elemDesc.InstanceDataStepRate = 0;
			}
			{
				D3D11_INPUT_ELEMENT_DESC & elemDesc = vtxFormat.elements.Add();
				elemDesc.SemanticName = "Color";
				elemDesc.SemanticIndex = 0;
				elemDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
				elemDesc.InputSlot = 0;
				elemDesc.AlignedByteOffset = Vertex_P3f_TEX2f_COL4Ub::rgba_stream_offset;
				elemDesc.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				elemDesc.InstanceDataStepRate = 0;
			}
			graphics.resources->Create_InputLayout( Vertex_P3f_TEX2f_COL4Ub::layout, vtxFormat.elements.ToPtr(), vtxFormat.elements.Num() );
			dxDbgSetName( Vertex_P3f_TEX2f_COL4Ub::layout, "Vertex_P3f_TEX2f_COL4Ub" );
		}
		
	}
	void Vertex_P3f::AssembleVertexData( const IndexedMesh& src, VertexData& dest )
	{
		dest.streams.SetNum( NumStreams );
		
		const SizeT vertexCount = src.numVertices;
		
		dest.streams[ xyz_stream ].stride = xyz_stream_size;
		dest.streams[ xyz_stream ].SetNum( vertexCount );
		
		TCopyVertices( c_cast(float3*)dest.streams[ xyz_stream ].ToPtr(), src.positions,
			vertexCount, xyz_stream_size, xyz_stream_offset );
		
	}
	
	void Vertex_P3f_TEX2f::AssembleVertexData( const IndexedMesh& src, VertexData& dest )
	{
		dest.streams.SetNum( NumStreams );
		
		const SizeT vertexCount = src.numVertices;
		
		dest.streams[ xyz_uv_stream ].stride = xyz_uv_stream_size;
		dest.streams[ xyz_uv_stream ].SetNum( vertexCount );
		
		TCopyVertices( c_cast(float3*)dest.streams[ xyz_uv_stream ].ToPtr(), src.positions,
			vertexCount, xyz_uv_stream_size, xyz_stream_offset );
		
		TCopyVertices( c_cast(float2*)dest.streams[ xyz_uv_stream ].ToPtr(), src.texCoords,
			vertexCount, xyz_uv_stream_size, uv_stream_offset );
		
	}
	
	void Vertex_P3f_TEX2f_N4Ub_T4Ub::AssembleVertexData( const IndexedMesh& src, VertexData& dest )
	{
		dest.streams.SetNum( NumStreams );
		
		const SizeT vertexCount = src.numVertices;
		
		dest.streams[ xyz_stream ].stride = xyz_stream_size;
		dest.streams[ xyz_stream ].SetNum( vertexCount );
		
		TCopyVertices( c_cast(float3*)dest.streams[ xyz_stream ].ToPtr(), src.positions,
			vertexCount, xyz_stream_size, xyz_stream_offset );
		
		
		dest.streams[ uv_N_T_stream ].stride = uv_N_T_stream_size;
		dest.streams[ uv_N_T_stream ].SetNum( vertexCount );
		
		TCopyVertices( c_cast(float2*)dest.streams[ uv_N_T_stream ].ToPtr(), src.texCoords,
			vertexCount, uv_N_T_stream_size, uv_stream_offset );
		
		TCopyVertices( c_cast(rxNormal4*)dest.streams[ uv_N_T_stream ].ToPtr(), src.normals,
			vertexCount, uv_N_T_stream_size, N_stream_offset );
		
		TCopyVertices( c_cast(rxNormal4*)dest.streams[ uv_N_T_stream ].ToPtr(), src.tangents,
			vertexCount, uv_N_T_stream_size, T_stream_offset );
		
	}
	
	void Vertex_P3f_TEX2f_COL4Ub::AssembleVertexData( const IndexedMesh& src, VertexData& dest )
	{
		dest.streams.SetNum( NumStreams );
		
		const SizeT vertexCount = src.numVertices;
		
		dest.streams[ xyz_uv_rgba_stream ].stride = xyz_uv_rgba_stream_size;
		dest.streams[ xyz_uv_rgba_stream ].SetNum( vertexCount );
		
		TCopyVertices( c_cast(float3*)dest.streams[ xyz_uv_rgba_stream ].ToPtr(), src.positions,
			vertexCount, xyz_uv_rgba_stream_size, xyz_stream_offset );
		
		TCopyVertices( c_cast(float2*)dest.streams[ xyz_uv_rgba_stream ].ToPtr(), src.texCoords,
			vertexCount, xyz_uv_rgba_stream_size, uv_stream_offset );
		
		TCopyVertices( c_cast(R8G8B8A8*)dest.streams[ xyz_uv_rgba_stream ].ToPtr(), src.colors,
			vertexCount, xyz_uv_rgba_stream_size, rgba_stream_offset );
		
	}
	
	
	
	//===========================================================================
	//	Creation / Destruction
	//===========================================================================
	
	void Initialize( const GrShaderLibraryContext& context )
	{
		// create render targets first so that they're placed in the fastest portion of VRAM
		SetupRenderTargets( context.backBufferWidth, context.backBufferHeight );
		SetupSamplerStates();
		SetupDepthStencilStates();
		SetupRasterizerStates();
		SetupBlendStates();
		SetupStateBlocks();
		CreateInputLayouts();
		SetupSharedSections();
		
		// create shader programs
		p_batched_lines::Initialize();
		p_build_hw_shadow_map::Initialize();
		p_debug_gbuffer_show_diffuse::Initialize();
		p_deferred_directional_light::Initialize();
		p_deferred_fullscreen_point_light::Initialize();
		p_deferred_fullscreen_spot_light::Initialize();
		p_deferred_local_point_light::Initialize();
		p_deferred_local_spot_light::Initialize();
		p_depth_of_field::Initialize();
		p_fullscreen_colored_triangle_shader::Initialize();
		p_fullscreen_textured_triangle_shader::Initialize();
		p_hit_proxy::Initialize();
		p_horizontal_blur::Initialize();
		p_horizontal_gaussian_blur::Initialize();
		p_material_phong::Initialize();
		p_material_plain_color::Initialize();
		p_sky_dome::Initialize();
		p_uber_post_processing_shader::Initialize();
		p_vertical_blur::Initialize();
		p_vertical_gaussian_blur::Initialize();
	}
	
	void Shutdown()
	{
		p_batched_lines::Shutdown();
		p_build_hw_shadow_map::Shutdown();
		p_debug_gbuffer_show_diffuse::Shutdown();
		p_deferred_directional_light::Shutdown();
		p_deferred_fullscreen_point_light::Shutdown();
		p_deferred_fullscreen_spot_light::Shutdown();
		p_deferred_local_point_light::Shutdown();
		p_deferred_local_spot_light::Shutdown();
		p_depth_of_field::Shutdown();
		p_fullscreen_colored_triangle_shader::Shutdown();
		p_fullscreen_textured_triangle_shader::Shutdown();
		p_hit_proxy::Shutdown();
		p_horizontal_blur::Shutdown();
		p_horizontal_gaussian_blur::Shutdown();
		p_material_phong::Shutdown();
		p_material_plain_color::Shutdown();
		p_sky_dome::Shutdown();
		p_uber_post_processing_shader::Shutdown();
		p_vertical_blur::Shutdown();
		p_vertical_gaussian_blur::Shutdown();
		
		graphics.resources->Destroy_SamplerState( SS_Point );
		graphics.resources->Destroy_SamplerState( SS_Bilinear );
		graphics.resources->Destroy_SamplerState( SS_Trilinear );
		graphics.resources->Destroy_SamplerState( SS_Aniso );
		graphics.resources->Destroy_SamplerState( SS_PointClamp );
		graphics.resources->Destroy_SamplerState( SS_LinearClamp );
		graphics.resources->Destroy_SamplerState( SS_ShadowMap );
		graphics.resources->Destroy_SamplerState( SS_ShadowMapPCF );
		graphics.resources->Destroy_SamplerState( SS_ShadowMapPCF_Bilinear );
		
		graphics.resources->Destroy_DepthStencilState( DS_NormalZTestWriteNoStencil );
		graphics.resources->Destroy_DepthStencilState( DS_NormalZTestNoWriteNoStencil );
		graphics.resources->Destroy_DepthStencilState( DS_NoZTestWriteNoStencil );
		graphics.resources->Destroy_DepthStencilState( DS_ZTestLessEqual_ZWrite_NoStencil );
		graphics.resources->Destroy_DepthStencilState( DS_ZTestGreaterNoZWriteNoStencil );
		graphics.resources->Destroy_DepthStencilState( DS_ZTestLessEqualNoZWriteNoStencil );
		
		graphics.resources->Destroy_RasterizerState( RS_SolidNoCull );
		graphics.resources->Destroy_RasterizerState( RS_SolidCullBack );
		graphics.resources->Destroy_RasterizerState( RS_SolidCullFront );
		graphics.resources->Destroy_RasterizerState( RS_WireframeCullBack );
		graphics.resources->Destroy_RasterizerState( RS_SolidNoCullNoClip );
		graphics.resources->Destroy_RasterizerState( RS_WireframeNoCullNoClip );
		graphics.resources->Destroy_RasterizerState( RS_EyeOutsideLightVolume );
		graphics.resources->Destroy_RasterizerState( RS_BuildShadowMap );
		
		graphics.resources->Destroy_BlendState( BS_NoBlending );
		graphics.resources->Destroy_BlendState( BS_AdditiveBlending );
		graphics.resources->Destroy_BlendState( BS_AlphaBlending );
		graphics.resources->Destroy_BlendState( BS_NoBlendingNoColorWrites );
		
		graphics.resources->Destroy_RenderTarget( RT_Normal_SpecIntensity );
		graphics.resources->Destroy_RenderTarget( RT_Diffuse_SpecPower );
		graphics.resources->Destroy_RenderTarget( RT_LinearDepth );
		graphics.resources->Destroy_RenderTarget( RT_HDR_SceneColor );
		graphics.resources->Destroy_RenderTarget( RT_Ping );
		graphics.resources->Destroy_RenderTarget( RT_Pong );
		graphics.resources->Destroy_RenderTarget( RT_Downscaled_4x4 );
		graphics.resources->Destroy_RenderTarget( RT_HBlur_Map );
		graphics.resources->Destroy_RenderTarget( RT_FinalBlur_Map );
		
		ZERO_OUT( Default );
		ZERO_OUT( DebugPrimitives );
		ZERO_OUT( HitProxy_ZTestLessEqualCullBack );
		ZERO_OUT( SolidNoCullNoZTestNoClipNoBlend );
		ZERO_OUT( TranslucentCullBack );
		ZERO_OUT( SkyLast );
		ZERO_OUT( Deferred_Light_FullScreen_Additive );
		ZERO_OUT( Deferred_Light_ConvexMesh_Additive );
		ZERO_OUT( Build_Shadow_Map );
		graphics.resources->Destroy_InputLayout( Vertex_P3f::layout );
		graphics.resources->Destroy_InputLayout( Vertex_P3f_TEX2f::layout );
		graphics.resources->Destroy_InputLayout( Vertex_P3f_TEX2f_N4Ub_T4Ub::layout );
		graphics.resources->Destroy_InputLayout( Vertex_P3f_TEX2f_COL4Ub::layout );
		Shared_Globals::cb_PerFrame.Destroy( graphics.shaders );
		Shared_View::cb_PerView.Destroy( graphics.shaders );
		Shared_Object::cb_PerObject.Destroy( graphics.shaders );
		Shared_LocalLightData::cb_PerLocalLight.Destroy( graphics.shaders );
	}
}
