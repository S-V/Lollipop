/* Do NOT modify this file! It has been autogenerated by the tools.*/
/* File created by HLSL wrapper generator version 0.5 on Tuesday, May 15th, at 19-50-36 */

#pragma once

// Shaders

// 26 shader programs (100 combinations)

#include <Renderer/GPU/HLSL/BuildConfig.h>

namespace GPU
{
	//==============================================================================================================================================
	//
	//	p_adapt_luminance
	//
	//	uses Shared_Globals	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_post_processing.fx(431,7)
	struct MX_GRAPHICS_API p_adapt_luminance
	{
#pragma pack (push,16)
		struct Data
		{
			float4 sampleOffsets[ NUM_8 ];
		};
#pragma pack (pop)
	
	public:	// Constant buffers (manually updated)
		static TConstantBuffer< Data >	cb_Data;	// PS
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* currentLuminanceTexture;	// PS
								enum { SR_Slot_currentLuminanceTexture = 0 };
		static ID3D11ShaderResourceView* adaptedLuminanceTexture;	// PS
								enum { SR_Slot_adaptedLuminanceTexture = 1 };
	
	public:	// Read-only properties
		enum { UID = 0 }; // unique index (within this shader library)
		enum { NumInstances = 1 }; // number of unique combinations
	
	public:	// Public member functions
		static FORCEINLINE ShaderInstance& GetInstance()
		{
			return shaderInstances[ 0 ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext )
		{
			// Bind constant buffers
			theContext->PSSetConstantBuffers(
				1,
				1,
				(ID3D11Buffer**)&cb_Data
			);
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				0,
				2,
				(ID3D11ShaderResourceView**)&currentLuminanceTexture
			);
			
			// Bind shader program
			ShaderInstance & program = shaderInstances[ 0 ];
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11Buffer* old_PS_CBs[ 1 ];
			ID3D11ShaderResourceView* old_PS_SRVs[ 2 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetConstantBuffers( 1, 1, old_PS_CBs );
				pD3DContext->PSGetShaderResources( 0, 2, old_PS_SRVs );
				p_adapt_luminance::Set( pD3DContext );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetConstantBuffers( 1, 1, old_PS_CBs );	D3D_SafeReleaseArray( old_PS_CBs );
				pD3DContext->PSSetShaderResources( 0, 2, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_adapt_luminance() {}
		
		static ShaderInstance	shaderInstances[ p_adapt_luminance::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_batched_lines
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_editor_shaders.fx(6,7)
	struct MX_GRAPHICS_API p_batched_lines
	{
#pragma pack (push,16)
		struct Data
		{
			float4x4 transform;
		};
#pragma pack (pop)
	
	public:	// Constant buffers (manually updated)
		static TConstantBuffer< Data >	cb_Data;	// VS
	
	public:	// Sampler states (set manually)
		static ID3D11SamplerState* linearSampler;	// PS
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* textureMap;	// PS
								enum { SR_Slot_textureMap = 0 };
	
	public:	// Read-only properties
		enum { UID = 1 }; // unique index (within this shader library)
		enum { NumInstances = 2 }; // number of unique combinations
		// Integer bit masks for identifying unique shader program combinations:
		enum Variations
		{
			bTextureMap = BIT(0), //default=0
			DefaultInstanceId = 0
		};
	
	public:	// Public member functions
		static FORCEINLINE BOOL IsValidInstanceId( rxShaderInstanceId instanceId )
		{
			return ( instanceId < p_batched_lines::NumInstances );
		}
		static FORCEINLINE ShaderInstance& GetInstance( rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			return shaderInstances[ instanceId ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			// Bind constant buffers
			theContext->VSSetConstantBuffers(
				0,
				1,
				(ID3D11Buffer**)&cb_Data
			);
			
			// Bind sampler states to slots
			theContext->PSSetSamplers(
				0,
				1,
				(ID3D11SamplerState**)&linearSampler
			);
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				0,
				1,
				(ID3D11ShaderResourceView**)&textureMap
			);
			
			// Bind shader program
			ShaderInstance & program = GetInstance( instanceId );
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11Buffer* old_VS_CBs[ 1 ];
			ID3D11SamplerState* old_PS_SS[ 1 ];
			ID3D11ShaderResourceView* old_PS_SRVs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
			{
				pD3DContext = theContext;
				pD3DContext->VSGetConstantBuffers( 0, 1, old_VS_CBs );
				pD3DContext->PSGetSamplers( 0, 1, old_PS_SS );
				pD3DContext->PSGetShaderResources( 0, 1, old_PS_SRVs );
				p_batched_lines::Set( pD3DContext, instanceId );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->VSSetConstantBuffers( 0, 1, old_VS_CBs );	D3D_SafeReleaseArray( old_VS_CBs );
				pD3DContext->PSSetSamplers( 0, 1, old_PS_SS );	D3D_SafeReleaseArray( old_PS_SS );
				pD3DContext->PSSetShaderResources( 0, 1, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_batched_lines() {}
		
		static ShaderInstance	shaderInstances[ p_batched_lines::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_build_hw_shadow_map
	//
	//	uses Shared_Globals, Shared_View	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_shadow_mapping.fx(9,7)
	struct MX_GRAPHICS_API p_build_hw_shadow_map
	{
#pragma pack (push,16)
		struct Data
		{
			float4x4 lightWVP;
		};
#pragma pack (pop)
	
	public:	// Constant buffers (manually updated)
		static TConstantBuffer< Data >	cb_Data;	// VS
	
	public:	// Read-only properties
		enum { UID = 2 }; // unique index (within this shader library)
		enum { NumInstances = 1 }; // number of unique combinations
	
	public:	// Public member functions
		static FORCEINLINE ShaderInstance& GetInstance()
		{
			return shaderInstances[ 0 ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext )
		{
			// Bind constant buffers
			theContext->VSSetConstantBuffers(
				2,
				1,
				(ID3D11Buffer**)&cb_Data
			);
			
			// Bind shader program
			ShaderInstance & program = shaderInstances[ 0 ];
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				nil,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11Buffer* old_VS_CBs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext )
			{
				pD3DContext = theContext;
				pD3DContext->VSGetConstantBuffers( 2, 1, old_VS_CBs );
				p_build_hw_shadow_map::Set( pD3DContext );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->VSSetConstantBuffers( 2, 1, old_VS_CBs );	D3D_SafeReleaseArray( old_VS_CBs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_build_hw_shadow_map() {}
		
		static ShaderInstance	shaderInstances[ p_build_hw_shadow_map::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_debug_gbuffer_show_diffuse
	//
	//	uses Shared_Globals, Shared_View, Shared_GBuffer	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_debug_shaders.fx(6,7)
	struct MX_GRAPHICS_API p_debug_gbuffer_show_diffuse
	{
	
	public:	// Read-only properties
		enum { UID = 3 }; // unique index (within this shader library)
		enum { NumInstances = 1 }; // number of unique combinations
	
	public:	// Public member functions
		static FORCEINLINE ShaderInstance& GetInstance()
		{
			return shaderInstances[ 0 ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext )
		{
			// Bind shader program
			ShaderInstance & program = shaderInstances[ 0 ];
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext )
			{
				pD3DContext = theContext;
				p_debug_gbuffer_show_diffuse::Set( pD3DContext );
			}
			FORCEINLINE ~SetScoped()
			{
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_debug_gbuffer_show_diffuse() {}
		
		static ShaderInstance	shaderInstances[ p_debug_gbuffer_show_diffuse::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_deferred_directional_light
	//
	//	uses Shared_Globals, Shared_View, Shared_GBuffer	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_deferred_lighting.fx(13,7)
	struct MX_GRAPHICS_API p_deferred_directional_light
	{
#pragma pack (push,16)
		struct Data
		{
			float4 lightVectorVS;
			float4 lightDiffuseColor;
			float4 lightSpecularColor;
			float4x4 shadowMatrices[ NUM_SHADOW_CASCADES ];
			float4 cascadeSplits;
		};
#pragma pack (pop)
	
	public:	// Constant buffers (manually updated)
		static TConstantBuffer< Data >	cb_Data;	// PS
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* shadowDepthMap;	// PS
								enum { SR_Slot_shadowDepthMap = 3 };
	
	public:	// Read-only properties
		enum { UID = 4 }; // unique index (within this shader library)
		enum { NumInstances = 8 }; // number of unique combinations
		// Integer bit masks for identifying unique shader program combinations:
		enum Variations
		{
			bLight_CastShadows = BIT(0), //default=0
			bEnableSoftShadows = BIT(1), //default=1
			bVisualizeCascades = BIT(2), //default=0
			DefaultInstanceId = 1
		};
	
	public:	// Public member functions
		static FORCEINLINE BOOL IsValidInstanceId( rxShaderInstanceId instanceId )
		{
			return ( instanceId < p_deferred_directional_light::NumInstances );
		}
		static FORCEINLINE ShaderInstance& GetInstance( rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			return shaderInstances[ instanceId ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			// Bind constant buffers
			theContext->PSSetConstantBuffers(
				2,
				1,
				(ID3D11Buffer**)&cb_Data
			);
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				3,
				1,
				(ID3D11ShaderResourceView**)&shadowDepthMap
			);
			
			// Bind shader program
			ShaderInstance & program = GetInstance( instanceId );
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11Buffer* old_PS_CBs[ 1 ];
			ID3D11ShaderResourceView* old_PS_SRVs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetConstantBuffers( 2, 1, old_PS_CBs );
				pD3DContext->PSGetShaderResources( 3, 1, old_PS_SRVs );
				p_deferred_directional_light::Set( pD3DContext, instanceId );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetConstantBuffers( 2, 1, old_PS_CBs );	D3D_SafeReleaseArray( old_PS_CBs );
				pD3DContext->PSSetShaderResources( 3, 1, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_deferred_directional_light() {}
		
		static ShaderInstance	shaderInstances[ p_deferred_directional_light::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_deferred_fullscreen_point_light
	//
	//	uses Shared_Globals, Shared_View, Shared_GBuffer, Shared_LocalLightData	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_deferred_lighting.fx(246,7)
	struct MX_GRAPHICS_API p_deferred_fullscreen_point_light
	{
	
	public:	// Read-only properties
		enum { UID = 5 }; // unique index (within this shader library)
		enum { NumInstances = 2 }; // number of unique combinations
		// Integer bit masks for identifying unique shader program combinations:
		enum Variations
		{
			bLight_EnableSpecular = BIT(0), //default=0
			DefaultInstanceId = 0
		};
	
	public:	// Public member functions
		static FORCEINLINE BOOL IsValidInstanceId( rxShaderInstanceId instanceId )
		{
			return ( instanceId < p_deferred_fullscreen_point_light::NumInstances );
		}
		static FORCEINLINE ShaderInstance& GetInstance( rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			return shaderInstances[ instanceId ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			// Bind shader program
			ShaderInstance & program = GetInstance( instanceId );
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
			{
				pD3DContext = theContext;
				p_deferred_fullscreen_point_light::Set( pD3DContext, instanceId );
			}
			FORCEINLINE ~SetScoped()
			{
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_deferred_fullscreen_point_light() {}
		
		static ShaderInstance	shaderInstances[ p_deferred_fullscreen_point_light::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_deferred_fullscreen_spot_light
	//
	//	uses Shared_Globals, Shared_View, Shared_GBuffer, Shared_LocalLightData	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_deferred_lighting.fx(325,7)
	struct MX_GRAPHICS_API p_deferred_fullscreen_spot_light
	{
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* projector;	// PS
								enum { SR_Slot_projector = 3 };
		static ID3D11ShaderResourceView* shadowDepthMap;	// PS
								enum { SR_Slot_shadowDepthMap = 4 };
	
	public:	// Read-only properties
		enum { UID = 6 }; // unique index (within this shader library)
		enum { NumInstances = 8 }; // number of unique combinations
		// Integer bit masks for identifying unique shader program combinations:
		enum Variations
		{
			bLight_EnableSpecular = BIT(0), //default=0
			bSpotLight_ProjectsTexture = BIT(1), //default=0
			bSpotLight_CastShadows = BIT(2), //default=0
			DefaultInstanceId = 0
		};
	
	public:	// Public member functions
		static FORCEINLINE BOOL IsValidInstanceId( rxShaderInstanceId instanceId )
		{
			return ( instanceId < p_deferred_fullscreen_spot_light::NumInstances );
		}
		static FORCEINLINE ShaderInstance& GetInstance( rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			return shaderInstances[ instanceId ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				3,
				2,
				(ID3D11ShaderResourceView**)&projector
			);
			
			// Bind shader program
			ShaderInstance & program = GetInstance( instanceId );
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11ShaderResourceView* old_PS_SRVs[ 2 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetShaderResources( 3, 2, old_PS_SRVs );
				p_deferred_fullscreen_spot_light::Set( pD3DContext, instanceId );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetShaderResources( 3, 2, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_deferred_fullscreen_spot_light() {}
		
		static ShaderInstance	shaderInstances[ p_deferred_fullscreen_spot_light::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_deferred_local_point_light
	//
	//	uses Shared_Globals, Shared_View, Shared_GBuffer, Shared_LocalLightData	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_deferred_lighting.fx(286,7)
	struct MX_GRAPHICS_API p_deferred_local_point_light
	{
	
	public:	// Read-only properties
		enum { UID = 7 }; // unique index (within this shader library)
		enum { NumInstances = 2 }; // number of unique combinations
		// Integer bit masks for identifying unique shader program combinations:
		enum Variations
		{
			bLight_EnableSpecular = BIT(0), //default=0
			DefaultInstanceId = 0
		};
	
	public:	// Public member functions
		static FORCEINLINE BOOL IsValidInstanceId( rxShaderInstanceId instanceId )
		{
			return ( instanceId < p_deferred_local_point_light::NumInstances );
		}
		static FORCEINLINE ShaderInstance& GetInstance( rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			return shaderInstances[ instanceId ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			// Bind shader program
			ShaderInstance & program = GetInstance( instanceId );
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
			{
				pD3DContext = theContext;
				p_deferred_local_point_light::Set( pD3DContext, instanceId );
			}
			FORCEINLINE ~SetScoped()
			{
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_deferred_local_point_light() {}
		
		static ShaderInstance	shaderInstances[ p_deferred_local_point_light::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_deferred_local_spot_light
	//
	//	uses Shared_Globals, Shared_View, Shared_GBuffer, Shared_LocalLightData	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_deferred_lighting.fx(368,7)
	struct MX_GRAPHICS_API p_deferred_local_spot_light
	{
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* projector;	// PS
								enum { SR_Slot_projector = 3 };
		static ID3D11ShaderResourceView* shadowDepthMap;	// PS
								enum { SR_Slot_shadowDepthMap = 4 };
	
	public:	// Read-only properties
		enum { UID = 8 }; // unique index (within this shader library)
		enum { NumInstances = 8 }; // number of unique combinations
		// Integer bit masks for identifying unique shader program combinations:
		enum Variations
		{
			bLight_EnableSpecular = BIT(0), //default=0
			bSpotLight_ProjectsTexture = BIT(1), //default=0
			bSpotLight_CastShadows = BIT(2), //default=0
			DefaultInstanceId = 0
		};
	
	public:	// Public member functions
		static FORCEINLINE BOOL IsValidInstanceId( rxShaderInstanceId instanceId )
		{
			return ( instanceId < p_deferred_local_spot_light::NumInstances );
		}
		static FORCEINLINE ShaderInstance& GetInstance( rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			return shaderInstances[ instanceId ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				3,
				2,
				(ID3D11ShaderResourceView**)&projector
			);
			
			// Bind shader program
			ShaderInstance & program = GetInstance( instanceId );
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11ShaderResourceView* old_PS_SRVs[ 2 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetShaderResources( 3, 2, old_PS_SRVs );
				p_deferred_local_spot_light::Set( pD3DContext, instanceId );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetShaderResources( 3, 2, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_deferred_local_spot_light() {}
		
		static ShaderInstance	shaderInstances[ p_deferred_local_spot_light::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_depth_of_field
	//
	//	uses Shared_Globals, Shared_View, Shared_GBuffer	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_post_processing.fx(812,7)
	struct MX_GRAPHICS_API p_depth_of_field
	{
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* sceneColorTexture;	// PS
								enum { SR_Slot_sceneColorTexture = 3 };
		static ID3D11ShaderResourceView* sceneDepthTexture;	// PS
								enum { SR_Slot_sceneDepthTexture = 4 };
		static ID3D11ShaderResourceView* blurredSceneTexture;	// PS
								enum { SR_Slot_blurredSceneTexture = 5 };
	
	public:	// Read-only properties
		enum { UID = 9 }; // unique index (within this shader library)
		enum { NumInstances = 1 }; // number of unique combinations
	
	public:	// Public member functions
		static FORCEINLINE ShaderInstance& GetInstance()
		{
			return shaderInstances[ 0 ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext )
		{
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				3,
				3,
				(ID3D11ShaderResourceView**)&sceneColorTexture
			);
			
			// Bind shader program
			ShaderInstance & program = shaderInstances[ 0 ];
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11ShaderResourceView* old_PS_SRVs[ 3 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetShaderResources( 3, 3, old_PS_SRVs );
				p_depth_of_field::Set( pD3DContext );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetShaderResources( 3, 3, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_depth_of_field() {}
		
		static ShaderInstance	shaderInstances[ p_depth_of_field::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_downscale_4x4
	//
	//	uses Shared_Globals	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_post_processing.fx(13,7)
	struct MX_GRAPHICS_API p_downscale_4x4
	{
#pragma pack (push,16)
		struct Data
		{
			float2 sampleOffsets[ NUM_16 ];
		};
#pragma pack (pop)
	
	public:	// Constant buffers (manually updated)
		static TConstantBuffer< Data >	cb_Data;	// PS
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* sourceTexture;	// PS
								enum { SR_Slot_sourceTexture = 0 };
	
	public:	// Read-only properties
		enum { UID = 10 }; // unique index (within this shader library)
		enum { NumInstances = 1 }; // number of unique combinations
	
	public:	// Public member functions
		static FORCEINLINE ShaderInstance& GetInstance()
		{
			return shaderInstances[ 0 ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext )
		{
			// Bind constant buffers
			theContext->PSSetConstantBuffers(
				1,
				1,
				(ID3D11Buffer**)&cb_Data
			);
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				0,
				1,
				(ID3D11ShaderResourceView**)&sourceTexture
			);
			
			// Bind shader program
			ShaderInstance & program = shaderInstances[ 0 ];
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11Buffer* old_PS_CBs[ 1 ];
			ID3D11ShaderResourceView* old_PS_SRVs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetConstantBuffers( 1, 1, old_PS_CBs );
				pD3DContext->PSGetShaderResources( 0, 1, old_PS_SRVs );
				p_downscale_4x4::Set( pD3DContext );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetConstantBuffers( 1, 1, old_PS_CBs );	D3D_SafeReleaseArray( old_PS_CBs );
				pD3DContext->PSSetShaderResources( 0, 1, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_downscale_4x4() {}
		
		static ShaderInstance	shaderInstances[ p_downscale_4x4::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_downscale_4x4_bright_pass
	//
	//	uses Shared_Globals	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_post_processing.fx(59,7)
	struct MX_GRAPHICS_API p_downscale_4x4_bright_pass
	{
#pragma pack (push,16)
		struct Data
		{
			float4 sampleOffsets[ NUM_8 ];
		};
#pragma pack (pop)
	
	public:	// Constant buffers (manually updated)
		static TConstantBuffer< Data >	cb_Data;	// PS
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* sourceTexture;	// PS
								enum { SR_Slot_sourceTexture = 0 };
		static ID3D11ShaderResourceView* avgLuminanceTexture;	// PS
								enum { SR_Slot_avgLuminanceTexture = 1 };
	
	public:	// Read-only properties
		enum { UID = 11 }; // unique index (within this shader library)
		enum { NumInstances = 1 }; // number of unique combinations
	
	public:	// Public member functions
		static FORCEINLINE ShaderInstance& GetInstance()
		{
			return shaderInstances[ 0 ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext )
		{
			// Bind constant buffers
			theContext->PSSetConstantBuffers(
				1,
				1,
				(ID3D11Buffer**)&cb_Data
			);
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				0,
				2,
				(ID3D11ShaderResourceView**)&sourceTexture
			);
			
			// Bind shader program
			ShaderInstance & program = shaderInstances[ 0 ];
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11Buffer* old_PS_CBs[ 1 ];
			ID3D11ShaderResourceView* old_PS_SRVs[ 2 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetConstantBuffers( 1, 1, old_PS_CBs );
				pD3DContext->PSGetShaderResources( 0, 2, old_PS_SRVs );
				p_downscale_4x4_bright_pass::Set( pD3DContext );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetConstantBuffers( 1, 1, old_PS_CBs );	D3D_SafeReleaseArray( old_PS_CBs );
				pD3DContext->PSSetShaderResources( 0, 2, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_downscale_4x4_bright_pass() {}
		
		static ShaderInstance	shaderInstances[ p_downscale_4x4_bright_pass::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_fullscreen_colored_triangle_shader
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_screen_shader.fx(28,7)
	struct MX_GRAPHICS_API p_fullscreen_colored_triangle_shader
	{
#pragma pack (push,16)
		struct Data
		{
			float4 color;
		};
#pragma pack (pop)
	
	public:	// Constant buffers (manually updated)
		static TConstantBuffer< Data >	cb_Data;	// PS
	
	public:	// Read-only properties
		enum { UID = 12 }; // unique index (within this shader library)
		enum { NumInstances = 1 }; // number of unique combinations
	
	public:	// Public member functions
		static FORCEINLINE ShaderInstance& GetInstance()
		{
			return shaderInstances[ 0 ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext )
		{
			// Bind constant buffers
			theContext->PSSetConstantBuffers(
				0,
				1,
				(ID3D11Buffer**)&cb_Data
			);
			
			// Bind shader program
			ShaderInstance & program = shaderInstances[ 0 ];
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11Buffer* old_PS_CBs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetConstantBuffers( 0, 1, old_PS_CBs );
				p_fullscreen_colored_triangle_shader::Set( pD3DContext );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetConstantBuffers( 0, 1, old_PS_CBs );	D3D_SafeReleaseArray( old_PS_CBs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_fullscreen_colored_triangle_shader() {}
		
		static ShaderInstance	shaderInstances[ p_fullscreen_colored_triangle_shader::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_fullscreen_textured_triangle_shader
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_screen_shader.fx(1,7)
	struct MX_GRAPHICS_API p_fullscreen_textured_triangle_shader
	{
	
	public:	// Sampler states (set manually)
		static ID3D11SamplerState* linearSampler;	// PS
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* sourceTexture;	// PS
								enum { SR_Slot_sourceTexture = 0 };
	
	public:	// Read-only properties
		enum { UID = 13 }; // unique index (within this shader library)
		enum { NumInstances = 1 }; // number of unique combinations
	
	public:	// Public member functions
		static FORCEINLINE ShaderInstance& GetInstance()
		{
			return shaderInstances[ 0 ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext )
		{
			
			// Bind sampler states to slots
			theContext->PSSetSamplers(
				0,
				1,
				(ID3D11SamplerState**)&linearSampler
			);
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				0,
				1,
				(ID3D11ShaderResourceView**)&sourceTexture
			);
			
			// Bind shader program
			ShaderInstance & program = shaderInstances[ 0 ];
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11SamplerState* old_PS_SS[ 1 ];
			ID3D11ShaderResourceView* old_PS_SRVs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetSamplers( 0, 1, old_PS_SS );
				pD3DContext->PSGetShaderResources( 0, 1, old_PS_SRVs );
				p_fullscreen_textured_triangle_shader::Set( pD3DContext );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetSamplers( 0, 1, old_PS_SS );	D3D_SafeReleaseArray( old_PS_SS );
				pD3DContext->PSSetShaderResources( 0, 1, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_fullscreen_textured_triangle_shader() {}
		
		static ShaderInstance	shaderInstances[ p_fullscreen_textured_triangle_shader::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_hdr_final_scene_pass
	//
	//	uses Shared_Globals	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_post_processing.fx(514,7)
	struct MX_GRAPHICS_API p_hdr_final_scene_pass
	{
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* sourceTexture;	// PS
								enum { SR_Slot_sourceTexture = 0 };
		static ID3D11ShaderResourceView* averageLuminanceTexture;	// PS
								enum { SR_Slot_averageLuminanceTexture = 1 };
		static ID3D11ShaderResourceView* bloomTexture;	// PS
								enum { SR_Slot_bloomTexture = 2 };
	
	public:	// Read-only properties
		enum { UID = 14 }; // unique index (within this shader library)
		enum { NumInstances = 1 }; // number of unique combinations
	
	public:	// Public member functions
		static FORCEINLINE ShaderInstance& GetInstance()
		{
			return shaderInstances[ 0 ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext )
		{
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				0,
				3,
				(ID3D11ShaderResourceView**)&sourceTexture
			);
			
			// Bind shader program
			ShaderInstance & program = shaderInstances[ 0 ];
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11ShaderResourceView* old_PS_SRVs[ 3 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetShaderResources( 0, 3, old_PS_SRVs );
				p_hdr_final_scene_pass::Set( pD3DContext );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetShaderResources( 0, 3, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_hdr_final_scene_pass() {}
		
		static ShaderInstance	shaderInstances[ p_hdr_final_scene_pass::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_hit_proxy
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_editor_shaders.fx(65,7)
	struct MX_GRAPHICS_API p_hit_proxy
	{
#pragma pack (push,16)
		struct Data
		{
			float4x4 transform;
			float4 hitProxyId;
		};
#pragma pack (pop)
	
	public:	// Constant buffers (manually updated)
		static TConstantBuffer< Data >	cb_Data;	// VS PS
	
	public:	// Read-only properties
		enum { UID = 15 }; // unique index (within this shader library)
		enum { NumInstances = 2 }; // number of unique combinations
		// Integer bit masks for identifying unique shader program combinations:
		enum Variations
		{
			bEnableColorWrites = BIT(0), //default=0
			DefaultInstanceId = 0
		};
	
	public:	// Public member functions
		static FORCEINLINE BOOL IsValidInstanceId( rxShaderInstanceId instanceId )
		{
			return ( instanceId < p_hit_proxy::NumInstances );
		}
		static FORCEINLINE ShaderInstance& GetInstance( rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			return shaderInstances[ instanceId ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			// Bind constant buffers
			theContext->VSSetConstantBuffers(
				0,
				1,
				(ID3D11Buffer**)&cb_Data
			);
			theContext->PSSetConstantBuffers(
				0,
				1,
				(ID3D11Buffer**)&cb_Data
			);
			
			// Bind shader program
			ShaderInstance & program = GetInstance( instanceId );
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11Buffer* old_VS_CBs[ 1 ];
			ID3D11Buffer* old_PS_CBs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
			{
				pD3DContext = theContext;
				pD3DContext->VSGetConstantBuffers( 0, 1, old_VS_CBs );
				pD3DContext->PSGetConstantBuffers( 0, 1, old_PS_CBs );
				p_hit_proxy::Set( pD3DContext, instanceId );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->VSSetConstantBuffers( 0, 1, old_VS_CBs );	D3D_SafeReleaseArray( old_VS_CBs );
				pD3DContext->PSSetConstantBuffers( 0, 1, old_PS_CBs );	D3D_SafeReleaseArray( old_PS_CBs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_hit_proxy() {}
		
		static ShaderInstance	shaderInstances[ p_hit_proxy::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_material_phong
	//
	//	uses Shared_Globals, Shared_View, Shared_Object	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_materials.fx(75,7)
	struct MX_GRAPHICS_API p_material_phong
	{
#pragma pack (push,16)
		struct Data
		{
			float4 materialDiffuseColor;
			float4 materialSpecularColor;
			float4 materialEmissiveColor;
		};
#pragma pack (pop)
	
	public:	// Constant buffers (manually updated)
		static TConstantBuffer< Data >	cb_Data;	// PS
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* baseMap;	// PS
								enum { SR_Slot_baseMap = 0 };
		static ID3D11ShaderResourceView* normalMap;	// PS
								enum { SR_Slot_normalMap = 1 };
		static ID3D11ShaderResourceView* specularMap;	// PS
								enum { SR_Slot_specularMap = 2 };
	
	public:	// Read-only properties
		enum { UID = 16 }; // unique index (within this shader library)
		enum { NumInstances = 8 }; // number of unique combinations
		// Integer bit masks for identifying unique shader program combinations:
		enum Variations
		{
			bHasBaseMap = BIT(0), //default=0
			bHasNormalMap = BIT(1), //default=0
			bHasSpecularMap = BIT(2), //default=0
			DefaultInstanceId = 0
		};
	
	public:	// Public member functions
		static FORCEINLINE BOOL IsValidInstanceId( rxShaderInstanceId instanceId )
		{
			return ( instanceId < p_material_phong::NumInstances );
		}
		static FORCEINLINE ShaderInstance& GetInstance( rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			return shaderInstances[ instanceId ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			// Bind constant buffers
			theContext->PSSetConstantBuffers(
				3,
				1,
				(ID3D11Buffer**)&cb_Data
			);
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				0,
				3,
				(ID3D11ShaderResourceView**)&baseMap
			);
			
			// Bind shader program
			ShaderInstance & program = GetInstance( instanceId );
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11Buffer* old_PS_CBs[ 1 ];
			ID3D11ShaderResourceView* old_PS_SRVs[ 3 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetConstantBuffers( 3, 1, old_PS_CBs );
				pD3DContext->PSGetShaderResources( 0, 3, old_PS_SRVs );
				p_material_phong::Set( pD3DContext, instanceId );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetConstantBuffers( 3, 1, old_PS_CBs );	D3D_SafeReleaseArray( old_PS_CBs );
				pD3DContext->PSSetShaderResources( 0, 3, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_material_phong() {}
		
		static ShaderInstance	shaderInstances[ p_material_phong::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_material_plain_color
	//
	//	uses Shared_Globals, Shared_View, Shared_Object	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_materials.fx(13,7)
	struct MX_GRAPHICS_API p_material_plain_color
	{
#pragma pack (push,16)
		struct Data
		{
			float4 materialDiffuseColor;
			float4 materialSpecularColor;
		};
#pragma pack (pop)
	
	public:	// Constant buffers (manually updated)
		static TConstantBuffer< Data >	cb_Data;	// PS
	
	public:	// Read-only properties
		enum { UID = 17 }; // unique index (within this shader library)
		enum { NumInstances = 1 }; // number of unique combinations
	
	public:	// Public member functions
		static FORCEINLINE ShaderInstance& GetInstance()
		{
			return shaderInstances[ 0 ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext )
		{
			// Bind constant buffers
			theContext->PSSetConstantBuffers(
				3,
				1,
				(ID3D11Buffer**)&cb_Data
			);
			
			// Bind shader program
			ShaderInstance & program = shaderInstances[ 0 ];
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11Buffer* old_PS_CBs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetConstantBuffers( 3, 1, old_PS_CBs );
				p_material_plain_color::Set( pD3DContext );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetConstantBuffers( 3, 1, old_PS_CBs );	D3D_SafeReleaseArray( old_PS_CBs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_material_plain_color() {}
		
		static ShaderInstance	shaderInstances[ p_material_plain_color::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_sample_luminance_initial
	//
	//	uses Shared_Globals, Shared_PostProcessData	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_post_processing.fx(299,7)
	struct MX_GRAPHICS_API p_sample_luminance_initial
	{
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* sourceTexture;	// PS
								enum { SR_Slot_sourceTexture = 0 };
	
	public:	// Read-only properties
		enum { UID = 18 }; // unique index (within this shader library)
		enum { NumInstances = 1 }; // number of unique combinations
	
	public:	// Public member functions
		static FORCEINLINE ShaderInstance& GetInstance()
		{
			return shaderInstances[ 0 ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext )
		{
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				0,
				1,
				(ID3D11ShaderResourceView**)&sourceTexture
			);
			
			// Bind shader program
			ShaderInstance & program = shaderInstances[ 0 ];
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11ShaderResourceView* old_PS_SRVs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetShaderResources( 0, 1, old_PS_SRVs );
				p_sample_luminance_initial::Set( pD3DContext );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetShaderResources( 0, 1, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_sample_luminance_initial() {}
		
		static ShaderInstance	shaderInstances[ p_sample_luminance_initial::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_separable_sss_reflectance
	//
	//	uses Shared_Globals, Shared_View	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_skin_shaders.fx(462,7)
	struct MX_GRAPHICS_API p_separable_sss_reflectance
	{
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* sceneColorTexture;	// PS
								enum { SR_Slot_sceneColorTexture = 0 };
		static ID3D11ShaderResourceView* sceneDepthTexture;	// PS
								enum { SR_Slot_sceneDepthTexture = 1 };
	
	public:	// Read-only properties
		enum { UID = 19 }; // unique index (within this shader library)
		enum { NumInstances = 2 }; // number of unique combinations
		// Integer bit masks for identifying unique shader program combinations:
		enum Variations
		{
			bVerticalBlurDirection = BIT(0), //default=0
			DefaultInstanceId = 0
		};
	
	public:	// Public member functions
		static FORCEINLINE BOOL IsValidInstanceId( rxShaderInstanceId instanceId )
		{
			return ( instanceId < p_separable_sss_reflectance::NumInstances );
		}
		static FORCEINLINE ShaderInstance& GetInstance( rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			return shaderInstances[ instanceId ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				0,
				2,
				(ID3D11ShaderResourceView**)&sceneColorTexture
			);
			
			// Bind shader program
			ShaderInstance & program = GetInstance( instanceId );
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11ShaderResourceView* old_PS_SRVs[ 2 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetShaderResources( 0, 2, old_PS_SRVs );
				p_separable_sss_reflectance::Set( pD3DContext, instanceId );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetShaderResources( 0, 2, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_separable_sss_reflectance() {}
		
		static ShaderInstance	shaderInstances[ p_separable_sss_reflectance::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_skin_shader_build_shadow_map
	//
	//	uses Shared_Globals, Shared_View	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_skin_shaders.fx(8,7)
	struct MX_GRAPHICS_API p_skin_shader_build_shadow_map
	{
#pragma pack (push,16)
		struct Data
		{
			float4x4 lightWVP;
		};
#pragma pack (pop)
	
	public:	// Constant buffers (manually updated)
		static TConstantBuffer< Data >	cb_Data;	// VS
	
	public:	// Read-only properties
		enum { UID = 20 }; // unique index (within this shader library)
		enum { NumInstances = 1 }; // number of unique combinations
	
	public:	// Public member functions
		static FORCEINLINE ShaderInstance& GetInstance()
		{
			return shaderInstances[ 0 ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext )
		{
			// Bind constant buffers
			theContext->VSSetConstantBuffers(
				2,
				1,
				(ID3D11Buffer**)&cb_Data
			);
			
			// Bind shader program
			ShaderInstance & program = shaderInstances[ 0 ];
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				nil,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11Buffer* old_VS_CBs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext )
			{
				pD3DContext = theContext;
				pD3DContext->VSGetConstantBuffers( 2, 1, old_VS_CBs );
				p_skin_shader_build_shadow_map::Set( pD3DContext );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->VSSetConstantBuffers( 2, 1, old_VS_CBs );	D3D_SafeReleaseArray( old_VS_CBs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_skin_shader_build_shadow_map() {}
		
		static ShaderInstance	shaderInstances[ p_skin_shader_build_shadow_map::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_skin_shader_forward_pass
	//
	//	uses Shared_Globals, Shared_View, Shared_Object	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_skin_shaders.fx(173,7)
	struct MX_GRAPHICS_API p_skin_shader_forward_pass
	{
#pragma pack (push,16)
		struct Data
		{
			float4 lightPos_Radius;
			float4 lightDir_InvRadius;
			float4 lightDiffuseColor;
			float4 lightSpecularParams;
			float4 lightSpotParams;
			float4x4 lightViewProjection;
			float4 lightShadowParams;
		};
#pragma pack (pop)
	
	public:	// Constant buffers (manually updated)
		static TConstantBuffer< Data >	cb_Data;	// PS
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* baseMap;	// PS
								enum { SR_Slot_baseMap = 0 };
		static ID3D11ShaderResourceView* normalMap;	// PS
								enum { SR_Slot_normalMap = 1 };
		static ID3D11ShaderResourceView* specularMap;	// PS
								enum { SR_Slot_specularMap = 2 };
		static ID3D11ShaderResourceView* shadowDepthMap;	// PS
								enum { SR_Slot_shadowDepthMap = 3 };
		static ID3D11ShaderResourceView* beckmannTexture;	// PS
								enum { SR_Slot_beckmannTexture = 4 };
	
	public:	// Read-only properties
		enum { UID = 21 }; // unique index (within this shader library)
		enum { NumInstances = 16 }; // number of unique combinations
		// Integer bit masks for identifying unique shader program combinations:
		enum Variations
		{
			bEnableSSS = BIT(0), //default=0
			bUseNormalMap = BIT(1), //default=0
			bUseSpecularMap = BIT(2), //default=0
			bEnableShadows = BIT(3), //default=0
			DefaultInstanceId = 0
		};
	
	public:	// Public member functions
		static FORCEINLINE BOOL IsValidInstanceId( rxShaderInstanceId instanceId )
		{
			return ( instanceId < p_skin_shader_forward_pass::NumInstances );
		}
		static FORCEINLINE ShaderInstance& GetInstance( rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			return shaderInstances[ instanceId ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			// Bind constant buffers
			theContext->PSSetConstantBuffers(
				3,
				1,
				(ID3D11Buffer**)&cb_Data
			);
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				0,
				5,
				(ID3D11ShaderResourceView**)&baseMap
			);
			
			// Bind shader program
			ShaderInstance & program = GetInstance( instanceId );
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11Buffer* old_PS_CBs[ 1 ];
			ID3D11ShaderResourceView* old_PS_SRVs[ 5 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetConstantBuffers( 3, 1, old_PS_CBs );
				pD3DContext->PSGetShaderResources( 0, 5, old_PS_SRVs );
				p_skin_shader_forward_pass::Set( pD3DContext, instanceId );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetConstantBuffers( 3, 1, old_PS_CBs );	D3D_SafeReleaseArray( old_PS_CBs );
				pD3DContext->PSSetShaderResources( 0, 5, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_skin_shader_forward_pass() {}
		
		static ShaderInstance	shaderInstances[ p_skin_shader_forward_pass::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_skin_shader_gbuffer_pass
	//
	//	uses Shared_Globals, Shared_View, Shared_Object	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_skin_shaders.fx(58,7)
	struct MX_GRAPHICS_API p_skin_shader_gbuffer_pass
	{
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* baseMap;	// PS
								enum { SR_Slot_baseMap = 0 };
		static ID3D11ShaderResourceView* normalMap;	// PS
								enum { SR_Slot_normalMap = 1 };
		static ID3D11ShaderResourceView* specularMap;	// PS
								enum { SR_Slot_specularMap = 2 };
	
	public:	// Read-only properties
		enum { UID = 22 }; // unique index (within this shader library)
		enum { NumInstances = 4 }; // number of unique combinations
		// Integer bit masks for identifying unique shader program combinations:
		enum Variations
		{
			bHasNormalMap = BIT(0), //default=0
			bHasSpecularMap = BIT(1), //default=0
			DefaultInstanceId = 0
		};
	
	public:	// Public member functions
		static FORCEINLINE BOOL IsValidInstanceId( rxShaderInstanceId instanceId )
		{
			return ( instanceId < p_skin_shader_gbuffer_pass::NumInstances );
		}
		static FORCEINLINE ShaderInstance& GetInstance( rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			return shaderInstances[ instanceId ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				0,
				3,
				(ID3D11ShaderResourceView**)&baseMap
			);
			
			// Bind shader program
			ShaderInstance & program = GetInstance( instanceId );
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11ShaderResourceView* old_PS_SRVs[ 3 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetShaderResources( 0, 3, old_PS_SRVs );
				p_skin_shader_gbuffer_pass::Set( pD3DContext, instanceId );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetShaderResources( 0, 3, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_skin_shader_gbuffer_pass() {}
		
		static ShaderInstance	shaderInstances[ p_skin_shader_gbuffer_pass::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_sky_dome
	//
	//	uses Shared_Globals, Shared_View	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_sky_shaders.fx(8,7)
	struct MX_GRAPHICS_API p_sky_dome
	{
#pragma pack (push,16)
		struct Data
		{
			float4x4 skyDomeTransform;
			float4 sunDirection;
			float4 skyParams;
		};
#pragma pack (pop)
	
	public:	// Constant buffers (manually updated)
		static TConstantBuffer< Data >	cb_Data;	// VS PS
	
	public:	// Sampler states (set manually)
		static ID3D11SamplerState* skyTextureSampler;	// PS
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* skyTexture;	// PS
								enum { SR_Slot_skyTexture = 0 };
	
	public:	// Read-only properties
		enum { UID = 23 }; // unique index (within this shader library)
		enum { NumInstances = 2 }; // number of unique combinations
		// Integer bit masks for identifying unique shader program combinations:
		enum Variations
		{
			bDrawSun = BIT(0), //default=0
			DefaultInstanceId = 0
		};
	
	public:	// Public member functions
		static FORCEINLINE BOOL IsValidInstanceId( rxShaderInstanceId instanceId )
		{
			return ( instanceId < p_sky_dome::NumInstances );
		}
		static FORCEINLINE ShaderInstance& GetInstance( rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			return shaderInstances[ instanceId ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			// Bind constant buffers
			theContext->VSSetConstantBuffers(
				2,
				1,
				(ID3D11Buffer**)&cb_Data
			);
			theContext->PSSetConstantBuffers(
				2,
				1,
				(ID3D11Buffer**)&cb_Data
			);
			
			// Bind sampler states to slots
			theContext->PSSetSamplers(
				14,
				1,
				(ID3D11SamplerState**)&skyTextureSampler
			);
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				0,
				1,
				(ID3D11ShaderResourceView**)&skyTexture
			);
			
			// Bind shader program
			ShaderInstance & program = GetInstance( instanceId );
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11Buffer* old_VS_CBs[ 1 ];
			ID3D11Buffer* old_PS_CBs[ 1 ];
			ID3D11SamplerState* old_PS_SS[ 1 ];
			ID3D11ShaderResourceView* old_PS_SRVs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
			{
				pD3DContext = theContext;
				pD3DContext->VSGetConstantBuffers( 2, 1, old_VS_CBs );
				pD3DContext->PSGetConstantBuffers( 2, 1, old_PS_CBs );
				pD3DContext->PSGetSamplers( 14, 1, old_PS_SS );
				pD3DContext->PSGetShaderResources( 0, 1, old_PS_SRVs );
				p_sky_dome::Set( pD3DContext, instanceId );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->VSSetConstantBuffers( 2, 1, old_VS_CBs );	D3D_SafeReleaseArray( old_VS_CBs );
				pD3DContext->PSSetConstantBuffers( 2, 1, old_PS_CBs );	D3D_SafeReleaseArray( old_PS_CBs );
				pD3DContext->PSSetSamplers( 14, 1, old_PS_SS );	D3D_SafeReleaseArray( old_PS_SS );
				pD3DContext->PSSetShaderResources( 0, 1, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_sky_dome() {}
		
		static ShaderInstance	shaderInstances[ p_sky_dome::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_uber_post_processing_shader
	//
	//	uses Shared_Globals, Shared_View, Shared_GBuffer	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_post_processing.fx(852,7)
	struct MX_GRAPHICS_API p_uber_post_processing_shader
	{
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* sceneColorTexture;	// PS
								enum { SR_Slot_sceneColorTexture = 3 };
		static ID3D11ShaderResourceView* sceneDepthTexture;	// PS
								enum { SR_Slot_sceneDepthTexture = 4 };
		static ID3D11ShaderResourceView* blurredSceneTexture;	// PS
								enum { SR_Slot_blurredSceneTexture = 5 };
		static ID3D11ShaderResourceView* averageLuminanceTexture;	// PS
								enum { SR_Slot_averageLuminanceTexture = 6 };
		static ID3D11ShaderResourceView* bloomTexture;	// PS
								enum { SR_Slot_bloomTexture = 7 };
	
	public:	// Read-only properties
		enum { UID = 24 }; // unique index (within this shader library)
		enum { NumInstances = 8 }; // number of unique combinations
		// Integer bit masks for identifying unique shader program combinations:
		enum Variations
		{
			bEnable_Bloom = BIT(0), //default=1
			bEnable_HDR = BIT(1), //default=1
			bEnable_DOF = BIT(2), //default=1
			DefaultInstanceId = 1
		};
	
	public:	// Public member functions
		static FORCEINLINE BOOL IsValidInstanceId( rxShaderInstanceId instanceId )
		{
			return ( instanceId < p_uber_post_processing_shader::NumInstances );
		}
		static FORCEINLINE ShaderInstance& GetInstance( rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			return shaderInstances[ instanceId ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				3,
				5,
				(ID3D11ShaderResourceView**)&sceneColorTexture
			);
			
			// Bind shader program
			ShaderInstance & program = GetInstance( instanceId );
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11ShaderResourceView* old_PS_SRVs[ 5 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetShaderResources( 3, 5, old_PS_SRVs );
				p_uber_post_processing_shader::Set( pD3DContext, instanceId );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetShaderResources( 3, 5, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_uber_post_processing_shader() {}
		
		static ShaderInstance	shaderInstances[ p_uber_post_processing_shader::NumInstances ];
	};
	
	//==============================================================================================================================================
	//
	//	p_weighted_blur
	//
	//	uses Shared_Globals	
	//
	//==============================================================================================================================================
	//
// D:/_/Development/SourceCode/Renderer/GPU/source/p_post_processing.fx(185,7)
	struct MX_GRAPHICS_API p_weighted_blur
	{
#pragma pack (push,16)
		struct Data
		{
			float4 sampleOffsets[ NUM_8 ];
			float4 sampleWeights[ NUM_4 ];
		};
#pragma pack (pop)
	
	public:	// Constant buffers (manually updated)
		static TConstantBuffer< Data >	cb_Data;	// PS
	
	public:	// Sampler states (set manually)
		static ID3D11SamplerState* sourceSampler;	// PS
	
	public:	// Shader resources (set manually)
		static ID3D11ShaderResourceView* sourceTexture;	// PS
								enum { SR_Slot_sourceTexture = 0 };
	
	public:	// Read-only properties
		enum { UID = 25 }; // unique index (within this shader library)
		enum { NumInstances = 16 }; // number of unique combinations
		// Integer bit masks for identifying unique shader program combinations:
		enum Variations
		{
			iNumSamplesBit0 = BIT(0), //default=1
			iNumSamplesBit1 = BIT(1), //default=0
			iNumSamplesBit2 = BIT(2), //default=0
			iNumSamplesBit3 = BIT(3), //default=0
			DefaultInstanceId = 1
		};
	
	public:	// Public member functions
		static FORCEINLINE BOOL IsValidInstanceId( rxShaderInstanceId instanceId )
		{
			return ( instanceId < p_weighted_blur::NumInstances );
		}
		static FORCEINLINE ShaderInstance& GetInstance( rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			return shaderInstances[ instanceId ];
		}
		static FORCEINLINE void Set( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
		{
			// Bind constant buffers
			theContext->PSSetConstantBuffers(
				1,
				1,
				(ID3D11Buffer**)&cb_Data
			);
			
			// Bind sampler states to slots
			theContext->PSSetSamplers(
				14,
				1,
				(ID3D11SamplerState**)&sourceSampler
			);
			
			// Bind shader resources
			theContext->PSSetShaderResources(
				0,
				1,
				(ID3D11ShaderResourceView**)&sourceTexture
			);
			
			// Bind shader program
			ShaderInstance & program = GetInstance( instanceId );
			
			theContext->VSSetShader(
				program.vertexShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
			theContext->PSSetShader(
				program.pixelShader,
				nil,	// ID3D11ClassInstance *const *ppClassInstances
				0	// NumClassInstances
			);
		}
		
		// NOTE: it doesn't not restore the previous shader program
		class SetScoped
		{
			ID3D11DeviceContext* pD3DContext;
			ID3D11Buffer* old_PS_CBs[ 1 ];
			ID3D11SamplerState* old_PS_SS[ 1 ];
			ID3D11ShaderResourceView* old_PS_SRVs[ 1 ];
		
		public:	// Public member functions
			FORCEINLINE SetScoped( ID3D11DeviceContext* theContext, rxShaderInstanceId instanceId = DefaultInstanceId )
			{
				pD3DContext = theContext;
				pD3DContext->PSGetConstantBuffers( 1, 1, old_PS_CBs );
				pD3DContext->PSGetSamplers( 14, 1, old_PS_SS );
				pD3DContext->PSGetShaderResources( 0, 1, old_PS_SRVs );
				p_weighted_blur::Set( pD3DContext, instanceId );
			}
			FORCEINLINE ~SetScoped()
			{
				pD3DContext->PSSetConstantBuffers( 1, 1, old_PS_CBs );	D3D_SafeReleaseArray( old_PS_CBs );
				pD3DContext->PSSetSamplers( 14, 1, old_PS_SS );	D3D_SafeReleaseArray( old_PS_SS );
				pD3DContext->PSSetShaderResources( 0, 1, old_PS_SRVs );	D3D_SafeReleaseArray( old_PS_SRVs );
			}
		};
	
	public_internal:
		static void Initialize();
		static void Shutdown();
		
		static void GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines );
	
	private:
		p_weighted_blur() {}
		
		static ShaderInstance	shaderInstances[ p_weighted_blur::NumInstances ];
	};
	
	
} // namespace GPU

//--------------------------------------------------------------//
//				End Of File.									//
//--------------------------------------------------------------//
