/* Do NOT modify this file! It has been autogenerated by the tools.*/
/* File created by HLSL wrapper generator version 0.5 on Tuesday, May 15th, at 19-50-36 */

/* This ALWAYS GENERATED file contains the definitions for the interfaces */


#include "Renderer_PCH.h"
#pragma hdrstop
#include "Renderer.h"

// for BinaryStringSearch()
#include <Base/Text/TextUtils.h>

// for dxVertexFormat
#include <Graphics/DX11/DX11Private.h>

// for assemble_vertex_data()
#include <Renderer/Core/Geometry.h>


#include "Main.hxx"
#include "ShaderPrograms.hxx"
#include "VertexFormats.hxx"

namespace GPU
{
	// 05.15.2012  19:50
	const FileTime TIME_STAMP( 2015160096, 30225074 );
	
	// sorted in ascending order
	const char* g_shaderNames[ TotalNumberOfShaders ] =
	{
		"p_adapt_luminance",
		"p_batched_lines",
		"p_build_hw_shadow_map",
		"p_debug_gbuffer_show_diffuse",
		"p_deferred_directional_light",
		"p_deferred_fullscreen_point_light",
		"p_deferred_fullscreen_spot_light",
		"p_deferred_local_point_light",
		"p_deferred_local_spot_light",
		"p_depth_of_field",
		"p_downscale_4x4",
		"p_downscale_4x4_bright_pass",
		"p_fullscreen_colored_triangle_shader",
		"p_fullscreen_textured_triangle_shader",
		"p_hdr_final_scene_pass",
		"p_hit_proxy",
		"p_material_phong",
		"p_material_plain_color",
		"p_sample_luminance_initial",
		"p_separable_sss_reflectance",
		"p_skin_shader_build_shadow_map",
		"p_skin_shader_forward_pass",
		"p_skin_shader_gbuffer_pass",
		"p_sky_dome",
		"p_uber_post_processing_shader",
		"p_weighted_blur",
	};
	
	UINT ShaderNameToIndex( const char* str ) {
		return BinaryStringSearch( g_shaderNames, ARRAY_SIZE(g_shaderNames), str );
	}
	
	const char* ShaderIndexToName( UINT idx ) {
		Assert( idx < ARRAY_SIZE(g_shaderNames) );
		return g_shaderNames[ idx ];
	}
	
	//===========================================================================
	//	Render targets
	//===========================================================================
	
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(11,13)
	RenderTarget RT_Normal_SpecIntensity;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(20,13)
	RenderTarget RT_Diffuse_SpecPower;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(29,13)
	RenderTarget RT_LinearDepth;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(72,13)
	RenderTarget RT_HDR_SceneColor;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(85,13)
	RenderTarget RT_Ping;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(92,13)
	RenderTarget RT_Pong;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(108,13)
	RenderTarget RT_Downscaled_4x4;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(116,13)
	RenderTarget RT_Downscaled_4x4_B;
	
	static void SetupRenderTargets( const UINT sizeX, const UINT sizeY )
	{
		rxGPU_MARKER( Create_Render_Targets );

		D3D11_TEXTURE2D_DESC texDesc;
		D3D11_RENDER_TARGET_VIEW_DESC rtvDesc;
		D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
		
// RT_Normal_SpecIntensity
// "Normals & Specular intensity"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(11,13)
		Assert( RT_Normal_SpecIntensity.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R8G8B8A8_UNORM;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_Normal_SpecIntensity, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_Normal_SpecIntensity.pTexture, "RT_Normal_SpecIntensity_T2D" );
			dxDbgSetName( RT_Normal_SpecIntensity.pRTV, "RT_Normal_SpecIntensity_RTV" );
			dxDbgSetName( RT_Normal_SpecIntensity.pSRV, "RT_Normal_SpecIntensity_SRV" );
		}
// RT_Diffuse_SpecPower
// "Diffuse & Specular power"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(20,13)
		Assert( RT_Diffuse_SpecPower.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R8G8B8A8_UNORM;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_Diffuse_SpecPower, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_Diffuse_SpecPower.pTexture, "RT_Diffuse_SpecPower_T2D" );
			dxDbgSetName( RT_Diffuse_SpecPower.pRTV, "RT_Diffuse_SpecPower_RTV" );
			dxDbgSetName( RT_Diffuse_SpecPower.pSRV, "RT_Diffuse_SpecPower_SRV" );
		}
// RT_LinearDepth
// "Depth"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(29,13)
		Assert( RT_LinearDepth.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R32_FLOAT;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R32_FLOAT;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R32_FLOAT;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_LinearDepth, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_LinearDepth.pTexture, "RT_LinearDepth_T2D" );
			dxDbgSetName( RT_LinearDepth.pRTV, "RT_LinearDepth_RTV" );
			dxDbgSetName( RT_LinearDepth.pSRV, "RT_LinearDepth_SRV" );
		}
// RT_HDR_SceneColor
// "HDR Light Accum"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(72,13)
		Assert( RT_HDR_SceneColor.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R16G16B16A16_FLOAT;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R16G16B16A16_FLOAT;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R16G16B16A16_FLOAT;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_HDR_SceneColor, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_HDR_SceneColor.pTexture, "RT_HDR_SceneColor_T2D" );
			dxDbgSetName( RT_HDR_SceneColor.pRTV, "RT_HDR_SceneColor_RTV" );
			dxDbgSetName( RT_HDR_SceneColor.pSRV, "RT_HDR_SceneColor_SRV" );
		}
// RT_Ping
// "Temporary storage"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(85,13)
		Assert( RT_Ping.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R16G16B16A16_FLOAT;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R16G16B16A16_FLOAT;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R16G16B16A16_FLOAT;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_Ping, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_Ping.pTexture, "RT_Ping_T2D" );
			dxDbgSetName( RT_Ping.pRTV, "RT_Ping_RTV" );
			dxDbgSetName( RT_Ping.pSRV, "RT_Ping_SRV" );
		}
// RT_Pong
// "Temporary storage"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(92,13)
		Assert( RT_Pong.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R16G16B16A16_FLOAT;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R16G16B16A16_FLOAT;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R16G16B16A16_FLOAT;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_Pong, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_Pong.pTexture, "RT_Pong_T2D" );
			dxDbgSetName( RT_Pong.pRTV, "RT_Pong_RTV" );
			dxDbgSetName( RT_Pong.pSRV, "RT_Pong_SRV" );
		}
// RT_Downscaled_4x4
// "Downscaled map for bloom"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(108,13)
		Assert( RT_Downscaled_4x4.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			texDesc.Width				= sizeX * 0.250000f;
			texDesc.Height				= sizeY * 0.250000f;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R8G8B8A8_UNORM;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_Downscaled_4x4, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_Downscaled_4x4.pTexture, "RT_Downscaled_4x4_T2D" );
			dxDbgSetName( RT_Downscaled_4x4.pRTV, "RT_Downscaled_4x4_RTV" );
			dxDbgSetName( RT_Downscaled_4x4.pSRV, "RT_Downscaled_4x4_SRV" );
		}
// RT_Downscaled_4x4_B
// "Downscaled map for bloom (B)"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(116,13)
		Assert( RT_Downscaled_4x4_B.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			texDesc.Width				= sizeX * 0.250000f;
			texDesc.Height				= sizeY * 0.250000f;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R8G8B8A8_UNORM;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_Downscaled_4x4_B, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_Downscaled_4x4_B.pTexture, "RT_Downscaled_4x4_B_T2D" );
			dxDbgSetName( RT_Downscaled_4x4_B.pRTV, "RT_Downscaled_4x4_B_RTV" );
			dxDbgSetName( RT_Downscaled_4x4_B.pSRV, "RT_Downscaled_4x4_B_SRV" );
		}
		#if MX_EDITOR
		{
			gRenderer.editor->GetTextureInspector()->AddDebugItem( RT_Normal_SpecIntensity.pTexture, "RT_Normal_SpecIntensity" );
			gRenderer.editor->GetTextureInspector()->AddDebugItem( RT_Diffuse_SpecPower.pTexture, "RT_Diffuse_SpecPower" );
			gRenderer.editor->GetTextureInspector()->AddDebugItem( RT_LinearDepth.pTexture, "RT_LinearDepth" );
			gRenderer.editor->GetTextureInspector()->AddDebugItem( RT_HDR_SceneColor.pTexture, "RT_HDR_SceneColor" );
			gRenderer.editor->GetTextureInspector()->AddDebugItem( RT_Ping.pTexture, "RT_Ping" );
			gRenderer.editor->GetTextureInspector()->AddDebugItem( RT_Pong.pTexture, "RT_Pong" );
			gRenderer.editor->GetTextureInspector()->AddDebugItem( RT_Downscaled_4x4.pTexture, "RT_Downscaled_4x4" );
			gRenderer.editor->GetTextureInspector()->AddDebugItem( RT_Downscaled_4x4_B.pTexture, "RT_Downscaled_4x4_B" );
		}
		#endif // MX_EDITOR
	}
	
	// releases render targets that depend on backbuffer size; should be called before resizing viewports
	void ReleaseRenderTargets()
	{
		rxGPU_MARKER( Release_Render_Targets );

		#if MX_EDITOR
		{
			gRenderer.editor->GetTextureInspector()->RemoveDebugItem( RT_Normal_SpecIntensity.pTexture );
			gRenderer.editor->GetTextureInspector()->RemoveDebugItem( RT_Diffuse_SpecPower.pTexture );
			gRenderer.editor->GetTextureInspector()->RemoveDebugItem( RT_LinearDepth.pTexture );
			gRenderer.editor->GetTextureInspector()->RemoveDebugItem( RT_HDR_SceneColor.pTexture );
			gRenderer.editor->GetTextureInspector()->RemoveDebugItem( RT_Ping.pTexture );
			gRenderer.editor->GetTextureInspector()->RemoveDebugItem( RT_Pong.pTexture );
			gRenderer.editor->GetTextureInspector()->RemoveDebugItem( RT_Downscaled_4x4.pTexture );
			gRenderer.editor->GetTextureInspector()->RemoveDebugItem( RT_Downscaled_4x4_B.pTexture );
		}
		#endif // MX_EDITOR
		RT_Normal_SpecIntensity.Release();
		RT_Diffuse_SpecPower.Release();
		RT_LinearDepth.Release();
		RT_HDR_SceneColor.Release();
		RT_Ping.Release();
		RT_Pong.Release();
		RT_Downscaled_4x4.Release();
		RT_Downscaled_4x4_B.Release();
	}
	
	// recreates render targets that depend on backbuffer size; should be called after resizing viewports
	void ReallocRenderTargets( UINT sizeX, UINT sizeY )
	{
		rxGPU_MARKER( Realloc_Render_Targets );

		D3D11_TEXTURE2D_DESC texDesc;
		D3D11_RENDER_TARGET_VIEW_DESC rtvDesc;
		D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
		
		Assert( RT_Normal_SpecIntensity.IsNull() );
// RT_Normal_SpecIntensity
// "Normals & Specular intensity"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(11,13)
		Assert( RT_Normal_SpecIntensity.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R8G8B8A8_UNORM;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_Normal_SpecIntensity, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_Normal_SpecIntensity.pTexture, "RT_Normal_SpecIntensity_T2D" );
			dxDbgSetName( RT_Normal_SpecIntensity.pRTV, "RT_Normal_SpecIntensity_RTV" );
			dxDbgSetName( RT_Normal_SpecIntensity.pSRV, "RT_Normal_SpecIntensity_SRV" );
		}
		
		Assert( RT_Diffuse_SpecPower.IsNull() );
// RT_Diffuse_SpecPower
// "Diffuse & Specular power"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(20,13)
		Assert( RT_Diffuse_SpecPower.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R8G8B8A8_UNORM;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_Diffuse_SpecPower, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_Diffuse_SpecPower.pTexture, "RT_Diffuse_SpecPower_T2D" );
			dxDbgSetName( RT_Diffuse_SpecPower.pRTV, "RT_Diffuse_SpecPower_RTV" );
			dxDbgSetName( RT_Diffuse_SpecPower.pSRV, "RT_Diffuse_SpecPower_SRV" );
		}
		
		Assert( RT_LinearDepth.IsNull() );
// RT_LinearDepth
// "Depth"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(29,13)
		Assert( RT_LinearDepth.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R32_FLOAT;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R32_FLOAT;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R32_FLOAT;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_LinearDepth, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_LinearDepth.pTexture, "RT_LinearDepth_T2D" );
			dxDbgSetName( RT_LinearDepth.pRTV, "RT_LinearDepth_RTV" );
			dxDbgSetName( RT_LinearDepth.pSRV, "RT_LinearDepth_SRV" );
		}
		
		Assert( RT_HDR_SceneColor.IsNull() );
// RT_HDR_SceneColor
// "HDR Light Accum"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(72,13)
		Assert( RT_HDR_SceneColor.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R16G16B16A16_FLOAT;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R16G16B16A16_FLOAT;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R16G16B16A16_FLOAT;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_HDR_SceneColor, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_HDR_SceneColor.pTexture, "RT_HDR_SceneColor_T2D" );
			dxDbgSetName( RT_HDR_SceneColor.pRTV, "RT_HDR_SceneColor_RTV" );
			dxDbgSetName( RT_HDR_SceneColor.pSRV, "RT_HDR_SceneColor_SRV" );
		}
		
		Assert( RT_Ping.IsNull() );
// RT_Ping
// "Temporary storage"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(85,13)
		Assert( RT_Ping.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R16G16B16A16_FLOAT;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R16G16B16A16_FLOAT;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R16G16B16A16_FLOAT;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_Ping, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_Ping.pTexture, "RT_Ping_T2D" );
			dxDbgSetName( RT_Ping.pRTV, "RT_Ping_RTV" );
			dxDbgSetName( RT_Ping.pSRV, "RT_Ping_SRV" );
		}
		
		Assert( RT_Pong.IsNull() );
// RT_Pong
// "Temporary storage"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(92,13)
		Assert( RT_Pong.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R16G16B16A16_FLOAT;
			texDesc.Width				= sizeX;
			texDesc.Height				= sizeY;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R16G16B16A16_FLOAT;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R16G16B16A16_FLOAT;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_Pong, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_Pong.pTexture, "RT_Pong_T2D" );
			dxDbgSetName( RT_Pong.pRTV, "RT_Pong_RTV" );
			dxDbgSetName( RT_Pong.pSRV, "RT_Pong_SRV" );
		}
		
		Assert( RT_Downscaled_4x4.IsNull() );
// RT_Downscaled_4x4
// "Downscaled map for bloom"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(108,13)
		Assert( RT_Downscaled_4x4.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			texDesc.Width				= sizeX * 0.250000f;
			texDesc.Height				= sizeY * 0.250000f;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R8G8B8A8_UNORM;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_Downscaled_4x4, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_Downscaled_4x4.pTexture, "RT_Downscaled_4x4_T2D" );
			dxDbgSetName( RT_Downscaled_4x4.pRTV, "RT_Downscaled_4x4_RTV" );
			dxDbgSetName( RT_Downscaled_4x4.pSRV, "RT_Downscaled_4x4_SRV" );
		}
		
		Assert( RT_Downscaled_4x4_B.IsNull() );
// RT_Downscaled_4x4_B
// "Downscaled map for bloom (B)"
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_targets.fx(116,13)
		Assert( RT_Downscaled_4x4_B.IsNull() );
		{
			texDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			texDesc.Width				= sizeX * 0.250000f;
			texDesc.Height				= sizeY * 0.250000f;
			texDesc.MipLevels			= 1;
			texDesc.ArraySize			= 1;
			texDesc.SampleDesc.Count	= 1;
			texDesc.SampleDesc.Quality	= 0;
			texDesc.Usage				= D3D11_USAGE_DEFAULT;
			texDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
			texDesc.CPUAccessFlags		= 0;
			texDesc.MiscFlags			= 0;
			
			rtvDesc.Format				= DXGI_FORMAT_R8G8B8A8_UNORM;
			rtvDesc.ViewDimension		= D3D11_RTV_DIMENSION_TEXTURE2D;
			rtvDesc.Texture2D.MipSlice	= 0;
			
			srvDesc.Format						= DXGI_FORMAT_R8G8B8A8_UNORM;
			srvDesc.ViewDimension				= D3D11_SRV_DIMENSION_TEXTURE2D;
			srvDesc.Texture2D.MipLevels			= 1;
			srvDesc.Texture2D.MostDetailedMip	= 0;
			
			graphics.resources->Create_RenderTarget( RT_Downscaled_4x4_B, texDesc, rtvDesc, srvDesc );
			
			dxDbgSetName( RT_Downscaled_4x4_B.pTexture, "RT_Downscaled_4x4_B_T2D" );
			dxDbgSetName( RT_Downscaled_4x4_B.pRTV, "RT_Downscaled_4x4_B_RTV" );
			dxDbgSetName( RT_Downscaled_4x4_B.pSRV, "RT_Downscaled_4x4_B_SRV" );
		}
		#if MX_EDITOR
		{
			gRenderer.editor->GetTextureInspector()->AddDebugItem( RT_Normal_SpecIntensity.pTexture, "RT_Normal_SpecIntensity" );
			gRenderer.editor->GetTextureInspector()->AddDebugItem( RT_Diffuse_SpecPower.pTexture, "RT_Diffuse_SpecPower" );
			gRenderer.editor->GetTextureInspector()->AddDebugItem( RT_LinearDepth.pTexture, "RT_LinearDepth" );
			gRenderer.editor->GetTextureInspector()->AddDebugItem( RT_HDR_SceneColor.pTexture, "RT_HDR_SceneColor" );
			gRenderer.editor->GetTextureInspector()->AddDebugItem( RT_Ping.pTexture, "RT_Ping" );
			gRenderer.editor->GetTextureInspector()->AddDebugItem( RT_Pong.pTexture, "RT_Pong" );
			gRenderer.editor->GetTextureInspector()->AddDebugItem( RT_Downscaled_4x4.pTexture, "RT_Downscaled_4x4" );
			gRenderer.editor->GetTextureInspector()->AddDebugItem( RT_Downscaled_4x4_B.pTexture, "RT_Downscaled_4x4_B" );
		}
		#endif // MX_EDITOR
	}
	
	void EnumerateRenderTargets( F_EnumerateRenderTargets* callback, void* userData )
	{
		(*callback)( &RT_Normal_SpecIntensity, userData );
		(*callback)( &RT_Diffuse_SpecPower, userData );
		(*callback)( &RT_LinearDepth, userData );
		(*callback)( &RT_HDR_SceneColor, userData );
		(*callback)( &RT_Ping, userData );
		(*callback)( &RT_Pong, userData );
		(*callback)( &RT_Downscaled_4x4, userData );
		(*callback)( &RT_Downscaled_4x4_B, userData );
	}
	
	//===========================================================================
	//	Sampler states
	//===========================================================================
	
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(7,13)
	ID3D11SamplerStatePtr SS_Point;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(13,13)
	ID3D11SamplerStatePtr SS_Bilinear;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(20,13)
	ID3D11SamplerStatePtr SS_Trilinear;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(27,13)
	ID3D11SamplerStatePtr SS_Aniso;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(36,13)
	ID3D11SamplerStatePtr SS_PointClamp;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(42,13)
	ID3D11SamplerStatePtr SS_LinearClamp;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(50,13)
	ID3D11SamplerStatePtr SS_ShadowMap;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(64,13)
	ID3D11SamplerStatePtr SS_ShadowMapPCF;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(78,13)
	ID3D11SamplerStatePtr SS_ShadowMapPCF_Bilinear;
	
	static void SetupSamplerStates()
	{
		rxGPU_MARKER( Create_Sampler_States );

		D3D11_SAMPLER_DESC samplerDesc;
		
// SS_Point
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(7,13)
		{
			samplerDesc.Filter	= D3D11_FILTER_MIN_MAG_MIP_POINT;
			samplerDesc.AddressU	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.AddressV	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.AddressW	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.MipLODBias		= 0.000000f;
			samplerDesc.MaxAnisotropy	= 1;
			samplerDesc.ComparisonFunc	= D3D11_COMPARISON_NEVER;
			samplerDesc.BorderColor[0]	= 1.000000f;
			samplerDesc.BorderColor[1]	= 1.000000f;
			samplerDesc.BorderColor[2]	= 1.000000f;
			samplerDesc.BorderColor[3]	= 1.000000f;
			samplerDesc.MinLOD			= 0.0f;
			samplerDesc.MaxLOD			= D3D11_FLOAT32_MAX;
			
			graphics.resources->Create_SamplerState( SS_Point, samplerDesc );
			dxDbgSetName( SS_Point, "SS_Point" );
		}
		
// SS_Bilinear
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(13,13)
		{
			samplerDesc.Filter	= D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT;
			samplerDesc.AddressU	= D3D11_TEXTURE_ADDRESS_WRAP;
			samplerDesc.AddressV	= D3D11_TEXTURE_ADDRESS_WRAP;
			samplerDesc.AddressW	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.MipLODBias		= 0.000000f;
			samplerDesc.MaxAnisotropy	= 1;
			samplerDesc.ComparisonFunc	= D3D11_COMPARISON_NEVER;
			samplerDesc.BorderColor[0]	= 1.000000f;
			samplerDesc.BorderColor[1]	= 1.000000f;
			samplerDesc.BorderColor[2]	= 1.000000f;
			samplerDesc.BorderColor[3]	= 1.000000f;
			samplerDesc.MinLOD			= 0.0f;
			samplerDesc.MaxLOD			= D3D11_FLOAT32_MAX;
			
			graphics.resources->Create_SamplerState( SS_Bilinear, samplerDesc );
			dxDbgSetName( SS_Bilinear, "SS_Bilinear" );
		}
		
// SS_Trilinear
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(20,13)
		{
			samplerDesc.Filter	= D3D11_FILTER_MIN_MAG_MIP_LINEAR;
			samplerDesc.AddressU	= D3D11_TEXTURE_ADDRESS_WRAP;
			samplerDesc.AddressV	= D3D11_TEXTURE_ADDRESS_WRAP;
			samplerDesc.AddressW	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.MipLODBias		= 0.000000f;
			samplerDesc.MaxAnisotropy	= 1;
			samplerDesc.ComparisonFunc	= D3D11_COMPARISON_NEVER;
			samplerDesc.BorderColor[0]	= 1.000000f;
			samplerDesc.BorderColor[1]	= 1.000000f;
			samplerDesc.BorderColor[2]	= 1.000000f;
			samplerDesc.BorderColor[3]	= 1.000000f;
			samplerDesc.MinLOD			= 0.0f;
			samplerDesc.MaxLOD			= D3D11_FLOAT32_MAX;
			
			graphics.resources->Create_SamplerState( SS_Trilinear, samplerDesc );
			dxDbgSetName( SS_Trilinear, "SS_Trilinear" );
		}
		
// SS_Aniso
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(27,13)
		{
			samplerDesc.Filter	= D3D11_FILTER_ANISOTROPIC;
			samplerDesc.AddressU	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.AddressV	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.AddressW	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.MipLODBias		= 0.000000f;
			samplerDesc.MaxAnisotropy	= 8;
			samplerDesc.ComparisonFunc	= D3D11_COMPARISON_NEVER;
			samplerDesc.BorderColor[0]	= 1.000000f;
			samplerDesc.BorderColor[1]	= 1.000000f;
			samplerDesc.BorderColor[2]	= 1.000000f;
			samplerDesc.BorderColor[3]	= 1.000000f;
			samplerDesc.MinLOD			= 0.0f;
			samplerDesc.MaxLOD			= D3D11_FLOAT32_MAX;
			
			graphics.resources->Create_SamplerState( SS_Aniso, samplerDesc );
			dxDbgSetName( SS_Aniso, "SS_Aniso" );
		}
		
// SS_PointClamp
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(36,13)
		{
			samplerDesc.Filter	= D3D11_FILTER_MIN_MAG_MIP_POINT;
			samplerDesc.AddressU	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.AddressV	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.AddressW	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.MipLODBias		= 0.000000f;
			samplerDesc.MaxAnisotropy	= 1;
			samplerDesc.ComparisonFunc	= D3D11_COMPARISON_NEVER;
			samplerDesc.BorderColor[0]	= 1.000000f;
			samplerDesc.BorderColor[1]	= 1.000000f;
			samplerDesc.BorderColor[2]	= 1.000000f;
			samplerDesc.BorderColor[3]	= 1.000000f;
			samplerDesc.MinLOD			= 0.0f;
			samplerDesc.MaxLOD			= D3D11_FLOAT32_MAX;
			
			graphics.resources->Create_SamplerState( SS_PointClamp, samplerDesc );
			dxDbgSetName( SS_PointClamp, "SS_PointClamp" );
		}
		
// SS_LinearClamp
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(42,13)
		{
			samplerDesc.Filter	= D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT;
			samplerDesc.AddressU	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.AddressV	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.AddressW	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.MipLODBias		= 0.000000f;
			samplerDesc.MaxAnisotropy	= 1;
			samplerDesc.ComparisonFunc	= D3D11_COMPARISON_NEVER;
			samplerDesc.BorderColor[0]	= 1.000000f;
			samplerDesc.BorderColor[1]	= 1.000000f;
			samplerDesc.BorderColor[2]	= 1.000000f;
			samplerDesc.BorderColor[3]	= 1.000000f;
			samplerDesc.MinLOD			= 0.0f;
			samplerDesc.MaxLOD			= D3D11_FLOAT32_MAX;
			
			graphics.resources->Create_SamplerState( SS_LinearClamp, samplerDesc );
			dxDbgSetName( SS_LinearClamp, "SS_LinearClamp" );
		}
		
// SS_ShadowMap
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(50,13)
		{
			samplerDesc.Filter	= D3D11_FILTER_COMPARISON_MIN_MAG_MIP_POINT;
			samplerDesc.AddressU	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.AddressV	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.AddressW	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.MipLODBias		= 0.000000f;
			samplerDesc.MaxAnisotropy	= 1;
			samplerDesc.ComparisonFunc	= D3D11_COMPARISON_LESS_EQUAL;
			samplerDesc.BorderColor[0]	= 0.000000f;
			samplerDesc.BorderColor[1]	= 0.000000f;
			samplerDesc.BorderColor[2]	= 0.000000f;
			samplerDesc.BorderColor[3]	= 0.000000f;
			samplerDesc.MinLOD			= 0.0f;
			samplerDesc.MaxLOD			= D3D11_FLOAT32_MAX;
			
			graphics.resources->Create_SamplerState( SS_ShadowMap, samplerDesc );
			dxDbgSetName( SS_ShadowMap, "SS_ShadowMap" );
		}
		
// SS_ShadowMapPCF
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(64,13)
		{
			samplerDesc.Filter	= D3D11_FILTER_COMPARISON_MIN_MAG_MIP_POINT;
			samplerDesc.AddressU	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.AddressV	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.AddressW	= D3D11_TEXTURE_ADDRESS_CLAMP;
			samplerDesc.MipLODBias		= 0.000000f;
			samplerDesc.MaxAnisotropy	= 1;
			samplerDesc.ComparisonFunc	= D3D11_COMPARISON_LESS_EQUAL;
			samplerDesc.BorderColor[0]	= 0.000000f;
			samplerDesc.BorderColor[1]	= 0.000000f;
			samplerDesc.BorderColor[2]	= 0.000000f;
			samplerDesc.BorderColor[3]	= 0.000000f;
			samplerDesc.MinLOD			= 0.0f;
			samplerDesc.MaxLOD			= D3D11_FLOAT32_MAX;
			
			graphics.resources->Create_SamplerState( SS_ShadowMapPCF, samplerDesc );
			dxDbgSetName( SS_ShadowMapPCF, "SS_ShadowMapPCF" );
		}
		
// SS_ShadowMapPCF_Bilinear
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(78,13)
		{
			samplerDesc.Filter	= D3D11_FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT;
			samplerDesc.AddressU	= D3D11_TEXTURE_ADDRESS_BORDER;
			samplerDesc.AddressV	= D3D11_TEXTURE_ADDRESS_BORDER;
			samplerDesc.AddressW	= D3D11_TEXTURE_ADDRESS_BORDER;
			samplerDesc.MipLODBias		= 0.000000f;
			samplerDesc.MaxAnisotropy	= 1;
			samplerDesc.ComparisonFunc	= D3D11_COMPARISON_LESS;
			samplerDesc.BorderColor[0]	= 0.000000f;
			samplerDesc.BorderColor[1]	= 0.000000f;
			samplerDesc.BorderColor[2]	= 0.000000f;
			samplerDesc.BorderColor[3]	= 0.000000f;
			samplerDesc.MinLOD			= 0.0f;
			samplerDesc.MaxLOD			= D3D11_FLOAT32_MAX;
			
			graphics.resources->Create_SamplerState( SS_ShadowMapPCF_Bilinear, samplerDesc );
			dxDbgSetName( SS_ShadowMapPCF_Bilinear, "SS_ShadowMapPCF_Bilinear" );
		}
	}
	
	void EnumerateSamplerStates( F_EnumerateSamplerStates* callback, void* userData )
	{
		(*callback)( SS_Point, userData );
		(*callback)( SS_Bilinear, userData );
		(*callback)( SS_Trilinear, userData );
		(*callback)( SS_Aniso, userData );
		(*callback)( SS_PointClamp, userData );
		(*callback)( SS_LinearClamp, userData );
		(*callback)( SS_ShadowMap, userData );
		(*callback)( SS_ShadowMapPCF, userData );
		(*callback)( SS_ShadowMapPCF_Bilinear, userData );
	}
	
	//===========================================================================
	//	Depth-Stencil states
	//===========================================================================
	
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(99,18)
	ID3D11DepthStencilStatePtr DS_NormalZTestWriteNoStencil;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(106,18)
	ID3D11DepthStencilStatePtr DS_NormalZTestNoWriteNoStencil;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(113,18)
	ID3D11DepthStencilStatePtr DS_NoZTestWriteNoStencil;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(120,18)
	ID3D11DepthStencilStatePtr DS_ZTestLessEqual_ZWrite_NoStencil;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(128,18)
	ID3D11DepthStencilStatePtr DS_NormalZTestWrite_StencilWrite;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(139,18)
	ID3D11DepthStencilStatePtr DS_SeparableSSS;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(154,18)
	ID3D11DepthStencilStatePtr DS_ZTestGreaterNoZWriteNoStencil;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(165,18)
	ID3D11DepthStencilStatePtr DS_ZTestLessEqualNoZWriteNoStencil;
	
	static void SetupDepthStencilStates()
	{
		rxGPU_MARKER( Create_DepthStencil_States );

		D3D11_DEPTH_STENCIL_DESC depthStencilDesc;
		
// DS_NormalZTestWriteNoStencil
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(99,18)
		{
			depthStencilDesc.DepthEnable	= TRUE;
			depthStencilDesc.DepthWriteMask	= D3D11_DEPTH_WRITE_MASK_ALL;
			depthStencilDesc.DepthFunc	= D3D11_COMPARISON_LESS;
			depthStencilDesc.StencilEnable	= FALSE;
			depthStencilDesc.StencilReadMask	= D3D11_DEFAULT_STENCIL_READ_MASK;
			depthStencilDesc.StencilWriteMask	= D3D11_DEFAULT_STENCIL_WRITE_MASK;
			depthStencilDesc.FrontFace.StencilFailOp		= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilPassOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			depthStencilDesc.BackFace.StencilFailOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilPassOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			
			graphics.resources->Create_DepthStencilState( DS_NormalZTestWriteNoStencil, depthStencilDesc );
			dxDbgSetName( DS_NormalZTestWriteNoStencil, "DS_NormalZTestWriteNoStencil" );
		}
		
// DS_NormalZTestNoWriteNoStencil
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(106,18)
		{
			depthStencilDesc.DepthEnable	= TRUE;
			depthStencilDesc.DepthWriteMask	= D3D11_DEPTH_WRITE_MASK_ZERO;
			depthStencilDesc.DepthFunc	= D3D11_COMPARISON_LESS;
			depthStencilDesc.StencilEnable	= FALSE;
			depthStencilDesc.StencilReadMask	= D3D11_DEFAULT_STENCIL_READ_MASK;
			depthStencilDesc.StencilWriteMask	= D3D11_DEFAULT_STENCIL_WRITE_MASK;
			depthStencilDesc.FrontFace.StencilFailOp		= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilPassOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			depthStencilDesc.BackFace.StencilFailOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilPassOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			
			graphics.resources->Create_DepthStencilState( DS_NormalZTestNoWriteNoStencil, depthStencilDesc );
			dxDbgSetName( DS_NormalZTestNoWriteNoStencil, "DS_NormalZTestNoWriteNoStencil" );
		}
		
// DS_NoZTestWriteNoStencil
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(113,18)
		{
			depthStencilDesc.DepthEnable	= FALSE;
			depthStencilDesc.DepthWriteMask	= D3D11_DEPTH_WRITE_MASK_ZERO;
			depthStencilDesc.DepthFunc	= D3D11_COMPARISON_ALWAYS;
			depthStencilDesc.StencilEnable	= FALSE;
			depthStencilDesc.StencilReadMask	= D3D11_DEFAULT_STENCIL_READ_MASK;
			depthStencilDesc.StencilWriteMask	= D3D11_DEFAULT_STENCIL_WRITE_MASK;
			depthStencilDesc.FrontFace.StencilFailOp		= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilPassOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			depthStencilDesc.BackFace.StencilFailOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilPassOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			
			graphics.resources->Create_DepthStencilState( DS_NoZTestWriteNoStencil, depthStencilDesc );
			dxDbgSetName( DS_NoZTestWriteNoStencil, "DS_NoZTestWriteNoStencil" );
		}
		
// DS_ZTestLessEqual_ZWrite_NoStencil
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(120,18)
		{
			depthStencilDesc.DepthEnable	= TRUE;
			depthStencilDesc.DepthWriteMask	= D3D11_DEPTH_WRITE_MASK_ALL;
			depthStencilDesc.DepthFunc	= D3D11_COMPARISON_LESS_EQUAL;
			depthStencilDesc.StencilEnable	= FALSE;
			depthStencilDesc.StencilReadMask	= D3D11_DEFAULT_STENCIL_READ_MASK;
			depthStencilDesc.StencilWriteMask	= D3D11_DEFAULT_STENCIL_WRITE_MASK;
			depthStencilDesc.FrontFace.StencilFailOp		= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilPassOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			depthStencilDesc.BackFace.StencilFailOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilPassOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			
			graphics.resources->Create_DepthStencilState( DS_ZTestLessEqual_ZWrite_NoStencil, depthStencilDesc );
			dxDbgSetName( DS_ZTestLessEqual_ZWrite_NoStencil, "DS_ZTestLessEqual_ZWrite_NoStencil" );
		}
		
// DS_NormalZTestWrite_StencilWrite
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(128,18)
		{
			depthStencilDesc.DepthEnable	= TRUE;
			depthStencilDesc.DepthWriteMask	= D3D11_DEPTH_WRITE_MASK_ALL;
			depthStencilDesc.DepthFunc	= D3D11_COMPARISON_LESS_EQUAL;
			depthStencilDesc.StencilEnable	= TRUE;
			depthStencilDesc.StencilReadMask	= D3D11_DEFAULT_STENCIL_READ_MASK;
			depthStencilDesc.StencilWriteMask	= D3D11_DEFAULT_STENCIL_WRITE_MASK;
			depthStencilDesc.FrontFace.StencilFailOp		= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilPassOp			= D3D11_STENCIL_OP_REPLACE;
			depthStencilDesc.FrontFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			depthStencilDesc.BackFace.StencilFailOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilPassOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			
			graphics.resources->Create_DepthStencilState( DS_NormalZTestWrite_StencilWrite, depthStencilDesc );
			dxDbgSetName( DS_NormalZTestWrite_StencilWrite, "DS_NormalZTestWrite_StencilWrite" );
		}
		
// DS_SeparableSSS
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(139,18)
		{
			depthStencilDesc.DepthEnable	= FALSE;
			depthStencilDesc.DepthWriteMask	= D3D11_DEPTH_WRITE_MASK_ZERO;
			depthStencilDesc.DepthFunc	= D3D11_COMPARISON_ALWAYS;
			depthStencilDesc.StencilEnable	= TRUE;
			depthStencilDesc.StencilReadMask	= D3D11_DEFAULT_STENCIL_READ_MASK;
			depthStencilDesc.StencilWriteMask	= D3D11_DEFAULT_STENCIL_WRITE_MASK;
			depthStencilDesc.FrontFace.StencilFailOp		= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilPassOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilFunc			= D3D11_COMPARISON_EQUAL;
			depthStencilDesc.BackFace.StencilFailOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilPassOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			
			graphics.resources->Create_DepthStencilState( DS_SeparableSSS, depthStencilDesc );
			dxDbgSetName( DS_SeparableSSS, "DS_SeparableSSS" );
		}
		
// DS_ZTestGreaterNoZWriteNoStencil
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(154,18)
		{
			depthStencilDesc.DepthEnable	= TRUE;
			depthStencilDesc.DepthWriteMask	= D3D11_DEPTH_WRITE_MASK_ZERO;
			depthStencilDesc.DepthFunc	= D3D11_COMPARISON_GREATER;
			depthStencilDesc.StencilEnable	= FALSE;
			depthStencilDesc.StencilReadMask	= D3D11_DEFAULT_STENCIL_READ_MASK;
			depthStencilDesc.StencilWriteMask	= D3D11_DEFAULT_STENCIL_WRITE_MASK;
			depthStencilDesc.FrontFace.StencilFailOp		= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilPassOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			depthStencilDesc.BackFace.StencilFailOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilPassOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			
			graphics.resources->Create_DepthStencilState( DS_ZTestGreaterNoZWriteNoStencil, depthStencilDesc );
			dxDbgSetName( DS_ZTestGreaterNoZWriteNoStencil, "DS_ZTestGreaterNoZWriteNoStencil" );
		}
		
// DS_ZTestLessEqualNoZWriteNoStencil
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(165,18)
		{
			depthStencilDesc.DepthEnable	= TRUE;
			depthStencilDesc.DepthWriteMask	= D3D11_DEPTH_WRITE_MASK_ZERO;
			depthStencilDesc.DepthFunc	= D3D11_COMPARISON_LESS_EQUAL;
			depthStencilDesc.StencilEnable	= FALSE;
			depthStencilDesc.StencilReadMask	= D3D11_DEFAULT_STENCIL_READ_MASK;
			depthStencilDesc.StencilWriteMask	= D3D11_DEFAULT_STENCIL_WRITE_MASK;
			depthStencilDesc.FrontFace.StencilFailOp		= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilPassOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.FrontFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			depthStencilDesc.BackFace.StencilFailOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilDepthFailOp	= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilPassOp			= D3D11_STENCIL_OP_KEEP;
			depthStencilDesc.BackFace.StencilFunc			= D3D11_COMPARISON_ALWAYS;
			
			graphics.resources->Create_DepthStencilState( DS_ZTestLessEqualNoZWriteNoStencil, depthStencilDesc );
			dxDbgSetName( DS_ZTestLessEqualNoZWriteNoStencil, "DS_ZTestLessEqualNoZWriteNoStencil" );
		}
	}
	
	void EnumerateDepthStencilStates( F_EnumerateDepthStencilStates* callback, void* userData )
	{
		(*callback)( DS_NormalZTestWriteNoStencil, userData );
		(*callback)( DS_NormalZTestNoWriteNoStencil, userData );
		(*callback)( DS_NoZTestWriteNoStencil, userData );
		(*callback)( DS_ZTestLessEqual_ZWrite_NoStencil, userData );
		(*callback)( DS_NormalZTestWrite_StencilWrite, userData );
		(*callback)( DS_SeparableSSS, userData );
		(*callback)( DS_ZTestGreaterNoZWriteNoStencil, userData );
		(*callback)( DS_ZTestLessEqualNoZWriteNoStencil, userData );
	}
	
	//===========================================================================
	//	Rasterizer states
	//===========================================================================
	
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(178,16)
	ID3D11RasterizerStatePtr RS_SolidNoCull;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(185,16)
	ID3D11RasterizerStatePtr RS_SolidCullBack;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(192,16)
	ID3D11RasterizerStatePtr RS_SolidCullFront;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(199,16)
	ID3D11RasterizerStatePtr RS_WireframeCullBack;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(207,16)
	ID3D11RasterizerStatePtr RS_SolidNoCullNoClip;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(214,16)
	ID3D11RasterizerStatePtr RS_WireframeNoCullNoClip;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(396,16)
	ID3D11RasterizerStatePtr RS_EyeOutsideLightVolume;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(420,16)
	ID3D11RasterizerStatePtr RS_BuildShadowMap;
	
	static void SetupRasterizerStates()
	{
		rxGPU_MARKER( Create_Rasterizer_States );

		D3D11_RASTERIZER_DESC rasterizerDesc;
		
// RS_SolidNoCull
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(178,16)
		{
			rasterizerDesc.FillMode				= D3D11_FILL_SOLID;
			rasterizerDesc.CullMode				= D3D11_CULL_NONE;
			rasterizerDesc.FrontCounterClockwise	= FALSE;
			rasterizerDesc.DepthBias				= 0;
			rasterizerDesc.DepthBiasClamp		= 0.0f;
			rasterizerDesc.SlopeScaledDepthBias	= 0.0f;
			rasterizerDesc.DepthClipEnable		= TRUE;
			rasterizerDesc.ScissorEnable			= FALSE;
			rasterizerDesc.MultisampleEnable		= FALSE;
			rasterizerDesc.AntialiasedLineEnable	= FALSE;
			
			graphics.resources->Create_RasterizerState( RS_SolidNoCull, rasterizerDesc );
			dxDbgSetName( RS_SolidNoCull, "RS_SolidNoCull" );
		}
		
// RS_SolidCullBack
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(185,16)
		{
			rasterizerDesc.FillMode				= D3D11_FILL_SOLID;
			rasterizerDesc.CullMode				= D3D11_CULL_BACK;
			rasterizerDesc.FrontCounterClockwise	= FALSE;
			rasterizerDesc.DepthBias				= 0;
			rasterizerDesc.DepthBiasClamp		= 0.0f;
			rasterizerDesc.SlopeScaledDepthBias	= 0.0f;
			rasterizerDesc.DepthClipEnable		= TRUE;
			rasterizerDesc.ScissorEnable			= FALSE;
			rasterizerDesc.MultisampleEnable		= FALSE;
			rasterizerDesc.AntialiasedLineEnable	= FALSE;
			
			graphics.resources->Create_RasterizerState( RS_SolidCullBack, rasterizerDesc );
			dxDbgSetName( RS_SolidCullBack, "RS_SolidCullBack" );
		}
		
// RS_SolidCullFront
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(192,16)
		{
			rasterizerDesc.FillMode				= D3D11_FILL_SOLID;
			rasterizerDesc.CullMode				= D3D11_CULL_FRONT;
			rasterizerDesc.FrontCounterClockwise	= FALSE;
			rasterizerDesc.DepthBias				= 0;
			rasterizerDesc.DepthBiasClamp		= 0.0f;
			rasterizerDesc.SlopeScaledDepthBias	= 0.0f;
			rasterizerDesc.DepthClipEnable		= TRUE;
			rasterizerDesc.ScissorEnable			= FALSE;
			rasterizerDesc.MultisampleEnable		= FALSE;
			rasterizerDesc.AntialiasedLineEnable	= FALSE;
			
			graphics.resources->Create_RasterizerState( RS_SolidCullFront, rasterizerDesc );
			dxDbgSetName( RS_SolidCullFront, "RS_SolidCullFront" );
		}
		
// RS_WireframeCullBack
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(199,16)
		{
			rasterizerDesc.FillMode				= D3D11_FILL_WIREFRAME;
			rasterizerDesc.CullMode				= D3D11_CULL_BACK;
			rasterizerDesc.FrontCounterClockwise	= FALSE;
			rasterizerDesc.DepthBias				= 0;
			rasterizerDesc.DepthBiasClamp		= 0.0f;
			rasterizerDesc.SlopeScaledDepthBias	= 0.0f;
			rasterizerDesc.DepthClipEnable		= TRUE;
			rasterizerDesc.ScissorEnable			= FALSE;
			rasterizerDesc.MultisampleEnable		= FALSE;
			rasterizerDesc.AntialiasedLineEnable	= FALSE;
			
			graphics.resources->Create_RasterizerState( RS_WireframeCullBack, rasterizerDesc );
			dxDbgSetName( RS_WireframeCullBack, "RS_WireframeCullBack" );
		}
		
// RS_SolidNoCullNoClip
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(207,16)
		{
			rasterizerDesc.FillMode				= D3D11_FILL_SOLID;
			rasterizerDesc.CullMode				= D3D11_CULL_NONE;
			rasterizerDesc.FrontCounterClockwise	= FALSE;
			rasterizerDesc.DepthBias				= 0;
			rasterizerDesc.DepthBiasClamp		= 0.0f;
			rasterizerDesc.SlopeScaledDepthBias	= 0.0f;
			rasterizerDesc.DepthClipEnable		= FALSE;
			rasterizerDesc.ScissorEnable			= FALSE;
			rasterizerDesc.MultisampleEnable		= FALSE;
			rasterizerDesc.AntialiasedLineEnable	= FALSE;
			
			graphics.resources->Create_RasterizerState( RS_SolidNoCullNoClip, rasterizerDesc );
			dxDbgSetName( RS_SolidNoCullNoClip, "RS_SolidNoCullNoClip" );
		}
		
// RS_WireframeNoCullNoClip
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(214,16)
		{
			rasterizerDesc.FillMode				= D3D11_FILL_WIREFRAME;
			rasterizerDesc.CullMode				= D3D11_CULL_NONE;
			rasterizerDesc.FrontCounterClockwise	= FALSE;
			rasterizerDesc.DepthBias				= 0;
			rasterizerDesc.DepthBiasClamp		= 0.0f;
			rasterizerDesc.SlopeScaledDepthBias	= 0.0f;
			rasterizerDesc.DepthClipEnable		= FALSE;
			rasterizerDesc.ScissorEnable			= FALSE;
			rasterizerDesc.MultisampleEnable		= FALSE;
			rasterizerDesc.AntialiasedLineEnable	= FALSE;
			
			graphics.resources->Create_RasterizerState( RS_WireframeNoCullNoClip, rasterizerDesc );
			dxDbgSetName( RS_WireframeNoCullNoClip, "RS_WireframeNoCullNoClip" );
		}
		
// RS_EyeOutsideLightVolume
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(396,16)
		{
			rasterizerDesc.FillMode				= D3D11_FILL_SOLID;
			rasterizerDesc.CullMode				= D3D11_CULL_BACK;
			rasterizerDesc.FrontCounterClockwise	= FALSE;
			rasterizerDesc.DepthBias				= 0;
			rasterizerDesc.DepthBiasClamp		= 0.0f;
			rasterizerDesc.SlopeScaledDepthBias	= 0.0f;
			rasterizerDesc.DepthClipEnable		= FALSE;
			rasterizerDesc.ScissorEnable			= FALSE;
			rasterizerDesc.MultisampleEnable		= FALSE;
			rasterizerDesc.AntialiasedLineEnable	= FALSE;
			
			graphics.resources->Create_RasterizerState( RS_EyeOutsideLightVolume, rasterizerDesc );
			dxDbgSetName( RS_EyeOutsideLightVolume, "RS_EyeOutsideLightVolume" );
		}
		
// RS_BuildShadowMap
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(420,16)
		{
			rasterizerDesc.FillMode				= D3D11_FILL_SOLID;
			rasterizerDesc.CullMode				= D3D11_CULL_BACK;
			rasterizerDesc.FrontCounterClockwise	= FALSE;
			rasterizerDesc.DepthBias				= 0;
			rasterizerDesc.DepthBiasClamp		= 0.0f;
			rasterizerDesc.SlopeScaledDepthBias	= 0.7F;
			rasterizerDesc.DepthClipEnable		= TRUE;
			rasterizerDesc.ScissorEnable			= FALSE;
			rasterizerDesc.MultisampleEnable		= FALSE;
			rasterizerDesc.AntialiasedLineEnable	= FALSE;
			
			graphics.resources->Create_RasterizerState( RS_BuildShadowMap, rasterizerDesc );
			dxDbgSetName( RS_BuildShadowMap, "RS_BuildShadowMap" );
		}
	}
	
	void EnumerateRasterizerStates( F_EnumerateRasterizerStates* callback, void* userData )
	{
		(*callback)( RS_SolidNoCull, userData );
		(*callback)( RS_SolidCullBack, userData );
		(*callback)( RS_SolidCullFront, userData );
		(*callback)( RS_WireframeCullBack, userData );
		(*callback)( RS_SolidNoCullNoClip, userData );
		(*callback)( RS_WireframeNoCullNoClip, userData );
		(*callback)( RS_EyeOutsideLightVolume, userData );
		(*callback)( RS_BuildShadowMap, userData );
	}
	
	//===========================================================================
	//	Blend states
	//===========================================================================
	
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(228,11)
	ID3D11BlendStatePtr BS_NoBlending;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(235,11)
	ID3D11BlendStatePtr BS_AdditiveBlending;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(246,11)
	ID3D11BlendStatePtr BS_AlphaBlending;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(258,11)
	ID3D11BlendStatePtr BS_NoBlendingNoColorWrites;
	
	static void SetupBlendStates()
	{
		rxGPU_MARKER( Create_Blend_States );

		D3D11_BLEND_DESC blendDesc;
		ZERO_OUT( blendDesc );
		
// BS_NoBlending
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(228,11)
		{
			blendDesc.AlphaToCoverageEnable	= FALSE;
			blendDesc.IndependentBlendEnable	= FALSE;
			blendDesc.RenderTarget[0].BlendEnable	= FALSE;
			blendDesc.RenderTarget[0].SrcBlend		= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].DestBlend		= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].BlendOp		= D3D11_BLEND_OP_ADD;
			blendDesc.RenderTarget[0].SrcBlendAlpha	= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].DestBlendAlpha	= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].BlendOpAlpha	= D3D11_BLEND_OP_ADD;
			blendDesc.RenderTarget[0].RenderTargetWriteMask	= 0x0F;
			
			graphics.resources->Create_BlendState( BS_NoBlending, blendDesc );
			dxDbgSetName( BS_NoBlending, "BS_NoBlending" );
		}
		
// BS_AdditiveBlending
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(235,11)
		{
			blendDesc.AlphaToCoverageEnable	= FALSE;
			blendDesc.IndependentBlendEnable	= FALSE;
			blendDesc.RenderTarget[0].BlendEnable	= TRUE;
			blendDesc.RenderTarget[0].SrcBlend		= D3D11_BLEND_ONE;
			blendDesc.RenderTarget[0].DestBlend		= D3D11_BLEND_ONE;
			blendDesc.RenderTarget[0].BlendOp		= D3D11_BLEND_OP_ADD;
			blendDesc.RenderTarget[0].SrcBlendAlpha	= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].DestBlendAlpha	= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].BlendOpAlpha	= D3D11_BLEND_OP_ADD;
			blendDesc.RenderTarget[0].RenderTargetWriteMask	= D3D11_COLOR_WRITE_ENABLE_ALL;
			
			graphics.resources->Create_BlendState( BS_AdditiveBlending, blendDesc );
			dxDbgSetName( BS_AdditiveBlending, "BS_AdditiveBlending" );
		}
		
// BS_AlphaBlending
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(246,11)
		{
			blendDesc.AlphaToCoverageEnable	= FALSE;
			blendDesc.IndependentBlendEnable	= FALSE;
			blendDesc.RenderTarget[0].BlendEnable	= TRUE;
			blendDesc.RenderTarget[0].SrcBlend		= D3D11_BLEND_SRC_ALPHA;
			blendDesc.RenderTarget[0].DestBlend		= D3D11_BLEND_INV_SRC_ALPHA;
			blendDesc.RenderTarget[0].BlendOp		= D3D11_BLEND_OP_ADD;
			blendDesc.RenderTarget[0].SrcBlendAlpha	= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].DestBlendAlpha	= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].BlendOpAlpha	= D3D11_BLEND_OP_ADD;
			blendDesc.RenderTarget[0].RenderTargetWriteMask	= D3D11_COLOR_WRITE_ENABLE_ALL;
			
			graphics.resources->Create_BlendState( BS_AlphaBlending, blendDesc );
			dxDbgSetName( BS_AlphaBlending, "BS_AlphaBlending" );
		}
		
// BS_NoBlendingNoColorWrites
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(258,11)
		{
			blendDesc.AlphaToCoverageEnable	= FALSE;
			blendDesc.IndependentBlendEnable	= FALSE;
			blendDesc.RenderTarget[0].BlendEnable	= FALSE;
			blendDesc.RenderTarget[0].SrcBlend		= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].DestBlend		= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].BlendOp		= D3D11_BLEND_OP_ADD;
			blendDesc.RenderTarget[0].SrcBlendAlpha	= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].DestBlendAlpha	= D3D11_BLEND_ZERO;
			blendDesc.RenderTarget[0].BlendOpAlpha	= D3D11_BLEND_OP_ADD;
			blendDesc.RenderTarget[0].RenderTargetWriteMask	= 0;
			
			graphics.resources->Create_BlendState( BS_NoBlendingNoColorWrites, blendDesc );
			dxDbgSetName( BS_NoBlendingNoColorWrites, "BS_NoBlendingNoColorWrites" );
		}
	}
	
	void EnumerateBlendStates( F_EnumerateBlendStates* callback, void* userData )
	{
		(*callback)( BS_NoBlending, userData );
		(*callback)( BS_AdditiveBlending, userData );
		(*callback)( BS_AlphaBlending, userData );
		(*callback)( BS_NoBlendingNoColorWrites, userData );
	}
	
	//===========================================================================
	//	State blocks
	//===========================================================================
	
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(271,11)
	StateBlock Default;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(287,11)
	StateBlock DebugPrimitives;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(299,11)
	StateBlock HitProxy_ZTestLessEqualCullBack;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(321,11)
	StateBlock SolidNoCullNoZTestNoClipNoBlend;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(346,11)
	StateBlock TranslucentCullBack;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(360,11)
	StateBlock SkyLast;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(378,11)
	StateBlock Deferred_Light_FullScreen_Additive;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(404,11)
	StateBlock Deferred_Light_ConvexMesh_Additive;
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(429,11)
	StateBlock Build_Shadow_Map;
	
	static void SetupStateBlocks()
	{
		
// Default
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(271,11)
		{
			Default.rasterizer   = RS_SolidCullBack;
			
			Default.depthStencil = DS_NormalZTestWriteNoStencil;
			Default.stencilRef   = 0;
			
			Default.blend           = BS_NoBlending;
			Default.blendFactorRGBA[0] = 0.000000;
			Default.blendFactorRGBA[1] = 0.000000;
			Default.blendFactorRGBA[2] = 0.000000;
			Default.blendFactorRGBA[3] = 1.000000;
			Default.sampleMask      = 0xFFFFFFFF;
		}
		
// DebugPrimitives
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(287,11)
		{
			DebugPrimitives.rasterizer   = RS_SolidNoCullNoClip;
			
			DebugPrimitives.depthStencil = DS_ZTestLessEqualNoZWriteNoStencil;
			DebugPrimitives.stencilRef   = 0;
			
			DebugPrimitives.blend           = BS_NoBlending;
			DebugPrimitives.blendFactorRGBA[0] = 0.000000;
			DebugPrimitives.blendFactorRGBA[1] = 0.000000;
			DebugPrimitives.blendFactorRGBA[2] = 0.000000;
			DebugPrimitives.blendFactorRGBA[3] = 1.000000;
			DebugPrimitives.sampleMask      = 0xFFFFFFFF;
		}
		
// HitProxy_ZTestLessEqualCullBack
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(299,11)
		{
			HitProxy_ZTestLessEqualCullBack.rasterizer   = RS_SolidCullBack;
			
			HitProxy_ZTestLessEqualCullBack.depthStencil = DS_ZTestLessEqualNoZWriteNoStencil;
			HitProxy_ZTestLessEqualCullBack.stencilRef   = 0;
			
			HitProxy_ZTestLessEqualCullBack.blend           = BS_NoBlending;
			HitProxy_ZTestLessEqualCullBack.blendFactorRGBA[0] = 0.000000;
			HitProxy_ZTestLessEqualCullBack.blendFactorRGBA[1] = 0.000000;
			HitProxy_ZTestLessEqualCullBack.blendFactorRGBA[2] = 0.000000;
			HitProxy_ZTestLessEqualCullBack.blendFactorRGBA[3] = 1.000000;
			HitProxy_ZTestLessEqualCullBack.sampleMask      = 0xFFFFFFFF;
		}
		
// SolidNoCullNoZTestNoClipNoBlend
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(321,11)
		{
			SolidNoCullNoZTestNoClipNoBlend.rasterizer   = RS_SolidNoCullNoClip;
			
			SolidNoCullNoZTestNoClipNoBlend.depthStencil = DS_NoZTestWriteNoStencil;
			SolidNoCullNoZTestNoClipNoBlend.stencilRef   = 0;
			
			SolidNoCullNoZTestNoClipNoBlend.blend           = BS_NoBlending;
			SolidNoCullNoZTestNoClipNoBlend.blendFactorRGBA[0] = 0.000000;
			SolidNoCullNoZTestNoClipNoBlend.blendFactorRGBA[1] = 0.000000;
			SolidNoCullNoZTestNoClipNoBlend.blendFactorRGBA[2] = 0.000000;
			SolidNoCullNoZTestNoClipNoBlend.blendFactorRGBA[3] = 1.000000;
			SolidNoCullNoZTestNoClipNoBlend.sampleMask      = 0xFFFFFFFF;
		}
		
// TranslucentCullBack
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(346,11)
		{
			TranslucentCullBack.rasterizer   = RS_SolidCullBack;
			
			TranslucentCullBack.depthStencil = DS_NormalZTestNoWriteNoStencil;
			TranslucentCullBack.stencilRef   = 0;
			
			TranslucentCullBack.blend           = BS_AlphaBlending;
			TranslucentCullBack.blendFactorRGBA[0] = 0.000000;
			TranslucentCullBack.blendFactorRGBA[1] = 0.000000;
			TranslucentCullBack.blendFactorRGBA[2] = 0.000000;
			TranslucentCullBack.blendFactorRGBA[3] = 1.000000;
			TranslucentCullBack.sampleMask      = 0xFFFFFFFF;
		}
		
// SkyLast
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(360,11)
		{
			SkyLast.rasterizer   = RS_SolidCullBack;
			
			SkyLast.depthStencil = DS_ZTestLessEqualNoZWriteNoStencil;
			SkyLast.stencilRef   = 0;
			
			SkyLast.blend           = BS_NoBlending;
			SkyLast.blendFactorRGBA[0] = 0.000000;
			SkyLast.blendFactorRGBA[1] = 0.000000;
			SkyLast.blendFactorRGBA[2] = 0.000000;
			SkyLast.blendFactorRGBA[3] = 1.000000;
			SkyLast.sampleMask      = 0xFFFFFFFF;
		}
		
// Deferred_Light_FullScreen_Additive
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(378,11)
		{
			Deferred_Light_FullScreen_Additive.rasterizer   = RS_SolidNoCull;
			
			Deferred_Light_FullScreen_Additive.depthStencil = DS_ZTestGreaterNoZWriteNoStencil;
			Deferred_Light_FullScreen_Additive.stencilRef   = 0;
			
			Deferred_Light_FullScreen_Additive.blend           = BS_AdditiveBlending;
			Deferred_Light_FullScreen_Additive.blendFactorRGBA[0] = 0.000000;
			Deferred_Light_FullScreen_Additive.blendFactorRGBA[1] = 0.000000;
			Deferred_Light_FullScreen_Additive.blendFactorRGBA[2] = 0.000000;
			Deferred_Light_FullScreen_Additive.blendFactorRGBA[3] = 1.000000;
			Deferred_Light_FullScreen_Additive.sampleMask      = 0xFFFFFFFF;
		}
		
// Deferred_Light_ConvexMesh_Additive
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(404,11)
		{
			Deferred_Light_ConvexMesh_Additive.rasterizer   = RS_EyeOutsideLightVolume;
			
			Deferred_Light_ConvexMesh_Additive.depthStencil = DS_NormalZTestNoWriteNoStencil;
			Deferred_Light_ConvexMesh_Additive.stencilRef   = 0;
			
			Deferred_Light_ConvexMesh_Additive.blend           = BS_AdditiveBlending;
			Deferred_Light_ConvexMesh_Additive.blendFactorRGBA[0] = 0.000000;
			Deferred_Light_ConvexMesh_Additive.blendFactorRGBA[1] = 0.000000;
			Deferred_Light_ConvexMesh_Additive.blendFactorRGBA[2] = 0.000000;
			Deferred_Light_ConvexMesh_Additive.blendFactorRGBA[3] = 1.000000;
			Deferred_Light_ConvexMesh_Additive.sampleMask      = 0xFFFFFFFF;
		}
		
// Build_Shadow_Map
// D:/_/Development/SourceCode/Renderer/GPU/source/r_render_states.fx(429,11)
		{
			Build_Shadow_Map.rasterizer   = RS_BuildShadowMap;
			
			Build_Shadow_Map.depthStencil = DS_NormalZTestWriteNoStencil;
			Build_Shadow_Map.stencilRef   = 0;
			
			Build_Shadow_Map.blend           = BS_NoBlending;
			Build_Shadow_Map.blendFactorRGBA[0] = 0.000000;
			Build_Shadow_Map.blendFactorRGBA[1] = 0.000000;
			Build_Shadow_Map.blendFactorRGBA[2] = 0.000000;
			Build_Shadow_Map.blendFactorRGBA[3] = 1.000000;
			Build_Shadow_Map.sampleMask      = 0xFFFFFFFF;
		}
	}
	
	
	TConstantBuffer< Shared_Globals::PerFrame >	Shared_Globals::cb_PerFrame;
	ID3D11SamplerState* Shared_Globals::pointSampler = nil;
	ID3D11SamplerState* Shared_Globals::linearSampler = nil;
	ID3D11SamplerState* Shared_Globals::anisotropicSampler = nil;
	ID3D11SamplerState* Shared_Globals::pointClampSampler = nil;
	ID3D11SamplerState* Shared_Globals::linearClampSampler = nil;
	ID3D11SamplerState* Shared_Globals::colorMapSampler = nil;
	ID3D11SamplerState* Shared_Globals::detailMapSampler = nil;
	ID3D11SamplerState* Shared_Globals::normalMapSampler = nil;
	ID3D11SamplerState* Shared_Globals::specularMapSampler = nil;
	ID3D11SamplerState* Shared_Globals::attenuationSampler = nil;
	ID3D11SamplerState* Shared_Globals::cubeMapSampler = nil;
	ID3D11SamplerState* Shared_Globals::shadowMapSampler = nil;
	ID3D11SamplerState* Shared_Globals::shadowMapPCFSampler = nil;
	ID3D11SamplerState* Shared_Globals::shadowMapPCFBilinearSampler = nil;
	
	
	TConstantBuffer< Shared_View::PerView >	Shared_View::cb_PerView;
	
	
	TConstantBuffer< Shared_Object::PerObject >	Shared_Object::cb_PerObject;
	
	
	ID3D11ShaderResourceView* Shared_GBuffer::RT_normal_specMul = nil;
	ID3D11ShaderResourceView* Shared_GBuffer::RT_diffuse_specExp = nil;
	ID3D11ShaderResourceView* Shared_GBuffer::RT_linearDepth = nil;
	
	
	TConstantBuffer< Shared_LocalLightData::PerLocalLight >	Shared_LocalLightData::cb_PerLocalLight;
	
	static void SetupSharedSections()
	{
		rxGPU_MARKER( Create_Shared_Sections );

		
		// Make sure that sampler states are laid out contiguously in memory (so we can Set() them in one call)
		{
			ID3D11SamplerState** samplerStatesArray = c_cast(ID3D11SamplerState**) &Shared_Globals::pointSampler;
			mxENSURE( samplerStatesArray + 0 == &Shared_Globals::pointSampler );
			mxENSURE( samplerStatesArray + 1 == &Shared_Globals::linearSampler );
			mxENSURE( samplerStatesArray + 2 == &Shared_Globals::anisotropicSampler );
			mxENSURE( samplerStatesArray + 3 == &Shared_Globals::pointClampSampler );
			mxENSURE( samplerStatesArray + 4 == &Shared_Globals::linearClampSampler );
			mxENSURE( samplerStatesArray + 5 == &Shared_Globals::colorMapSampler );
			mxENSURE( samplerStatesArray + 6 == &Shared_Globals::detailMapSampler );
			mxENSURE( samplerStatesArray + 7 == &Shared_Globals::normalMapSampler );
			mxENSURE( samplerStatesArray + 8 == &Shared_Globals::specularMapSampler );
			mxENSURE( samplerStatesArray + 9 == &Shared_Globals::attenuationSampler );
			mxENSURE( samplerStatesArray + 10 == &Shared_Globals::cubeMapSampler );
			mxENSURE( samplerStatesArray + 11 == &Shared_Globals::shadowMapSampler );
			mxENSURE( samplerStatesArray + 12 == &Shared_Globals::shadowMapPCFSampler );
			mxENSURE( samplerStatesArray + 13 == &Shared_Globals::shadowMapPCFBilinearSampler );
		}
		
		Shared_Globals::cb_PerFrame.Create( graphics.shaders );
		Shared_Globals::pointSampler = SS_Point;
		Shared_Globals::linearSampler = SS_Bilinear;
		Shared_Globals::anisotropicSampler = SS_Aniso;
		Shared_Globals::pointClampSampler = SS_PointClamp;
		Shared_Globals::linearClampSampler = SS_LinearClamp;
		Shared_Globals::colorMapSampler = SS_Bilinear;
		Shared_Globals::detailMapSampler = SS_Bilinear;
		Shared_Globals::normalMapSampler = SS_Bilinear;
		Shared_Globals::specularMapSampler = SS_Bilinear;
		Shared_Globals::attenuationSampler = SS_Bilinear;
		Shared_Globals::cubeMapSampler = SS_Bilinear;
		Shared_Globals::shadowMapSampler = SS_ShadowMap;
		Shared_Globals::shadowMapPCFSampler = SS_ShadowMapPCF;
		Shared_Globals::shadowMapPCFBilinearSampler = SS_ShadowMapPCF_Bilinear;
		Shared_View::cb_PerView.Create( graphics.shaders );
		Shared_Object::cb_PerObject.Create( graphics.shaders );
		
		// Make sure that shader resources are laid out contiguously in memory (so we can Set() them in one call)
		{
			ID3D11ShaderResourceView** shaderResourcesArray = c_cast(ID3D11ShaderResourceView**) &Shared_GBuffer::RT_normal_specMul;
			mxENSURE( shaderResourcesArray + 0 == &Shared_GBuffer::RT_normal_specMul );
			mxENSURE( shaderResourcesArray + 1 == &Shared_GBuffer::RT_diffuse_specExp );
			mxENSURE( shaderResourcesArray + 2 == &Shared_GBuffer::RT_linearDepth );
		}
		
		Shared_GBuffer::RT_normal_specMul = RT_Normal_SpecIntensity.pSRV;
		Shared_GBuffer::RT_diffuse_specExp = RT_Diffuse_SpecPower.pSRV;
		Shared_GBuffer::RT_linearDepth = RT_LinearDepth.pSRV;
		Shared_LocalLightData::cb_PerLocalLight.Create( graphics.shaders );
	}
	
	//===========================================================================
	//	Shaders
	//===========================================================================
	
	
	
	TConstantBuffer< p_adapt_luminance::Data >	p_adapt_luminance::cb_Data;
	ID3D11ShaderResourceView* p_adapt_luminance::currentLuminanceTexture = nil;
	ID3D11ShaderResourceView* p_adapt_luminance::adaptedLuminanceTexture = nil;
	ShaderInstance p_adapt_luminance::shaderInstances[1];
	
	
	void p_adapt_luminance::Initialize()
	{
		
		// Make sure that shader resources are laid out contiguously in memory (so we can Set() them in one call)
		{
			ID3D11ShaderResourceView** shaderResourcesArray = c_cast(ID3D11ShaderResourceView**) &p_adapt_luminance::currentLuminanceTexture;
			mxENSURE( shaderResourcesArray + 0 == &p_adapt_luminance::currentLuminanceTexture );
			mxENSURE( shaderResourcesArray + 1 == &p_adapt_luminance::adaptedLuminanceTexture );
		}
		
		p_adapt_luminance::cb_Data.Create( graphics.shaders );
		
		static GrShaderData d;
		d.uniqueId = p_adapt_luminance::UID;
		d.name = GR_TEXT("p_adapt_luminance");
		d.file = GR_TEXT("p_adapt_luminance_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("FullScreenTriangle_VS");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_adapt_luminance::NumInstances;
		d.instances = p_adapt_luminance::shaderInstances;
		d.getDefines = p_adapt_luminance::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_adapt_luminance::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_adapt_luminance::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_adapt_luminance::Shutdown()
	{
		p_adapt_luminance::cb_Data.Destroy( graphics.shaders );
	}
	
	
	TConstantBuffer< p_batched_lines::Data >	p_batched_lines::cb_Data;
	ID3D11SamplerState* p_batched_lines::linearSampler = nil;
	ID3D11ShaderResourceView* p_batched_lines::textureMap = nil;
	ShaderInstance p_batched_lines::shaderInstances[2];
	
	extern ID3D11SamplerStatePtr SS_Bilinear;
	
	void p_batched_lines::Initialize()
	{
		p_batched_lines::cb_Data.Create( graphics.shaders );
		
		p_batched_lines::linearSampler = SS_Bilinear;
		
		static GrShaderData d;
		d.uniqueId = p_batched_lines::UID;
		d.name = GR_TEXT("p_batched_lines");
		d.file = GR_TEXT("p_batched_lines_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VSMain");
		d.PS_EntryPoint = GR_TEXT("PSMain");
		d.numInstances = p_batched_lines::NumInstances;
		d.instances = p_batched_lines::shaderInstances;
		d.getDefines = p_batched_lines::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_batched_lines::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_batched_lines::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( "bTextureMap", (instanceId & bTextureMap) ? "1" : "0" );
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_batched_lines::Shutdown()
	{
		p_batched_lines::cb_Data.Destroy( graphics.shaders );
	}
	
	
	TConstantBuffer< p_build_hw_shadow_map::Data >	p_build_hw_shadow_map::cb_Data;
	ShaderInstance p_build_hw_shadow_map::shaderInstances[1];
	
	
	void p_build_hw_shadow_map::Initialize()
	{
		p_build_hw_shadow_map::cb_Data.Create( graphics.shaders );
		
		static GrShaderData d;
		d.uniqueId = p_build_hw_shadow_map::UID;
		d.name = GR_TEXT("p_build_hw_shadow_map");
		d.file = GR_TEXT("p_build_hw_shadow_map_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VS_Main");
		d.PS_EntryPoint = nil;	// null pixel shader
		d.numInstances = p_build_hw_shadow_map::NumInstances;
		d.instances = p_build_hw_shadow_map::shaderInstances;
		d.getDefines = p_build_hw_shadow_map::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_build_hw_shadow_map::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_build_hw_shadow_map::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_build_hw_shadow_map::Shutdown()
	{
		p_build_hw_shadow_map::cb_Data.Destroy( graphics.shaders );
	}
	
	
	ShaderInstance p_debug_gbuffer_show_diffuse::shaderInstances[1];
	
	
	void p_debug_gbuffer_show_diffuse::Initialize()
	{
		static GrShaderData d;
		d.uniqueId = p_debug_gbuffer_show_diffuse::UID;
		d.name = GR_TEXT("p_debug_gbuffer_show_diffuse");
		d.file = GR_TEXT("p_debug_gbuffer_show_diffuse_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("FullScreenTriangle_VS");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_debug_gbuffer_show_diffuse::NumInstances;
		d.instances = p_debug_gbuffer_show_diffuse::shaderInstances;
		d.getDefines = p_debug_gbuffer_show_diffuse::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_debug_gbuffer_show_diffuse::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_debug_gbuffer_show_diffuse::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_debug_gbuffer_show_diffuse::Shutdown()
	{
	}
	
	
	TConstantBuffer< p_deferred_directional_light::Data >	p_deferred_directional_light::cb_Data;
	ID3D11ShaderResourceView* p_deferred_directional_light::shadowDepthMap = nil;
	ShaderInstance p_deferred_directional_light::shaderInstances[8];
	
	
	void p_deferred_directional_light::Initialize()
	{
		p_deferred_directional_light::cb_Data.Create( graphics.shaders );
		
		static GrShaderData d;
		d.uniqueId = p_deferred_directional_light::UID;
		d.name = GR_TEXT("p_deferred_directional_light");
		d.file = GR_TEXT("p_deferred_directional_light_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("FullScreenQuad_VS");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_deferred_directional_light::NumInstances;
		d.instances = p_deferred_directional_light::shaderInstances;
		d.getDefines = p_deferred_directional_light::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_deferred_directional_light::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_deferred_directional_light::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( "bLight_CastShadows", (instanceId & bLight_CastShadows) ? "1" : "0" );
		OutDefines.Add().Set( "bEnableSoftShadows", (instanceId & bEnableSoftShadows) ? "1" : "0" );
		OutDefines.Add().Set( "bVisualizeCascades", (instanceId & bVisualizeCascades) ? "1" : "0" );
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_deferred_directional_light::Shutdown()
	{
		p_deferred_directional_light::cb_Data.Destroy( graphics.shaders );
	}
	
	
	ShaderInstance p_deferred_fullscreen_point_light::shaderInstances[2];
	
	
	void p_deferred_fullscreen_point_light::Initialize()
	{
		static GrShaderData d;
		d.uniqueId = p_deferred_fullscreen_point_light::UID;
		d.name = GR_TEXT("p_deferred_fullscreen_point_light");
		d.file = GR_TEXT("p_deferred_fullscreen_point_light_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("FullScreenQuad_VS");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_deferred_fullscreen_point_light::NumInstances;
		d.instances = p_deferred_fullscreen_point_light::shaderInstances;
		d.getDefines = p_deferred_fullscreen_point_light::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_deferred_fullscreen_point_light::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_deferred_fullscreen_point_light::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( "bLight_EnableSpecular", (instanceId & bLight_EnableSpecular) ? "1" : "0" );
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_deferred_fullscreen_point_light::Shutdown()
	{
	}
	
	
	ID3D11ShaderResourceView* p_deferred_fullscreen_spot_light::projector = nil;
	ID3D11ShaderResourceView* p_deferred_fullscreen_spot_light::shadowDepthMap = nil;
	ShaderInstance p_deferred_fullscreen_spot_light::shaderInstances[8];
	
	
	void p_deferred_fullscreen_spot_light::Initialize()
	{
		
		// Make sure that shader resources are laid out contiguously in memory (so we can Set() them in one call)
		{
			ID3D11ShaderResourceView** shaderResourcesArray = c_cast(ID3D11ShaderResourceView**) &p_deferred_fullscreen_spot_light::projector;
			mxENSURE( shaderResourcesArray + 0 == &p_deferred_fullscreen_spot_light::projector );
			mxENSURE( shaderResourcesArray + 1 == &p_deferred_fullscreen_spot_light::shadowDepthMap );
		}
		
		static GrShaderData d;
		d.uniqueId = p_deferred_fullscreen_spot_light::UID;
		d.name = GR_TEXT("p_deferred_fullscreen_spot_light");
		d.file = GR_TEXT("p_deferred_fullscreen_spot_light_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("FullScreenQuad_VS");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_deferred_fullscreen_spot_light::NumInstances;
		d.instances = p_deferred_fullscreen_spot_light::shaderInstances;
		d.getDefines = p_deferred_fullscreen_spot_light::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_deferred_fullscreen_spot_light::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_deferred_fullscreen_spot_light::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( "bLight_EnableSpecular", (instanceId & bLight_EnableSpecular) ? "1" : "0" );
		OutDefines.Add().Set( "bSpotLight_ProjectsTexture", (instanceId & bSpotLight_ProjectsTexture) ? "1" : "0" );
		OutDefines.Add().Set( "bSpotLight_CastShadows", (instanceId & bSpotLight_CastShadows) ? "1" : "0" );
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_deferred_fullscreen_spot_light::Shutdown()
	{
	}
	
	
	ShaderInstance p_deferred_local_point_light::shaderInstances[2];
	
	
	void p_deferred_local_point_light::Initialize()
	{
		static GrShaderData d;
		d.uniqueId = p_deferred_local_point_light::UID;
		d.name = GR_TEXT("p_deferred_local_point_light");
		d.file = GR_TEXT("p_deferred_local_point_light_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VS_LightVolume_Main");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_deferred_local_point_light::NumInstances;
		d.instances = p_deferred_local_point_light::shaderInstances;
		d.getDefines = p_deferred_local_point_light::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_deferred_local_point_light::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_deferred_local_point_light::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( "bLight_EnableSpecular", (instanceId & bLight_EnableSpecular) ? "1" : "0" );
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_deferred_local_point_light::Shutdown()
	{
	}
	
	
	ID3D11ShaderResourceView* p_deferred_local_spot_light::projector = nil;
	ID3D11ShaderResourceView* p_deferred_local_spot_light::shadowDepthMap = nil;
	ShaderInstance p_deferred_local_spot_light::shaderInstances[8];
	
	
	void p_deferred_local_spot_light::Initialize()
	{
		
		// Make sure that shader resources are laid out contiguously in memory (so we can Set() them in one call)
		{
			ID3D11ShaderResourceView** shaderResourcesArray = c_cast(ID3D11ShaderResourceView**) &p_deferred_local_spot_light::projector;
			mxENSURE( shaderResourcesArray + 0 == &p_deferred_local_spot_light::projector );
			mxENSURE( shaderResourcesArray + 1 == &p_deferred_local_spot_light::shadowDepthMap );
		}
		
		static GrShaderData d;
		d.uniqueId = p_deferred_local_spot_light::UID;
		d.name = GR_TEXT("p_deferred_local_spot_light");
		d.file = GR_TEXT("p_deferred_local_spot_light_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VS_LightVolume_Main");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_deferred_local_spot_light::NumInstances;
		d.instances = p_deferred_local_spot_light::shaderInstances;
		d.getDefines = p_deferred_local_spot_light::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_deferred_local_spot_light::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_deferred_local_spot_light::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( "bLight_EnableSpecular", (instanceId & bLight_EnableSpecular) ? "1" : "0" );
		OutDefines.Add().Set( "bSpotLight_ProjectsTexture", (instanceId & bSpotLight_ProjectsTexture) ? "1" : "0" );
		OutDefines.Add().Set( "bSpotLight_CastShadows", (instanceId & bSpotLight_CastShadows) ? "1" : "0" );
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_deferred_local_spot_light::Shutdown()
	{
	}
	
	
	ID3D11ShaderResourceView* p_depth_of_field::sceneColorTexture = nil;
	ID3D11ShaderResourceView* p_depth_of_field::sceneDepthTexture = nil;
	ID3D11ShaderResourceView* p_depth_of_field::blurredSceneTexture = nil;
	ShaderInstance p_depth_of_field::shaderInstances[1];
	
	
	void p_depth_of_field::Initialize()
	{
		
		// Make sure that shader resources are laid out contiguously in memory (so we can Set() them in one call)
		{
			ID3D11ShaderResourceView** shaderResourcesArray = c_cast(ID3D11ShaderResourceView**) &p_depth_of_field::sceneColorTexture;
			mxENSURE( shaderResourcesArray + 0 == &p_depth_of_field::sceneColorTexture );
			mxENSURE( shaderResourcesArray + 1 == &p_depth_of_field::sceneDepthTexture );
			mxENSURE( shaderResourcesArray + 2 == &p_depth_of_field::blurredSceneTexture );
		}
		
		static GrShaderData d;
		d.uniqueId = p_depth_of_field::UID;
		d.name = GR_TEXT("p_depth_of_field");
		d.file = GR_TEXT("p_depth_of_field_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VS_Main");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_depth_of_field::NumInstances;
		d.instances = p_depth_of_field::shaderInstances;
		d.getDefines = p_depth_of_field::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_depth_of_field::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_depth_of_field::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_depth_of_field::Shutdown()
	{
	}
	
	
	TConstantBuffer< p_downscale_4x4::Data >	p_downscale_4x4::cb_Data;
	ID3D11ShaderResourceView* p_downscale_4x4::sourceTexture = nil;
	ShaderInstance p_downscale_4x4::shaderInstances[1];
	
	
	void p_downscale_4x4::Initialize()
	{
		p_downscale_4x4::cb_Data.Create( graphics.shaders );
		
		static GrShaderData d;
		d.uniqueId = p_downscale_4x4::UID;
		d.name = GR_TEXT("p_downscale_4x4");
		d.file = GR_TEXT("p_downscale_4x4_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("FullScreenTriangle_VS");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_downscale_4x4::NumInstances;
		d.instances = p_downscale_4x4::shaderInstances;
		d.getDefines = p_downscale_4x4::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_downscale_4x4::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_downscale_4x4::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_downscale_4x4::Shutdown()
	{
		p_downscale_4x4::cb_Data.Destroy( graphics.shaders );
	}
	
	
	TConstantBuffer< p_downscale_4x4_bright_pass::Data >	p_downscale_4x4_bright_pass::cb_Data;
	ID3D11ShaderResourceView* p_downscale_4x4_bright_pass::sourceTexture = nil;
	ID3D11ShaderResourceView* p_downscale_4x4_bright_pass::avgLuminanceTexture = nil;
	ShaderInstance p_downscale_4x4_bright_pass::shaderInstances[1];
	
	
	void p_downscale_4x4_bright_pass::Initialize()
	{
		
		// Make sure that shader resources are laid out contiguously in memory (so we can Set() them in one call)
		{
			ID3D11ShaderResourceView** shaderResourcesArray = c_cast(ID3D11ShaderResourceView**) &p_downscale_4x4_bright_pass::sourceTexture;
			mxENSURE( shaderResourcesArray + 0 == &p_downscale_4x4_bright_pass::sourceTexture );
			mxENSURE( shaderResourcesArray + 1 == &p_downscale_4x4_bright_pass::avgLuminanceTexture );
		}
		
		p_downscale_4x4_bright_pass::cb_Data.Create( graphics.shaders );
		
		static GrShaderData d;
		d.uniqueId = p_downscale_4x4_bright_pass::UID;
		d.name = GR_TEXT("p_downscale_4x4_bright_pass");
		d.file = GR_TEXT("p_downscale_4x4_bright_pass_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("FullScreenTriangle_VS");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_downscale_4x4_bright_pass::NumInstances;
		d.instances = p_downscale_4x4_bright_pass::shaderInstances;
		d.getDefines = p_downscale_4x4_bright_pass::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_downscale_4x4_bright_pass::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_downscale_4x4_bright_pass::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_downscale_4x4_bright_pass::Shutdown()
	{
		p_downscale_4x4_bright_pass::cb_Data.Destroy( graphics.shaders );
	}
	
	
	TConstantBuffer< p_fullscreen_colored_triangle_shader::Data >	p_fullscreen_colored_triangle_shader::cb_Data;
	ShaderInstance p_fullscreen_colored_triangle_shader::shaderInstances[1];
	
	
	void p_fullscreen_colored_triangle_shader::Initialize()
	{
		p_fullscreen_colored_triangle_shader::cb_Data.Create( graphics.shaders );
		
		static GrShaderData d;
		d.uniqueId = p_fullscreen_colored_triangle_shader::UID;
		d.name = GR_TEXT("p_fullscreen_colored_triangle_shader");
		d.file = GR_TEXT("p_fullscreen_colored_triangle_shader_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("FullScreenTriangle_VS");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_fullscreen_colored_triangle_shader::NumInstances;
		d.instances = p_fullscreen_colored_triangle_shader::shaderInstances;
		d.getDefines = p_fullscreen_colored_triangle_shader::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_fullscreen_colored_triangle_shader::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_fullscreen_colored_triangle_shader::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_fullscreen_colored_triangle_shader::Shutdown()
	{
		p_fullscreen_colored_triangle_shader::cb_Data.Destroy( graphics.shaders );
	}
	
	
	ID3D11SamplerState* p_fullscreen_textured_triangle_shader::linearSampler = nil;
	ID3D11ShaderResourceView* p_fullscreen_textured_triangle_shader::sourceTexture = nil;
	ShaderInstance p_fullscreen_textured_triangle_shader::shaderInstances[1];
	
	extern ID3D11SamplerStatePtr SS_Bilinear;
	
	void p_fullscreen_textured_triangle_shader::Initialize()
	{
		p_fullscreen_textured_triangle_shader::linearSampler = SS_Bilinear;
		
		static GrShaderData d;
		d.uniqueId = p_fullscreen_textured_triangle_shader::UID;
		d.name = GR_TEXT("p_fullscreen_textured_triangle_shader");
		d.file = GR_TEXT("p_fullscreen_textured_triangle_shader_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("FullScreenTriangle_VS");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_fullscreen_textured_triangle_shader::NumInstances;
		d.instances = p_fullscreen_textured_triangle_shader::shaderInstances;
		d.getDefines = p_fullscreen_textured_triangle_shader::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_fullscreen_textured_triangle_shader::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_fullscreen_textured_triangle_shader::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_fullscreen_textured_triangle_shader::Shutdown()
	{
	}
	
	
	ID3D11ShaderResourceView* p_hdr_final_scene_pass::sourceTexture = nil;
	ID3D11ShaderResourceView* p_hdr_final_scene_pass::averageLuminanceTexture = nil;
	ID3D11ShaderResourceView* p_hdr_final_scene_pass::bloomTexture = nil;
	ShaderInstance p_hdr_final_scene_pass::shaderInstances[1];
	
	
	void p_hdr_final_scene_pass::Initialize()
	{
		
		// Make sure that shader resources are laid out contiguously in memory (so we can Set() them in one call)
		{
			ID3D11ShaderResourceView** shaderResourcesArray = c_cast(ID3D11ShaderResourceView**) &p_hdr_final_scene_pass::sourceTexture;
			mxENSURE( shaderResourcesArray + 0 == &p_hdr_final_scene_pass::sourceTexture );
			mxENSURE( shaderResourcesArray + 1 == &p_hdr_final_scene_pass::averageLuminanceTexture );
			mxENSURE( shaderResourcesArray + 2 == &p_hdr_final_scene_pass::bloomTexture );
		}
		
		static GrShaderData d;
		d.uniqueId = p_hdr_final_scene_pass::UID;
		d.name = GR_TEXT("p_hdr_final_scene_pass");
		d.file = GR_TEXT("p_hdr_final_scene_pass_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("FullScreenTriangle_VS");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_hdr_final_scene_pass::NumInstances;
		d.instances = p_hdr_final_scene_pass::shaderInstances;
		d.getDefines = p_hdr_final_scene_pass::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_hdr_final_scene_pass::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_hdr_final_scene_pass::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_hdr_final_scene_pass::Shutdown()
	{
	}
	
	
	TConstantBuffer< p_hit_proxy::Data >	p_hit_proxy::cb_Data;
	ShaderInstance p_hit_proxy::shaderInstances[2];
	
	
	void p_hit_proxy::Initialize()
	{
		p_hit_proxy::cb_Data.Create( graphics.shaders );
		
		static GrShaderData d;
		d.uniqueId = p_hit_proxy::UID;
		d.name = GR_TEXT("p_hit_proxy");
		d.file = GR_TEXT("p_hit_proxy_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VSMain");
		d.PS_EntryPoint = GR_TEXT("PSMain");
		d.numInstances = p_hit_proxy::NumInstances;
		d.instances = p_hit_proxy::shaderInstances;
		d.getDefines = p_hit_proxy::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_hit_proxy::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_hit_proxy::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( "bEnableColorWrites", (instanceId & bEnableColorWrites) ? "1" : "0" );
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_hit_proxy::Shutdown()
	{
		p_hit_proxy::cb_Data.Destroy( graphics.shaders );
	}
	
	
	TConstantBuffer< p_material_phong::Data >	p_material_phong::cb_Data;
	ID3D11ShaderResourceView* p_material_phong::baseMap = nil;
	ID3D11ShaderResourceView* p_material_phong::normalMap = nil;
	ID3D11ShaderResourceView* p_material_phong::specularMap = nil;
	ShaderInstance p_material_phong::shaderInstances[8];
	
	
	void p_material_phong::Initialize()
	{
		
		// Make sure that shader resources are laid out contiguously in memory (so we can Set() them in one call)
		{
			ID3D11ShaderResourceView** shaderResourcesArray = c_cast(ID3D11ShaderResourceView**) &p_material_phong::baseMap;
			mxENSURE( shaderResourcesArray + 0 == &p_material_phong::baseMap );
			mxENSURE( shaderResourcesArray + 1 == &p_material_phong::normalMap );
			mxENSURE( shaderResourcesArray + 2 == &p_material_phong::specularMap );
		}
		
		p_material_phong::cb_Data.Create( graphics.shaders );
		
		static GrShaderData d;
		d.uniqueId = p_material_phong::UID;
		d.name = GR_TEXT("p_material_phong");
		d.file = GR_TEXT("p_material_phong_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VS_Main");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_material_phong::NumInstances;
		d.instances = p_material_phong::shaderInstances;
		d.getDefines = p_material_phong::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_material_phong::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_material_phong::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( "bHasBaseMap", (instanceId & bHasBaseMap) ? "1" : "0" );
		OutDefines.Add().Set( "bHasNormalMap", (instanceId & bHasNormalMap) ? "1" : "0" );
		OutDefines.Add().Set( "bHasSpecularMap", (instanceId & bHasSpecularMap) ? "1" : "0" );
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_material_phong::Shutdown()
	{
		p_material_phong::cb_Data.Destroy( graphics.shaders );
	}
	
	
	TConstantBuffer< p_material_plain_color::Data >	p_material_plain_color::cb_Data;
	ShaderInstance p_material_plain_color::shaderInstances[1];
	
	
	void p_material_plain_color::Initialize()
	{
		p_material_plain_color::cb_Data.Create( graphics.shaders );
		
		static GrShaderData d;
		d.uniqueId = p_material_plain_color::UID;
		d.name = GR_TEXT("p_material_plain_color");
		d.file = GR_TEXT("p_material_plain_color_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VS_Main");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_material_plain_color::NumInstances;
		d.instances = p_material_plain_color::shaderInstances;
		d.getDefines = p_material_plain_color::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_material_plain_color::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_material_plain_color::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_material_plain_color::Shutdown()
	{
		p_material_plain_color::cb_Data.Destroy( graphics.shaders );
	}
	
	
	ID3D11ShaderResourceView* p_sample_luminance_initial::sourceTexture = nil;
	ShaderInstance p_sample_luminance_initial::shaderInstances[1];
	
	
	void p_sample_luminance_initial::Initialize()
	{
		static GrShaderData d;
		d.uniqueId = p_sample_luminance_initial::UID;
		d.name = GR_TEXT("p_sample_luminance_initial");
		d.file = GR_TEXT("p_sample_luminance_initial_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("FullScreenTriangle_VS");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_sample_luminance_initial::NumInstances;
		d.instances = p_sample_luminance_initial::shaderInstances;
		d.getDefines = p_sample_luminance_initial::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_sample_luminance_initial::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_sample_luminance_initial::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_sample_luminance_initial::Shutdown()
	{
	}
	
	
	ID3D11ShaderResourceView* p_separable_sss_reflectance::sceneColorTexture = nil;
	ID3D11ShaderResourceView* p_separable_sss_reflectance::sceneDepthTexture = nil;
	ShaderInstance p_separable_sss_reflectance::shaderInstances[2];
	
	
	void p_separable_sss_reflectance::Initialize()
	{
		
		// Make sure that shader resources are laid out contiguously in memory (so we can Set() them in one call)
		{
			ID3D11ShaderResourceView** shaderResourcesArray = c_cast(ID3D11ShaderResourceView**) &p_separable_sss_reflectance::sceneColorTexture;
			mxENSURE( shaderResourcesArray + 0 == &p_separable_sss_reflectance::sceneColorTexture );
			mxENSURE( shaderResourcesArray + 1 == &p_separable_sss_reflectance::sceneDepthTexture );
		}
		
		static GrShaderData d;
		d.uniqueId = p_separable_sss_reflectance::UID;
		d.name = GR_TEXT("p_separable_sss_reflectance");
		d.file = GR_TEXT("p_separable_sss_reflectance_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VS_Main");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_separable_sss_reflectance::NumInstances;
		d.instances = p_separable_sss_reflectance::shaderInstances;
		d.getDefines = p_separable_sss_reflectance::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_separable_sss_reflectance::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_separable_sss_reflectance::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( "bVerticalBlurDirection", (instanceId & bVerticalBlurDirection) ? "1" : "0" );
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_separable_sss_reflectance::Shutdown()
	{
	}
	
	
	TConstantBuffer< p_skin_shader_build_shadow_map::Data >	p_skin_shader_build_shadow_map::cb_Data;
	ShaderInstance p_skin_shader_build_shadow_map::shaderInstances[1];
	
	
	void p_skin_shader_build_shadow_map::Initialize()
	{
		p_skin_shader_build_shadow_map::cb_Data.Create( graphics.shaders );
		
		static GrShaderData d;
		d.uniqueId = p_skin_shader_build_shadow_map::UID;
		d.name = GR_TEXT("p_skin_shader_build_shadow_map");
		d.file = GR_TEXT("p_skin_shader_build_shadow_map_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VS_Main");
		d.PS_EntryPoint = nil;	// null pixel shader
		d.numInstances = p_skin_shader_build_shadow_map::NumInstances;
		d.instances = p_skin_shader_build_shadow_map::shaderInstances;
		d.getDefines = p_skin_shader_build_shadow_map::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_skin_shader_build_shadow_map::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_skin_shader_build_shadow_map::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_skin_shader_build_shadow_map::Shutdown()
	{
		p_skin_shader_build_shadow_map::cb_Data.Destroy( graphics.shaders );
	}
	
	
	TConstantBuffer< p_skin_shader_forward_pass::Data >	p_skin_shader_forward_pass::cb_Data;
	ID3D11ShaderResourceView* p_skin_shader_forward_pass::baseMap = nil;
	ID3D11ShaderResourceView* p_skin_shader_forward_pass::normalMap = nil;
	ID3D11ShaderResourceView* p_skin_shader_forward_pass::specularMap = nil;
	ID3D11ShaderResourceView* p_skin_shader_forward_pass::shadowDepthMap = nil;
	ID3D11ShaderResourceView* p_skin_shader_forward_pass::beckmannTexture = nil;
	ShaderInstance p_skin_shader_forward_pass::shaderInstances[16];
	
	
	void p_skin_shader_forward_pass::Initialize()
	{
		
		// Make sure that shader resources are laid out contiguously in memory (so we can Set() them in one call)
		{
			ID3D11ShaderResourceView** shaderResourcesArray = c_cast(ID3D11ShaderResourceView**) &p_skin_shader_forward_pass::baseMap;
			mxENSURE( shaderResourcesArray + 0 == &p_skin_shader_forward_pass::baseMap );
			mxENSURE( shaderResourcesArray + 1 == &p_skin_shader_forward_pass::normalMap );
			mxENSURE( shaderResourcesArray + 2 == &p_skin_shader_forward_pass::specularMap );
			mxENSURE( shaderResourcesArray + 3 == &p_skin_shader_forward_pass::shadowDepthMap );
			mxENSURE( shaderResourcesArray + 4 == &p_skin_shader_forward_pass::beckmannTexture );
		}
		
		p_skin_shader_forward_pass::cb_Data.Create( graphics.shaders );
		
		static GrShaderData d;
		d.uniqueId = p_skin_shader_forward_pass::UID;
		d.name = GR_TEXT("p_skin_shader_forward_pass");
		d.file = GR_TEXT("p_skin_shader_forward_pass_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VS_Main");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_skin_shader_forward_pass::NumInstances;
		d.instances = p_skin_shader_forward_pass::shaderInstances;
		d.getDefines = p_skin_shader_forward_pass::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_skin_shader_forward_pass::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_skin_shader_forward_pass::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( "bEnableSSS", (instanceId & bEnableSSS) ? "1" : "0" );
		OutDefines.Add().Set( "bUseNormalMap", (instanceId & bUseNormalMap) ? "1" : "0" );
		OutDefines.Add().Set( "bUseSpecularMap", (instanceId & bUseSpecularMap) ? "1" : "0" );
		OutDefines.Add().Set( "bEnableShadows", (instanceId & bEnableShadows) ? "1" : "0" );
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_skin_shader_forward_pass::Shutdown()
	{
		p_skin_shader_forward_pass::cb_Data.Destroy( graphics.shaders );
	}
	
	
	ID3D11ShaderResourceView* p_skin_shader_gbuffer_pass::baseMap = nil;
	ID3D11ShaderResourceView* p_skin_shader_gbuffer_pass::normalMap = nil;
	ID3D11ShaderResourceView* p_skin_shader_gbuffer_pass::specularMap = nil;
	ShaderInstance p_skin_shader_gbuffer_pass::shaderInstances[4];
	
	
	void p_skin_shader_gbuffer_pass::Initialize()
	{
		
		// Make sure that shader resources are laid out contiguously in memory (so we can Set() them in one call)
		{
			ID3D11ShaderResourceView** shaderResourcesArray = c_cast(ID3D11ShaderResourceView**) &p_skin_shader_gbuffer_pass::baseMap;
			mxENSURE( shaderResourcesArray + 0 == &p_skin_shader_gbuffer_pass::baseMap );
			mxENSURE( shaderResourcesArray + 1 == &p_skin_shader_gbuffer_pass::normalMap );
			mxENSURE( shaderResourcesArray + 2 == &p_skin_shader_gbuffer_pass::specularMap );
		}
		
		static GrShaderData d;
		d.uniqueId = p_skin_shader_gbuffer_pass::UID;
		d.name = GR_TEXT("p_skin_shader_gbuffer_pass");
		d.file = GR_TEXT("p_skin_shader_gbuffer_pass_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VS_Main");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_skin_shader_gbuffer_pass::NumInstances;
		d.instances = p_skin_shader_gbuffer_pass::shaderInstances;
		d.getDefines = p_skin_shader_gbuffer_pass::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_skin_shader_gbuffer_pass::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_skin_shader_gbuffer_pass::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( "bHasNormalMap", (instanceId & bHasNormalMap) ? "1" : "0" );
		OutDefines.Add().Set( "bHasSpecularMap", (instanceId & bHasSpecularMap) ? "1" : "0" );
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_skin_shader_gbuffer_pass::Shutdown()
	{
	}
	
	
	TConstantBuffer< p_sky_dome::Data >	p_sky_dome::cb_Data;
	ID3D11SamplerState* p_sky_dome::skyTextureSampler = nil;
	ID3D11ShaderResourceView* p_sky_dome::skyTexture = nil;
	ShaderInstance p_sky_dome::shaderInstances[2];
	
	extern ID3D11SamplerStatePtr SS_Bilinear;
	
	void p_sky_dome::Initialize()
	{
		p_sky_dome::cb_Data.Create( graphics.shaders );
		
		p_sky_dome::skyTextureSampler = SS_Bilinear;
		
		static GrShaderData d;
		d.uniqueId = p_sky_dome::UID;
		d.name = GR_TEXT("p_sky_dome");
		d.file = GR_TEXT("p_sky_dome_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("VS_Main");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_sky_dome::NumInstances;
		d.instances = p_sky_dome::shaderInstances;
		d.getDefines = p_sky_dome::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_sky_dome::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_sky_dome::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( "bDrawSun", (instanceId & bDrawSun) ? "1" : "0" );
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_sky_dome::Shutdown()
	{
		p_sky_dome::cb_Data.Destroy( graphics.shaders );
	}
	
	
	ID3D11ShaderResourceView* p_uber_post_processing_shader::sceneColorTexture = nil;
	ID3D11ShaderResourceView* p_uber_post_processing_shader::sceneDepthTexture = nil;
	ID3D11ShaderResourceView* p_uber_post_processing_shader::blurredSceneTexture = nil;
	ID3D11ShaderResourceView* p_uber_post_processing_shader::averageLuminanceTexture = nil;
	ID3D11ShaderResourceView* p_uber_post_processing_shader::bloomTexture = nil;
	ShaderInstance p_uber_post_processing_shader::shaderInstances[8];
	
	
	void p_uber_post_processing_shader::Initialize()
	{
		
		// Make sure that shader resources are laid out contiguously in memory (so we can Set() them in one call)
		{
			ID3D11ShaderResourceView** shaderResourcesArray = c_cast(ID3D11ShaderResourceView**) &p_uber_post_processing_shader::sceneColorTexture;
			mxENSURE( shaderResourcesArray + 0 == &p_uber_post_processing_shader::sceneColorTexture );
			mxENSURE( shaderResourcesArray + 1 == &p_uber_post_processing_shader::sceneDepthTexture );
			mxENSURE( shaderResourcesArray + 2 == &p_uber_post_processing_shader::blurredSceneTexture );
			mxENSURE( shaderResourcesArray + 3 == &p_uber_post_processing_shader::averageLuminanceTexture );
			mxENSURE( shaderResourcesArray + 4 == &p_uber_post_processing_shader::bloomTexture );
		}
		
		static GrShaderData d;
		d.uniqueId = p_uber_post_processing_shader::UID;
		d.name = GR_TEXT("p_uber_post_processing_shader");
		d.file = GR_TEXT("p_uber_post_processing_shader_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("FullScreenQuad_VS");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_uber_post_processing_shader::NumInstances;
		d.instances = p_uber_post_processing_shader::shaderInstances;
		d.getDefines = p_uber_post_processing_shader::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_uber_post_processing_shader::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_uber_post_processing_shader::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( "bEnable_Bloom", (instanceId & bEnable_Bloom) ? "1" : "0" );
		OutDefines.Add().Set( "bEnable_HDR", (instanceId & bEnable_HDR) ? "1" : "0" );
		OutDefines.Add().Set( "bEnable_DOF", (instanceId & bEnable_DOF) ? "1" : "0" );
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_uber_post_processing_shader::Shutdown()
	{
	}
	
	
	TConstantBuffer< p_weighted_blur::Data >	p_weighted_blur::cb_Data;
	ID3D11SamplerState* p_weighted_blur::sourceSampler = nil;
	ID3D11ShaderResourceView* p_weighted_blur::sourceTexture = nil;
	ShaderInstance p_weighted_blur::shaderInstances[16];
	
	extern ID3D11SamplerStatePtr SS_PointClamp;
	
	void p_weighted_blur::Initialize()
	{
		p_weighted_blur::cb_Data.Create( graphics.shaders );
		
		p_weighted_blur::sourceSampler = SS_PointClamp;
		
		static GrShaderData d;
		d.uniqueId = p_weighted_blur::UID;
		d.name = GR_TEXT("p_weighted_blur");
		d.file = GR_TEXT("p_weighted_blur_AUTO.hxx");
		d.VS_EntryPoint = GR_TEXT("FullScreenTriangle_VS");
		d.PS_EntryPoint = GR_TEXT("PS_Main");
		d.numInstances = p_weighted_blur::NumInstances;
		d.instances = p_weighted_blur::shaderInstances;
		d.getDefines = p_weighted_blur::GetShaderDefines;
		static ShaderInstanceData instancesData[ p_weighted_blur::NumInstances ];
		d.instancesData = instancesData;
		
		graphics.shaders->RegisterShader(&d);
	}
	
	void p_weighted_blur::GetShaderDefines( rxShaderInstanceId instanceId, dxShaderMacros &OutDefines )
	{
		OutDefines.Empty();
		OutDefines.Add().Set( "iNumSamplesBit0", (instanceId & iNumSamplesBit0) ? "1" : "0" );
		OutDefines.Add().Set( "iNumSamplesBit1", (instanceId & iNumSamplesBit1) ? "1" : "0" );
		OutDefines.Add().Set( "iNumSamplesBit2", (instanceId & iNumSamplesBit2) ? "1" : "0" );
		OutDefines.Add().Set( "iNumSamplesBit3", (instanceId & iNumSamplesBit3) ? "1" : "0" );
		OutDefines.Add().Set( nil, nil );	// append null terminator
	}
	
	void p_weighted_blur::Shutdown()
	{
		p_weighted_blur::cb_Data.Destroy( graphics.shaders );
	}
	ID3D11InputLayoutPtr Vertex_P3f::layout;
	ID3D11InputLayoutPtr Vertex_P3f_TEX2f::layout;
	ID3D11InputLayoutPtr Vertex_P3f_TEX2f_N4Ub_T4Ub::layout;
	ID3D11InputLayoutPtr Vertex_P3f_TEX2f_COL4Ub::layout;
	
	static void CreateInputLayouts()
	{
		rxGPU_MARKER( Create_Input_Layouts );

		{
			dxVertexFormat	vtxFormat;
			{
				D3D11_INPUT_ELEMENT_DESC & elemDesc = vtxFormat.elements.Add();
				elemDesc.SemanticName = "Position";
				elemDesc.SemanticIndex = 0;
				elemDesc.Format = DXGI_FORMAT_R32G32B32_FLOAT;
				elemDesc.InputSlot = 0;
				elemDesc.AlignedByteOffset = Vertex_P3f::xyz_stream_offset;
				elemDesc.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				elemDesc.InstanceDataStepRate = 0;
			}
			graphics.resources->Create_InputLayout( Vertex_P3f::layout, vtxFormat.elements.ToPtr(), vtxFormat.elements.Num() );
			dxDbgSetName( Vertex_P3f::layout, "Vertex_P3f" );
		}
		
		{
			dxVertexFormat	vtxFormat;
			{
				D3D11_INPUT_ELEMENT_DESC & elemDesc = vtxFormat.elements.Add();
				elemDesc.SemanticName = "Position";
				elemDesc.SemanticIndex = 0;
				elemDesc.Format = DXGI_FORMAT_R32G32B32_FLOAT;
				elemDesc.InputSlot = 0;
				elemDesc.AlignedByteOffset = Vertex_P3f_TEX2f::xyz_stream_offset;
				elemDesc.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				elemDesc.InstanceDataStepRate = 0;
			}
			{
				D3D11_INPUT_ELEMENT_DESC & elemDesc = vtxFormat.elements.Add();
				elemDesc.SemanticName = "TexCoord";
				elemDesc.SemanticIndex = 0;
				elemDesc.Format = DXGI_FORMAT_R32G32_FLOAT;
				elemDesc.InputSlot = 0;
				elemDesc.AlignedByteOffset = Vertex_P3f_TEX2f::uv_stream_offset;
				elemDesc.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				elemDesc.InstanceDataStepRate = 0;
			}
			graphics.resources->Create_InputLayout( Vertex_P3f_TEX2f::layout, vtxFormat.elements.ToPtr(), vtxFormat.elements.Num() );
			dxDbgSetName( Vertex_P3f_TEX2f::layout, "Vertex_P3f_TEX2f" );
		}
		
		{
			dxVertexFormat	vtxFormat;
			{
				D3D11_INPUT_ELEMENT_DESC & elemDesc = vtxFormat.elements.Add();
				elemDesc.SemanticName = "Position";
				elemDesc.SemanticIndex = 0;
				elemDesc.Format = DXGI_FORMAT_R32G32B32_FLOAT;
				elemDesc.InputSlot = 0;
				elemDesc.AlignedByteOffset = Vertex_P3f_TEX2f_N4Ub_T4Ub::xyz_stream_offset;
				elemDesc.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				elemDesc.InstanceDataStepRate = 0;
			}
			{
				D3D11_INPUT_ELEMENT_DESC & elemDesc = vtxFormat.elements.Add();
				elemDesc.SemanticName = "TexCoord";
				elemDesc.SemanticIndex = 0;
				elemDesc.Format = DXGI_FORMAT_R32G32_FLOAT;
				elemDesc.InputSlot = 1;
				elemDesc.AlignedByteOffset = Vertex_P3f_TEX2f_N4Ub_T4Ub::uv_stream_offset;
				elemDesc.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				elemDesc.InstanceDataStepRate = 0;
			}
			{
				D3D11_INPUT_ELEMENT_DESC & elemDesc = vtxFormat.elements.Add();
				elemDesc.SemanticName = "Normal";
				elemDesc.SemanticIndex = 0;
				elemDesc.Format = DXGI_FORMAT_R8G8B8A8_UINT;
				elemDesc.InputSlot = 1;
				elemDesc.AlignedByteOffset = Vertex_P3f_TEX2f_N4Ub_T4Ub::N_stream_offset;
				elemDesc.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				elemDesc.InstanceDataStepRate = 0;
			}
			{
				D3D11_INPUT_ELEMENT_DESC & elemDesc = vtxFormat.elements.Add();
				elemDesc.SemanticName = "Tangent";
				elemDesc.SemanticIndex = 0;
				elemDesc.Format = DXGI_FORMAT_R8G8B8A8_UINT;
				elemDesc.InputSlot = 1;
				elemDesc.AlignedByteOffset = Vertex_P3f_TEX2f_N4Ub_T4Ub::T_stream_offset;
				elemDesc.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				elemDesc.InstanceDataStepRate = 0;
			}
			graphics.resources->Create_InputLayout( Vertex_P3f_TEX2f_N4Ub_T4Ub::layout, vtxFormat.elements.ToPtr(), vtxFormat.elements.Num() );
			dxDbgSetName( Vertex_P3f_TEX2f_N4Ub_T4Ub::layout, "Vertex_P3f_TEX2f_N4Ub_T4Ub" );
		}
		
		{
			dxVertexFormat	vtxFormat;
			{
				D3D11_INPUT_ELEMENT_DESC & elemDesc = vtxFormat.elements.Add();
				elemDesc.SemanticName = "Position";
				elemDesc.SemanticIndex = 0;
				elemDesc.Format = DXGI_FORMAT_R32G32B32_FLOAT;
				elemDesc.InputSlot = 0;
				elemDesc.AlignedByteOffset = Vertex_P3f_TEX2f_COL4Ub::xyz_stream_offset;
				elemDesc.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				elemDesc.InstanceDataStepRate = 0;
			}
			{
				D3D11_INPUT_ELEMENT_DESC & elemDesc = vtxFormat.elements.Add();
				elemDesc.SemanticName = "TexCoord";
				elemDesc.SemanticIndex = 0;
				elemDesc.Format = DXGI_FORMAT_R32G32_FLOAT;
				elemDesc.InputSlot = 0;
				elemDesc.AlignedByteOffset = Vertex_P3f_TEX2f_COL4Ub::uv_stream_offset;
				elemDesc.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				elemDesc.InstanceDataStepRate = 0;
			}
			{
				D3D11_INPUT_ELEMENT_DESC & elemDesc = vtxFormat.elements.Add();
				elemDesc.SemanticName = "Color";
				elemDesc.SemanticIndex = 0;
				elemDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
				elemDesc.InputSlot = 0;
				elemDesc.AlignedByteOffset = Vertex_P3f_TEX2f_COL4Ub::rgba_stream_offset;
				elemDesc.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				elemDesc.InstanceDataStepRate = 0;
			}
			graphics.resources->Create_InputLayout( Vertex_P3f_TEX2f_COL4Ub::layout, vtxFormat.elements.ToPtr(), vtxFormat.elements.Num() );
			dxDbgSetName( Vertex_P3f_TEX2f_COL4Ub::layout, "Vertex_P3f_TEX2f_COL4Ub" );
		}
		
	}
	void Vertex_P3f::AssembleVertexData( const IndexedMesh& src, VertexData& dest )
	{
		dest.streams.SetNum( NumStreams );
		
		const SizeT vertexCount = src.numVertices;
		
		dest.streams[ xyz_stream ].stride = xyz_stream_size;
		dest.streams[ xyz_stream ].SetNum( vertexCount );
		
		TCopyVertices( c_cast(float3*)dest.streams[ xyz_stream ].ToVoidPtr(), src.positions,
			vertexCount, xyz_stream_size, xyz_stream_offset );
		
	}
	
	void Vertex_P3f_TEX2f::AssembleVertexData( const IndexedMesh& src, VertexData& dest )
	{
		dest.streams.SetNum( NumStreams );
		
		const SizeT vertexCount = src.numVertices;
		
		dest.streams[ xyz_uv_stream ].stride = xyz_uv_stream_size;
		dest.streams[ xyz_uv_stream ].SetNum( vertexCount );
		
		TCopyVertices( c_cast(float3*)dest.streams[ xyz_uv_stream ].ToVoidPtr(), src.positions,
			vertexCount, xyz_uv_stream_size, xyz_stream_offset );
		
		TCopyVertices( c_cast(float2*)dest.streams[ xyz_uv_stream ].ToVoidPtr(), src.texCoords,
			vertexCount, xyz_uv_stream_size, uv_stream_offset );
		
	}
	
	void Vertex_P3f_TEX2f_N4Ub_T4Ub::AssembleVertexData( const IndexedMesh& src, VertexData& dest )
	{
		dest.streams.SetNum( NumStreams );
		
		const SizeT vertexCount = src.numVertices;
		
		dest.streams[ xyz_stream ].stride = xyz_stream_size;
		dest.streams[ xyz_stream ].SetNum( vertexCount );
		
		TCopyVertices( c_cast(float3*)dest.streams[ xyz_stream ].ToVoidPtr(), src.positions,
			vertexCount, xyz_stream_size, xyz_stream_offset );
		
		
		dest.streams[ uv_N_T_stream ].stride = uv_N_T_stream_size;
		dest.streams[ uv_N_T_stream ].SetNum( vertexCount );
		
		TCopyVertices( c_cast(float2*)dest.streams[ uv_N_T_stream ].ToVoidPtr(), src.texCoords,
			vertexCount, uv_N_T_stream_size, uv_stream_offset );
		
		TCopyVertices( c_cast(rxNormal4*)dest.streams[ uv_N_T_stream ].ToVoidPtr(), src.normals,
			vertexCount, uv_N_T_stream_size, N_stream_offset );
		
		TCopyVertices( c_cast(rxNormal4*)dest.streams[ uv_N_T_stream ].ToVoidPtr(), src.tangents,
			vertexCount, uv_N_T_stream_size, T_stream_offset );
		
	}
	
	void Vertex_P3f_TEX2f_COL4Ub::AssembleVertexData( const IndexedMesh& src, VertexData& dest )
	{
		dest.streams.SetNum( NumStreams );
		
		const SizeT vertexCount = src.numVertices;
		
		dest.streams[ xyz_uv_rgba_stream ].stride = xyz_uv_rgba_stream_size;
		dest.streams[ xyz_uv_rgba_stream ].SetNum( vertexCount );
		
		TCopyVertices( c_cast(float3*)dest.streams[ xyz_uv_rgba_stream ].ToVoidPtr(), src.positions,
			vertexCount, xyz_uv_rgba_stream_size, xyz_stream_offset );
		
		TCopyVertices( c_cast(float2*)dest.streams[ xyz_uv_rgba_stream ].ToVoidPtr(), src.texCoords,
			vertexCount, xyz_uv_rgba_stream_size, uv_stream_offset );
		
		TCopyVertices( c_cast(R8G8B8A8*)dest.streams[ xyz_uv_rgba_stream ].ToVoidPtr(), src.colors,
			vertexCount, xyz_uv_rgba_stream_size, rgba_stream_offset );
		
	}
	
	
	
	//===========================================================================
	//	Creation / Destruction
	//===========================================================================
	
	void Initialize( const GrShaderLibraryContext& context )
	{
		// create render targets first so that they're placed in the fastest portion of VRAM
		SetupRenderTargets( context.backBufferWidth, context.backBufferHeight );
		SetupSamplerStates();
		SetupDepthStencilStates();
		SetupRasterizerStates();
		SetupBlendStates();
		SetupStateBlocks();
		CreateInputLayouts();
		SetupSharedSections();
		
		rxGPU_MARKER( Create_Shaders );

		// create shader programs
		p_adapt_luminance::Initialize();
		p_batched_lines::Initialize();
		p_build_hw_shadow_map::Initialize();
		p_debug_gbuffer_show_diffuse::Initialize();
		p_deferred_directional_light::Initialize();
		p_deferred_fullscreen_point_light::Initialize();
		p_deferred_fullscreen_spot_light::Initialize();
		p_deferred_local_point_light::Initialize();
		p_deferred_local_spot_light::Initialize();
		p_depth_of_field::Initialize();
		p_downscale_4x4::Initialize();
		p_downscale_4x4_bright_pass::Initialize();
		p_fullscreen_colored_triangle_shader::Initialize();
		p_fullscreen_textured_triangle_shader::Initialize();
		p_hdr_final_scene_pass::Initialize();
		p_hit_proxy::Initialize();
		p_material_phong::Initialize();
		p_material_plain_color::Initialize();
		p_sample_luminance_initial::Initialize();
		p_separable_sss_reflectance::Initialize();
		p_skin_shader_build_shadow_map::Initialize();
		p_skin_shader_forward_pass::Initialize();
		p_skin_shader_gbuffer_pass::Initialize();
		p_sky_dome::Initialize();
		p_uber_post_processing_shader::Initialize();
		p_weighted_blur::Initialize();
	}
	
	void Shutdown()
	{
		{
			rxGPU_MARKER( Release_Shaders );

			p_adapt_luminance::Shutdown();
			p_batched_lines::Shutdown();
			p_build_hw_shadow_map::Shutdown();
			p_debug_gbuffer_show_diffuse::Shutdown();
			p_deferred_directional_light::Shutdown();
			p_deferred_fullscreen_point_light::Shutdown();
			p_deferred_fullscreen_spot_light::Shutdown();
			p_deferred_local_point_light::Shutdown();
			p_deferred_local_spot_light::Shutdown();
			p_depth_of_field::Shutdown();
			p_downscale_4x4::Shutdown();
			p_downscale_4x4_bright_pass::Shutdown();
			p_fullscreen_colored_triangle_shader::Shutdown();
			p_fullscreen_textured_triangle_shader::Shutdown();
			p_hdr_final_scene_pass::Shutdown();
			p_hit_proxy::Shutdown();
			p_material_phong::Shutdown();
			p_material_plain_color::Shutdown();
			p_sample_luminance_initial::Shutdown();
			p_separable_sss_reflectance::Shutdown();
			p_skin_shader_build_shadow_map::Shutdown();
			p_skin_shader_forward_pass::Shutdown();
			p_skin_shader_gbuffer_pass::Shutdown();
			p_sky_dome::Shutdown();
			p_uber_post_processing_shader::Shutdown();
			p_weighted_blur::Shutdown();
		}
		{
			rxGPU_MARKER( Release_Sampler_States );

			
			graphics.resources->Destroy_SamplerState( SS_Point );
			graphics.resources->Destroy_SamplerState( SS_Bilinear );
			graphics.resources->Destroy_SamplerState( SS_Trilinear );
			graphics.resources->Destroy_SamplerState( SS_Aniso );
			graphics.resources->Destroy_SamplerState( SS_PointClamp );
			graphics.resources->Destroy_SamplerState( SS_LinearClamp );
			graphics.resources->Destroy_SamplerState( SS_ShadowMap );
			graphics.resources->Destroy_SamplerState( SS_ShadowMapPCF );
			graphics.resources->Destroy_SamplerState( SS_ShadowMapPCF_Bilinear );
			
		}
		{
			rxGPU_MARKER( Release_Depth_Stencil_States );

			graphics.resources->Destroy_DepthStencilState( DS_NormalZTestWriteNoStencil );
			graphics.resources->Destroy_DepthStencilState( DS_NormalZTestNoWriteNoStencil );
			graphics.resources->Destroy_DepthStencilState( DS_NoZTestWriteNoStencil );
			graphics.resources->Destroy_DepthStencilState( DS_ZTestLessEqual_ZWrite_NoStencil );
			graphics.resources->Destroy_DepthStencilState( DS_NormalZTestWrite_StencilWrite );
			graphics.resources->Destroy_DepthStencilState( DS_SeparableSSS );
			graphics.resources->Destroy_DepthStencilState( DS_ZTestGreaterNoZWriteNoStencil );
			graphics.resources->Destroy_DepthStencilState( DS_ZTestLessEqualNoZWriteNoStencil );
			
		}
		{
			rxGPU_MARKER( Release_Rasterizer_States );

			graphics.resources->Destroy_RasterizerState( RS_SolidNoCull );
			graphics.resources->Destroy_RasterizerState( RS_SolidCullBack );
			graphics.resources->Destroy_RasterizerState( RS_SolidCullFront );
			graphics.resources->Destroy_RasterizerState( RS_WireframeCullBack );
			graphics.resources->Destroy_RasterizerState( RS_SolidNoCullNoClip );
			graphics.resources->Destroy_RasterizerState( RS_WireframeNoCullNoClip );
			graphics.resources->Destroy_RasterizerState( RS_EyeOutsideLightVolume );
			graphics.resources->Destroy_RasterizerState( RS_BuildShadowMap );
			
		}
		{
			rxGPU_MARKER( Release_Blend_States );

			graphics.resources->Destroy_BlendState( BS_NoBlending );
			graphics.resources->Destroy_BlendState( BS_AdditiveBlending );
			graphics.resources->Destroy_BlendState( BS_AlphaBlending );
			graphics.resources->Destroy_BlendState( BS_NoBlendingNoColorWrites );
			
		}
		#if MX_EDITOR
		{
			gRenderer.editor->GetTextureInspector()->RemoveDebugItem( RT_Normal_SpecIntensity.pTexture );
			gRenderer.editor->GetTextureInspector()->RemoveDebugItem( RT_Diffuse_SpecPower.pTexture );
			gRenderer.editor->GetTextureInspector()->RemoveDebugItem( RT_LinearDepth.pTexture );
			gRenderer.editor->GetTextureInspector()->RemoveDebugItem( RT_HDR_SceneColor.pTexture );
			gRenderer.editor->GetTextureInspector()->RemoveDebugItem( RT_Ping.pTexture );
			gRenderer.editor->GetTextureInspector()->RemoveDebugItem( RT_Pong.pTexture );
			gRenderer.editor->GetTextureInspector()->RemoveDebugItem( RT_Downscaled_4x4.pTexture );
			gRenderer.editor->GetTextureInspector()->RemoveDebugItem( RT_Downscaled_4x4_B.pTexture );
		}
		#endif // MX_EDITOR
		{
			rxGPU_MARKER( Release_Render_Targets );

			graphics.resources->Destroy_RenderTarget( RT_Normal_SpecIntensity );
			graphics.resources->Destroy_RenderTarget( RT_Diffuse_SpecPower );
			graphics.resources->Destroy_RenderTarget( RT_LinearDepth );
			graphics.resources->Destroy_RenderTarget( RT_HDR_SceneColor );
			graphics.resources->Destroy_RenderTarget( RT_Ping );
			graphics.resources->Destroy_RenderTarget( RT_Pong );
			graphics.resources->Destroy_RenderTarget( RT_Downscaled_4x4 );
			graphics.resources->Destroy_RenderTarget( RT_Downscaled_4x4_B );
			
		}
		ZERO_OUT( Default );
		ZERO_OUT( DebugPrimitives );
		ZERO_OUT( HitProxy_ZTestLessEqualCullBack );
		ZERO_OUT( SolidNoCullNoZTestNoClipNoBlend );
		ZERO_OUT( TranslucentCullBack );
		ZERO_OUT( SkyLast );
		ZERO_OUT( Deferred_Light_FullScreen_Additive );
		ZERO_OUT( Deferred_Light_ConvexMesh_Additive );
		ZERO_OUT( Build_Shadow_Map );
		{
			rxGPU_MARKER( Release_Input_Layouts );

			graphics.resources->Destroy_InputLayout( Vertex_P3f::layout );
			graphics.resources->Destroy_InputLayout( Vertex_P3f_TEX2f::layout );
			graphics.resources->Destroy_InputLayout( Vertex_P3f_TEX2f_N4Ub_T4Ub::layout );
			graphics.resources->Destroy_InputLayout( Vertex_P3f_TEX2f_COL4Ub::layout );
		}
		{
			rxGPU_MARKER( Release_Shared_Sections );

			Shared_Globals::cb_PerFrame.Destroy( graphics.shaders );
			Shared_View::cb_PerView.Destroy( graphics.shaders );
			Shared_Object::cb_PerObject.Destroy( graphics.shaders );
			Shared_LocalLightData::cb_PerLocalLight.Destroy( graphics.shaders );
		}
	}
}
