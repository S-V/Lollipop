/*
=============================================================================
	File:	Float32.h
	Desc:	floating-point arithmetic
	Note:	Some parts have been swiped from idLib (Id Software) and ICE (Pierre Terdiman).
	ToDo:	remove obsolete code not conforming to modern C/C++ strict aliasing rules
=============================================================================
*/

#ifndef __MX_FLOAT_32_H__
#define __MX_FLOAT_32_H__

// integer comparisons are faster than floating-point ones,
// but don't use blindly, it depends on contexts,
// in general, avoid mixing integers and floats in the same expression - LHS issues...
#define MX_USE_CPU_COMPARISONS	1

#ifdef MACOS_X
// for square root estimate instruction
#include <ppc_intrinsics.h>
// for FLT_MIN
#include <float.h>
#endif

#ifdef INFINITY
#undef INFINITY
#endif

#ifdef FLT_EPSILON
#undef FLT_EPSILON
#endif

//
//	IEEE 754 floating point type.
//

/*
		Float IEEE-754 bit representation

		MSB to LSB:
		sign (1 bit), exponent (8 bits), mantissa (23 bits)

		0      0x00000000
		1.0    0x3f800000
		0.5    0x3f000000
		3      0x40400000
		+inf   0x7f800000
		-inf   0xff800000
		+NaN   0x7fc00000 or 0x7ff00000

		in general: number = (sign ? -1:1) * 2^(exponent) * 1.(mantissa bits)

		Specifically, for 32-bit floats:
		(sign ? -1:1) * 2^(127 - biasedExponent) * (1 + mantissa/(2^23)),
		where biasedExponent has a range of [0,255] and mantissa ranges from [0,2^23-1]


	The approximate minimum and maximum values
	that can be represented by the double and float data types:

	Data type	Lowest value	Highest value
	float	1.175494*10-38	3.402823*10+38
	double	2.225074*10-308	1.797693*10+308


	A floating-point value is infinity when the bits in the exponent are all 1
	and the bits in the significand are all zero.
	A minus sign can be used to make a negative infinity.

	A floating-point number is zero when both its significand and its exponent are zero.
	The sign bit, however, can indicate either a positive or negative zero.
	+0.0 and -0. 0 are equal.
	When performing multiplication or division,
	the sign of a zero value affects the sign of the result.

	NaNs
	When is a number not a number?
	When its exponent is all ones and its significand contains any set of bits
	that is not all zeros, which would indicate an infinity.
	A value in this format is known as a NaN (Not a Number).
	The sign bit for a NaN is irrelevant. 

	Quiet NaN
	When the high-order bit of a NaN's significand is 1, it is called a quiet NaN.
	Quiet NaNs can be used in calculations and as arguments in calls to library functions.
	Any mathematical operation involving a quiet NaN results in a quiet NaN. Any floating-point library function that is called with a quiet NaN for a parameter returns a quiet NaN. Also, some floating-point library functions return quiet NaNs when an error has occurred. The macro NAN, which expands to the value of a quiet NaN, is defined in fltpnt.h. 
	
	Signaling NaN
	If the high-order bit of a NaN's significand is zero, it is known as a signaling NaN.
	Whenever a signaling NaN is an operand in a calculation, the result of the calculation is a quiet NaN, and the FE_INVALID exception is raised.
	This is known as triggering a signaling NaN. Unless otherwise specified, the functions in the floating-point library trigger signaling NaNs. 
	Signaling NaNs are never generated by function calls or calculations.
	
	Subnormals
	A subnormal floating-point value is 1 in which the exponent and implied significand bit
	are zero and the significand is not zero.
	These are numbers that are too small to be accurately represented by the floating-point format.
	In general, subnormal numbers do not show up very often; they don't have any particular use and are usually the result of calculations involving very tiny numbers. If a subnormal value is generated, the FE_INEXACT exception is raised.
	Subnormal values involved in a calculation reduce the accuracy of the result.


	Note

	Don't use ugly casts between floats and integers!
	Strict C and C++ aliasing rules make it illegal to have a pointer to a float also be a pointer to an integer. The only legal way to do this is to use a union.
*/

mxNAMESPACE_BEGIN

//
// Enum for the different classes that a floating point number can belong to.
//
enum E_IEEE_754_Float_Class
{
	IEEE_754_FP_Unknown,               /* nobody knows */
	IEEE_754_FP_SNAN,                  /* signaling NaN */
	IEEE_754_FP_QNAN,                  /* quiet NaN */
	IEEE_754_FP_POS_INF,               /* positive infinity */
	IEEE_754_FP_NEG_INF,               /* negative infinity */
	IEEE_754_FP_POS_NORM,              /* positive normalized non-zero */
	IEEE_754_FP_NEG_NORM,              /* negative normalized non-zero */
	IEEE_754_FP_POS_DENORM,            /* positive denormalized non-zero */
	IEEE_754_FP_NEG_DENORM,            /* negative denormalized non-zero */
	IEEE_754_FP_POS_ZERO,              /* +0.0, positive zero */
	IEEE_754_FP_NEG_ZERO,              /* -0.0, negative zero */
};

//
// 32-bit (single precision) floating point data type properties.
//
enum E_IEEE_754_Float32_Standard
{
	IEEE_FLT_EXPONENT_BITS	= 8,
	IEEE_FLT_MANTISSA_BITS	= 23,
	IEEE_FLT_SIGN_BIT		= 31,
	IEEE_FLT_EXPONENT_BIAS	= 127,
};

//
// 64-bit (double precision) floating point data type properties.
//
enum E_IEEE_754_Float64_Standard
{
	IEEE_DBL_EXPONENT_BITS	= 11,
	IEEE_DBL_MANTISSA_BITS	= 52,
	IEEE_DBL_SIGN_BIT		= 63,
	IEEE_DBL_EXPONENT_BIAS	= 1023,
};

//
// 80-bit (extended) floating point data type properties.
//
enum E_IEEE_754_Float80_Standard
{
	IEEE_DBLE_EXPONENT_BIAS	= 0,
	IEEE_DBLE_EXPONENT_BITS	= 15,
	IEEE_DBLE_MANTISSA_BITS	= 63,
	IEEE_DBLE_SIGN_BIT		= 79,
};

// remember about strict C and C++ aliasing rules
union _flint
{
	S4	i;
	F4	f;
};

//  returns 'true' if the given floating point number is an IEEE special (NaN/Inf)
FORCEINLINE bool IsSpecial( const FLOAT& f )
{
	_flint u;
	u.f = f;
	DWORD bits = u.i;
	return ((bits & 0x7F800000) == 0x7F800000);
}

mxNAMESPACE_END



// Don't use these macros, use unions instead.
#define FLOATSIGNBITSET(f)			((*(const UINT32*)&(f)) >> 31)
#define FLOATSIGNBITNOTSET(f)		((~(*(const UINT32*)&(f))) >> 31)
#define FLOATNOTZERO(f)				((*(const UINT32*)&(f)) & ~(1<<31) )




#define	F32_SIGN_BITMASK	0x80000000U
#define F32_EXPON_MANTISSA	0x7FFFFFFFU
#define F32_NAN_MASK		(255<<23)	// 0x7f800000




// Don't use these macros, use unions instead.

#define	FLOAT_IS_NAN(x)			(((*(const UINT32*)&x) & 0x7F800000) == 0x7F800000)
#define FLOAT_IS_INF(x)			(((*(const UINT32*)&x) & 0x7FFFFFFF) == 0x7F800000)
#define FLOAT_IS_IND(x)			((*(const UINT32*)&x) == 0xFFC00000)
#define	FLOAT_IS_DENORMAL(x)	(((*(const UINT32*)&x) & 0x7F800000) == 0x00000000 && \
								 ((*(const UINT32*)&x) & 0x007FFFFF) != 0x00000000 )

#define	FLOAT_IS_INVALID(x)		(FLOAT_IS_NAN(x) || FLOAT_IS_DENORMAL(x))
#define FLOAT_SET_NAN( x )		(*(UINT32 *)&x) |= F32_NAN_MASK

// Unsigned integer representation of a floating-point value.
#define UIR(x)	((UINT&)(x))

// Absolute integer representation of a floating-point value.
//#define AIR(x)	(UIR(x)&0x7FFFFFFF)

// Signed integer representation of a float value.
#define SIR(x)	((INT&)(x))

// Floating-point representation of an integer value.
#define FPR(x)	((F4&)(x))

/*
#define F32_AS_S32(f)			(*((INT32 *) &(f)))
#define F32_AS_U32(f)			(*((UINT32 *) &(f)))
#define F32_AS_U32_POINTER(f)	( ((UINT32 *) &(f)))
*/


/*
// integer representation of 0.0f
#define F32_VALUE_0		0x00000000

// integer representation of 1.0f
#define F32_VALUE_1		0x3F800000

// integer representation of 255.0f
#define F32_VALUE_255	0x437F0000

// integer representation of MAX_FLOAT
#define F32_MAX_FLOAT	0x7F7FFFFF

// integer representation of MIN_FLOAT
#define F32_MIN_FLOAT	0xFF7FFFFF
*/

/*
#if MX_USE_CPU_COMPARISONS

	#define	F32_LOWER_0(f)			(F32_AS_U32(f) >  F32_SIGN_BITMASK)
	#define	F32_LOWER_EQUAL_0(f)	(F32_AS_S32(f) <= F32_VALUE_0)
	#define	F32_GREATER_0(f)		(F32_AS_S32(f) >  F32_VALUE_0)
	#define	F32_GREATER_EQUAL_0(f)	(F32_AS_U32(f) <= F32_SIGN_BITMASK)
	#define	F32_EQUAL_1(f)			(F32_AS_U32(f) == F32_VALUE_1)
	#define	F32_EQUAL_0(f)			((F32_AS_U32(f) & F32_EXPON_MANTISSA) == F32_VALUE_0)
	// only same sign
	#define	F32_A_GREATER_B(a,b)	(F32_AS_S32((a)) > F32_AS_S32((b)))

#else

	#define	F32_LOWER_0(result)			((result) <  0.0f)
	#define	F32_LOWER_EQUAL_0(result)	((result) <= 0.0f)
	#define	F32_GREATER_0(result)		((result) >  0.0f)
	#define	F32_GREATER_EQUAL_0(result)	((result) >= 0.0f)
	#define	F32_EQUAL_1(result)			((result) == 1.0f)
	#define	F32_EQUAL_0(result)			((result) == 0.0f)
	#define	F32_A_GREATER_B(a,b)	((a) > (b))

#endif
*/

/*
------------------------------------------------------------------------------------
Twiddle the bits of floating point numbers exploiting your knowledge of their representation.

For the most common operation, compilers generate already optimized code, but some less common operation may become slightly faster if the bits are manipulated using bitwise integer operators.

One of such operations is the multiplication or the division by a power of two. To perform such operation, it is enough to add or subtract the exponent of the power of two to the exponent part of the floating point number.

For example, given a variable f of type float, conforming to IEEE 754 format, and given an integer positive expression n, instead of the following statement:
f *= pow(2, n);

you can use the following code:
if (*(int*)&f & 0x7FFFFFFF) { // if f==0 do nothing
    *(int*)&f += n << 23; // add n to the exponent
}
------------------------------------------------------------------------------------
*/

mxNAMESPACE_BEGIN

// Don't use these macros, use unions instead.
FORCEINLINE bool IsNAN( FLOAT f )			{ return (UIR(f) & 0x7F800000) == 0x7F800000;	}
FORCEINLINE bool IsIndeterminate( FLOAT f)	{ return (UIR(f) == 0xFFC00000);				}
FORCEINLINE bool IsPlusInf( FLOAT f )		{ return (UIR(f) == 0x7F800000);				}
FORCEINLINE bool IsMinusInf( FLOAT f )		{ return (UIR(f) == 0xFF800000);				}

FORCEINLINE	bool IsValidFloat( FLOAT f )
{
	if( IsNAN(f) )				return false;
	if( IsIndeterminate(f) )	return false;
	if( IsPlusInf(f) )			return false;
	if( IsMinusInf(f) )			return false;
	return true;
}

// The usual way to test for a NaN is to see if it's equal to itself.
// According to the IEEE standard, NaN values have the odd property
// that comparisons involving them are always false.
// That is, for a float f, f != f will be true only if f is NaN.
// But some people on StackOverflow said that some compilers screw this up,
// especially when 'fastmath' option is used.
// (This is used in DX11 SDK.)
/*
FORCEINLINE bool FloatIsNan( FLOAT x )
{
	return x != x;
}
*/

// huge number which should be larger than any valid number used
#define	MX_INFINITY			+1e30f
#define	MX_NEG_INFINITY		-1e30f

// smallest positive number such that 1.0+MX_FLT_EPSILON != 1.0
#define	MX_FLT_EPSILON		1.192092896e-07f

// computes the smallest possible floating-point value
FORCEINLINE FLOAT mxComputeFloatEpsilon()
{
	FLOAT f = 1.0f;
	((ULONG&)f) ^= 1;
	return f - 1.0f;	// it's the same as MX_FLT_EPSILON
}

FORCEINLINE bool mxFuzzyIsZero( FLOAT x, FLOAT epsilon = 1e-6f )
{
	return (x * x) < epsilon;
}

FORCEINLINE FLOAT minf( FLOAT a, FLOAT b )
{
	return (a < b) ? a : b;
}

FORCEINLINE FLOAT maxf( FLOAT a, FLOAT b )
{
	return (a > b) ? a : b;
}

FORCEINLINE FLOAT midf( FLOAT a, FLOAT b )
{
	return (a + b) * 0.5f;
}

FORCEINLINE FLOAT clampf( FLOAT x, FLOAT min, FLOAT max )
{
	return (x < min) ? min : (x > max) ? max : x;
}

FORCEINLINE FLOAT fselect( FLOAT test, FLOAT a, FLOAT b )
{
	return (test >= 0.0f ) ? a : b;	// branchless selection (using conditional move)
}

FORCEINLINE void swapf( FLOAT & x, FLOAT & y )
{
	FLOAT temp = x;
	x = y;
	y = temp;
}

FORCEINLINE FLOAT squaref( FLOAT x )
{
	return (x * x);
}

FORCEINLINE FLOAT cubef( FLOAT x )
{
	return (x * x * x);
}

FORCEINLINE FLOAT signf( FLOAT x )
{
	return (x > 0.0f) ? 1.0f
		: (x < 0.0f) ? -1.0f
		: 0.0f;
}

// returns 'true' if the given two values have different signs
FORCEINLINE BOOL mxDifferentSign( FLOAT x, FLOAT y )
{
	return (UIR(x)^UIR(y)) & F32_SIGN_BITMASK;
}

FORCEINLINE bool mxFuzzyIsNull( FLOAT x, FLOAT epsilon = 1e-5 )
{
    return (mxFabs( x ) <= epsilon);
}

// Tests if the two values are equal (with respect to specified epsilon).
FORCEINLINE bool mxFuzzyCompare( FLOAT x, FLOAT y, FLOAT epsilon = 1e-5 )
{
	return (mxFabs( x - y ) < epsilon);
}


//------------------------------------------------------------
//	Conversions
//------------------------------------------------------------

// A rounding technique that uses a magic number and the structure of floating point numbers
// to approximate the truncation. Recommended in Intel's Software Optimization Cookbook.
//

#define FLOAT_FTOI_MAGIC_NUM	(FLOAT)(3<<21)
#define IT_FTOI_MAGIC_NUM		0x4AC00000

FORCEINLINE INT mxFtoI( FLOAT x )
{
	FLOAT f = x + FLOAT_FTOI_MAGIC_NUM;
	return (*((INT*)&f) - IT_FTOI_MAGIC_NUM) >> 1;
}

/*
// Another version:
#define FIST_MAGIC ((((65536.0f * 65536.0f * 16.0f)+(65536.0f * 0.5f))* 65536.0f))

FORCEINLINE INT QuickFist( float inval )
{
	float dtemp = FIST_MAGIC + inval;
	return ((*(INT32 *)&dtemp) - 0x80000000);
}
*/

// Another version:
FORCEINLINE INT FloatToInt( FLOAT x )
{
	_flint	result, bias;

	bias.i = (x > 0.0f)
		?
		((23 + 127) << 23)
		:
		(((23 + 127) << 23) + (1 << 22))
		;

	result.f = x;

	result.f += bias.f;
	result.i -= bias.i;

	return result.i;
}

// Slow!
FORCEINLINE INT mxFloatToInt( FLOAT x )
{
#if MX_USE_ASM
	return asmFloatToInt( x );
#else
	return mxFtoI( x );
#endif
}

// Slow!
FORCEINLINE FLOAT mxIntToFloat( INT x )
{
	return (FLOAT) x;
}

// Rounds to nearest float.
inline
FLOAT mxSnapFloat( FLOAT x, FLOAT scale )
{
	return scale * (FLOAT)mxFloor( (x / scale) + 0.5f );
}

/*
	This code uses the current rounding mode instead of truncation 
	when performing the conversion. Therefore, the result may differ by 1 from the ftol result.
	The replacement code adds the “magic number” 2^52 * 1.5 to the source operand, then stores the double 
	precision result to memory and retrieves the lower doubleword of the stored result.
	Adding the magic number shifts the original argument to the right inside the double precision mantissa,
	placing the binary point of the sum immediately to the right of the least-significant mantissa bit.
	Extracting the lower doubleword of the sum then delivers the integral portion of the original argument.
	The following conversion code causes a 64-bit store to feed into a 32-bit load. The load is from the 
	lower 32 bits of the 64-bit store, the one case of size mismatch between a store and a dependent load 
	that is specifically supported by the store-to-load-forwarding hardware of the AMD Athlon 64 and 
	AMD Opteron processors.
	See Software Optimization Guide for the AMD64 processors.
*/
FORCEINLINE INT mxDoubleToInt( DOUBLE val )
{
	// Fast round (banker's round) using Sree Kotay's method.
	// This function is much faster than a naive cast from FLOAT to int.

	val	= val + 6755399441055744.0;  // Magic number: 2^52 * 1.5.

#if MX_ENDIAN_LITTLE
	return ((INT *)&val)[0];
#else
	return ((INT *)&val)[1];         // Needs to be [1] for big-endian.
#endif
}

// Fast conversion from a IEEE 32-bit floating point number F in [0,1] to a
// a 32-bit integer I in [0,2^P-1].  The input 'value' is F, the input
// 'power' is P, and the return value of the function is I.
//
INLINE INT mxScaledFloatToInt( FLOAT value, INT power )
{
	INT result;

	INT shift = 150 - power - ((*(INT*)(&value) >> 23) & 0xFF);
	if( shift < 24 )
	{
		result = ((*(INT*)(&value) & 0x007FFFFF) | 0x00800000) >> shift;
		if( result == (1 << power) )
		{
			--result;
		}
	}
	else
	{
		result = 0;
	}

	return result;
}

//
//	ERoundingMethod
//
enum ERoundingMethod
{
	eRoundNearest,
	eRoundUp,        // Round up always in +ve direction
	eRoundDown,      // Round down always in -ve direction
	eRoundTowards0,  // Round values towards zero
	eRoundAwayFrom0, // Round values away from zero
};



inline void float_static_checks()
{
	//{StaticAssert( MAX_WORLD_SIZE*MAX_WORLD_SIZE < MX_INFINITY );}	//removed due to warning: "integral constant overflow"
	{mxSTATIC_ASSERT( BIG_NUMBER*BIG_NUMBER < MX_INFINITY );}
}

mxNAMESPACE_END








mxSWIPED("CryEngine 3");

// http://www.psc.edu/general/software/packages/ieee/ieee.html

/*
	The IEEE standard for floating point arithmetic
	""""""""""""""""""""""""""""""""""""""""""""""""

	Single Precision
	"""""""""""""""""

	The IEEE single precision floating point standard representation requires a 32 bit word, 
	which may be represented as numbered from 0 to 31, left to right. 
	The first bit is the sign bit, S, 
	the next eight bits are the exponent bits, 'E', 
	and the final 23 bits are the fraction 'F':

	S EEEEEEEE FFFFFFFFFFFFFFFFFFFFFFF
	0 1      8 9                    31

	The value V represented by the word may be determined as follows:

	* If E=255 and F is nonzero, then V=NaN ("Not a number")
	* If E=255 and F is zero and S is 1, then V=-Infinity
	* If E=255 and F is zero and S is 0, then V=Infinity
	* If 0<E<255 then V=(-1)**S * 2 ** (E-127) * (1.F) where "1.F" is intended to represent the binary number created by prefixing F with an implicit leading 1 and a binary point.
	* If E=0 and F is nonzero, then V=(-1)**S * 2 ** (-126) * (0.F) These are "unnormalized" values.
	* If E=0 and F is zero and S is 1, then V=-0
	* If E=0 and F is zero and S is 0, then V=0 



	Double Precision
	"""""""""""""""""

	The IEEE double precision floating point standard representation requires a 64 bit word, 
	which may be represented as numbered from 0 to 63, left to right. 
	The first bit is the sign bit, S, 
	the next eleven bits are the exponent bits, 'E', 
	and the final 52 bits are the fraction 'F':

	S EEEEEEEEEEE FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	0 1        11 12                                                63

	The value V represented by the word may be determined as follows:

	* If E=2047 and F is nonzero, then V=NaN ("Not a number")
	* If E=2047 and F is zero and S is 1, then V=-Infinity
	* If E=2047 and F is zero and S is 0, then V=Infinity
	* If 0<E<2047 then V=(-1)**S * 2 ** (E-1023) * (1.F) where "1.F" is intended to represent the binary number created by prefixing F with an implicit leading 1 and a binary point.
	* If E=0 and F is nonzero, then V=(-1)**S * 2 ** (-1022) * (0.F) These are "unnormalized" values.
	* If E=0 and F is zero and S is 1, then V=-0
	* If E=0 and F is zero and S is 0, then V=0 

*/

//--------------------------------------------------------------------------------

#define FloatU32(x)					(*( (UINT32*) &(x) ))
#define FloatU32ExpMask				(0xFF << 23)
#define FloatU32FracMask			((1 << 23) - 1)
#define FloatU32SignMask			(1 << 31)
#define F32NAN						(0x7F800001)					// Produces rock solid fp-exceptions.
#define F32NAN_SAFE					(FloatU32ExpMask | FloatU32FracMask) // This one is not triggering an fp-exception.

#define DoubleU64(x)				(*( (UINT64*) &(x) ))
#define DoubleU64ExpMask			((UINT64)255 << 55)
#define DoubleU64FracMask			(((UINT64)1 << 55) - (UINT64)1)
#define DoubleU64SignMask			((UINT64)1 << 63)

#if defined(__GNUC__)
	#define F64NAN					(0x7FF0000000000001ULL)	// Produces rock solid fp-exceptions.
#else
	#define F64NAN					(0x7FF0000000000001)	// Produces rock solid fp-exceptions.
#endif

#define F64NAN_SAFE					(DoubleU64ExpMask | DoubleU64FracMask)  // This one is not triggering an fp-exception.

//--------------------------------------------------------------------------------

mxNAMESPACE_BEGIN


INLINE bool NumberValid(const float& x)
{
	//return ((FloatU32(x) & FloatU32ExpMask) != FloatU32ExpMask);

	UINT32 i = FloatU32(x);
	UINT32 expmask = FloatU32ExpMask;
	UINT32 iexp = i & expmask;
	bool invalid = (iexp == expmask);

	if (invalid)
	{
		union f32_u
		{
			UINT32 uintVal;
			F4 floatVal;
		};
		f32_u u;	u.uintVal = 0x7F800001;
		float fpe = u.floatVal;
		(void)fpe;
	}

	return !invalid;
}

INLINE bool NumberNAN(const float& x)
{
	return (((FloatU32(x) & FloatU32ExpMask) == FloatU32ExpMask) && 
					((FloatU32(x) & FloatU32FracMask) != 0));
}

INLINE bool NumberINF(const float& x)
{
	return (((FloatU32(x) & FloatU32ExpMask) == FloatU32ExpMask) && 
					((FloatU32(x) & FloatU32FracMask) == 0));
}

INLINE bool NumberDEN(const float& x)
{
	return (((FloatU32(x) & FloatU32ExpMask) == 0) && 
					((FloatU32(x) & FloatU32FracMask) != 0));
}

//--------------------------------------------------------------------------------

INLINE bool NumberValid(const double& x)
{
	return ((DoubleU64(x) & DoubleU64ExpMask) != DoubleU64ExpMask);
}

INLINE bool NumberNAN(const double& x)
{
	return (((DoubleU64(x) & DoubleU64ExpMask) == DoubleU64ExpMask) && 
					((DoubleU64(x) & DoubleU64FracMask) != 0));
}

INLINE bool NumberINF(const double& x)
{
	return (((DoubleU64(x) & DoubleU64ExpMask) == DoubleU64ExpMask) && 
					((DoubleU64(x) & DoubleU64FracMask) == 0));
}

INLINE bool NumberDEN(const double& x)
{
	return (((DoubleU64(x) & DoubleU64ExpMask) == 0) && 
					((DoubleU64(x) & DoubleU64FracMask) != 0));
}

//--------------------------------------------------------------------------------


INLINE bool NumberValid(const INT8 x)
{	
	return true; //integers are always valid
}
INLINE bool NumberValid(const UINT8 x)
{	
	return true; //integers are always valid
}
INLINE bool NumberValid(const INT16 x)
{	
	return true; //integers are always valid
}
INLINE bool NumberValid(const UINT16 x)
{	
	return true; //integers are always valid
}
INLINE bool NumberValid(const INT32 x)
{	
	return true; //integers are always valid
}
INLINE bool NumberValid(const UINT32 x)
{	
	return true; //integers are always valid
}
INLINE bool NumberValid(const INT64 x)
{	
	return true; //integers are always valid
}
INLINE bool NumberValid(const UINT64 x)
{	
	return true; //integers are always valid
}

//--------------------------------------------------------------------------------



/////////////////////////////////////////////////////////////////////////////
 // CRFloat                                                                                                                                     //
 // Copyright (c) 2009 Scirra                                                                                           //
 // Written by Ashley Gullen                                                                                            //
 /////////////////////////////////////////////////////////////////////////////
 /*
        This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/
// Kahan summation wrapper
template<typename FloatType = double>
class KahanCounter {
protected:
	FloatType c, y, t, sum;
public:
	KahanCounter() : c(0.0), sum(0.0) {}

	void add(FloatType v)
	{
		y = v - c;
		t = sum + y;
		c = (t - sum) - y;
		sum = t;
	}

	FloatType total() const
	{
		return sum;
	}
};


// Convert byte to normalized float 0.0 - 1.0 with lookup table
template<typename T>
class byte_to_float_lookup {
public:
	T table[256];

	byte_to_float_lookup()
	{
		// Generate lookup table
		for (UINT i = 0; i < 256; i++)
			table[i] = static_cast<T>(i) / static_cast<T>(255.0);
	}

	inline T operator[](UINT index) const
	{
		Assert(index < 256);
		return table[index];
	}
};

// Instances of lookup tables
//static const byte_to_float_lookup<float> byte_to_float;
//static const byte_to_float_lookup<double> byte_to_double;
//static const byte_to_float_lookup<cr_float> byte_to_crfloat;

mxNAMESPACE_END

//--------------------------------------------------------------------------------





#endif /* !__MX_FLOAT_32_H__ */

//--------------------------------------------------------------//
//				End Of File.									//
//--------------------------------------------------------------//
